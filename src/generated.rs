/* automatically generated by rust-bindgen 0.55.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub type size_t = ::std::os::raw::c_ulong;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
#[doc = " @brief Handle to an entity"]
#[doc = " @ingroup entity"]
#[doc = ""]
#[doc = " A valid entity handle will always have a positive integer value."]
#[doc = " Should the value be negative, it is one of the DDS_RETCODE_*"]
#[doc = " error codes."]
pub type dds_entity_t = i32;
#[doc = " Absolute Time definition"]
pub type dds_time_t = i64;
#[doc = " Relative Time definition in nanoseconds"]
pub type dds_duration_t = i64;
#[doc = " @}"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ddsrt_mtime_t {
    pub v: dds_time_t,
}
#[test]
fn bindgen_test_layout_ddsrt_mtime_t() {
    assert_eq!(
        ::std::mem::size_of::<ddsrt_mtime_t>(),
        8usize,
        concat!("Size of: ", stringify!(ddsrt_mtime_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsrt_mtime_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ddsrt_mtime_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsrt_mtime_t>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsrt_mtime_t),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ddsrt_wctime_t {
    pub v: dds_time_t,
}
#[test]
fn bindgen_test_layout_ddsrt_wctime_t() {
    assert_eq!(
        ::std::mem::size_of::<ddsrt_wctime_t>(),
        8usize,
        concat!("Size of: ", stringify!(ddsrt_wctime_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsrt_wctime_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ddsrt_wctime_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsrt_wctime_t>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsrt_wctime_t),
            "::",
            stringify!(v)
        )
    );
}
pub type dds_return_t = i32;
#[doc = "< free full sample"]
pub const dds_free_op_t_DDS_FREE_ALL: dds_free_op_t = 7;
#[doc = "< free all sample contents, but leave sample pointer intact"]
pub const dds_free_op_t_DDS_FREE_CONTENTS: dds_free_op_t = 3;
#[doc = "< free only the keyfields in a sample"]
pub const dds_free_op_t_DDS_FREE_KEY: dds_free_op_t = 1;
#[doc = " @brief Freeing operation type"]
#[doc = " @ingroup alloc"]
#[doc = " What part of a sample to free"]
pub type dds_free_op_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Perform an alloc() with the default allocator."]
    #[doc = ""]
    #[doc = " @param[in] size number of bytes"]
    #[doc = " @returns new pointer or NULL if out of memory"]
    pub fn dds_alloc(size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Perform a realloc() with the default allocator."]
    #[doc = ""]
    #[doc = " @param[in] ptr previously alloc()'ed pointer"]
    #[doc = " @param[in] size new size"]
    #[doc = " @return new pointer or NULL if out of memory"]
    pub fn dds_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Perform a realloc() with the default allocator. Zero out memory."]
    #[doc = ""]
    #[doc = " @param[in] ptr previously alloc()'ed pointer"]
    #[doc = " @param[in] size new size"]
    #[doc = " @return new pointer or NULL if out of memory"]
    pub fn dds_realloc_zero(
        ptr: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Perform a free() on a memory fragment allocated with the default allocator."]
    #[doc = ""]
    #[doc = " @param[in] ptr previously alloc()'ed pointer"]
    pub fn dds_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " @brief Allocated a string with size, accounting for the null terminator."]
    #[doc = ""]
    #[doc = " @param[in] size number of characters"]
    #[doc = " @returns newly allocated string or NULL if out of memory"]
    pub fn dds_string_alloc(size: size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Duplicate a null-terminated string"]
    #[doc = ""]
    #[doc = " @param[in] str string to duplicate"]
    #[doc = " @returns newly allocated duplicate string, or NULL if out of memory"]
    pub fn dds_string_dup(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Free a string, equivalent to dds_free"]
    #[doc = ""]
    #[doc = " @param[in] str string to free"]
    pub fn dds_string_free(str_: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @brief Free (parts of) a sample according to the \\ref dds_free_op_t"]
    #[doc = ""]
    #[doc = " @param[in] sample sample to free"]
    #[doc = " @param[in] desc topic descriptor of the type this sample was created from."]
    #[doc = " @param[in] op Which parts of the sample to free."]
    pub fn dds_sample_free(
        sample: *mut ::std::os::raw::c_void,
        desc: *const dds_topic_descriptor,
        op: dds_free_op_t,
    );
}
#[doc = " return from subroutine, exits top-level"]
#[doc = "[RTS,   0,   0, 0]"]
pub const dds_stream_opcode_DDS_OP_RTS: dds_stream_opcode = 0;
#[doc = " data field"]
#[doc = "[ADR, nBY,   0, f] [offset]"]
#[doc = "[ADR, BLN,   0, f] [offset]"]
#[doc = "[ADR, ENU,   0, f] [offset] [max]"]
#[doc = "[ADR, BMK,   0, f] [offset] [bits-high] [bits-low]"]
#[doc = "[ADR, STR,   0, f] [offset]"]
#[doc = "[ADR, BST,   0, f] [offset] [max-size]"]
#[doc = ""]
#[doc = "[ADR, SEQ, nBY, f] [offset]"]
#[doc = "[ADR, SEQ, BLN, f] [offset]"]
#[doc = "[ADR, SEQ, ENU, f] [offset] [max]"]
#[doc = "[ADR, SEQ, BMK, f] [offset] [bits-high] [bits-low]"]
#[doc = "[ADR, SEQ, STR, f] [offset]"]
#[doc = "[ADR, SEQ, BST, f] [offset] [max-size]"]
#[doc = "[ADR, SEQ,   s, f] [offset] [elem-size] [next-insn, elem-insn]"]
#[doc = "where s = {SEQ,ARR,UNI,STU,BSQ}"]
#[doc = "[ADR, SEQ, EXT, f] *** not supported"]
#[doc = ""]
#[doc = "[ADR, BSQ, nBY, f] [offset] [sbound]"]
#[doc = "[ADR, BSQ, BLN, f] [offset] [sbound]"]
#[doc = "[ADR, BSQ, ENU, f] [offset] [sbound] [max]"]
#[doc = "[ADR, BSQ, BMK, f] [offset] [sbound] [bits-high] [bits-low]"]
#[doc = "[ADR, BSQ, STR, f] [offset] [sbound]"]
#[doc = "[ADR, BSQ, BST, f] [offset] [sbound] [max-size]"]
#[doc = "[ADR, BSQ,   s, f] [offset] [sbound] [elem-size] [next-insn, elem-insn]"]
#[doc = "where s = {SEQ,ARR,UNI,STU,BSQ}"]
#[doc = "[ADR, BSQ, EXT, f] *** not supported"]
#[doc = ""]
#[doc = "[ADR, ARR, nBY, f] [offset] [alen]"]
#[doc = "[ADR, ARR, BLN, f] [offset] [alen]"]
#[doc = "[ADR, ARR, ENU, f] [offset] [alen] [max]"]
#[doc = "[ADR, ARR, BMK, f] [offset] [alen] [bits-high] [bits-low]"]
#[doc = "[ADR, ARR, STR, f] [offset] [alen]"]
#[doc = "[ADR, ARR, BST, f] [offset] [alen] [0] [max-size]"]
#[doc = "[ADR, ARR,   s, f] [offset] [alen] [next-insn, elem-insn] [elem-size]"]
#[doc = "where s = {SEQ,ARR,UNI,STU,BSQ}"]
#[doc = "[ADR, ARR, EXT, f] *** not supported"]
#[doc = ""]
#[doc = "[ADR, UNI,   d, z] [offset] [alen] [next-insn, cases]"]
#[doc = "[ADR, UNI, ENU, z] [offset] [alen] [next-insn, cases] [max]"]
#[doc = "[ADR, UNI, EXT, f] *** not supported"]
#[doc = "where"]
#[doc = "d = discriminant type of {1BY,2BY,4BY,BLN}"]
#[doc = "z = default present/not present (DDS_OP_FLAG_DEF)"]
#[doc = "offset = discriminant offset"]
#[doc = "max = max enum value"]
#[doc = "followed by alen case labels: in JEQ format"]
#[doc = ""]
#[doc = "[ADR, e | EXT,   0, f] [offset] [next-insn, elem-insn] [elem-size iff \"external\" flag e is set, or flag f has DDS_OP_FLAG_OPT]"]
#[doc = "[ADR, STU,   0, f] *** not supported"]
#[doc = "where"]
#[doc = "s            = subtype"]
#[doc = "e            = external: stored as external data (pointer) (DDS_OP_FLAG_EXT)"]
#[doc = "f            = flags:"]
#[doc = "- key/not key (DDS_OP_FLAG_KEY)"]
#[doc = "- base type member, used with EXT type (DDS_OP_FLAG_BASE)"]
#[doc = "- optional (DDS_OP_FLAG_OPT)"]
#[doc = "- must-understand (DDS_OP_FLAG_MU)"]
#[doc = "- storage size, only for ENU and BMK (n << DDS_OP_FLAG_SZ_SHIFT)"]
#[doc = "[offset]     = field offset from start of element in memory"]
#[doc = "[elem-size]  = element size in memory (elem-size is only included in case 'external' flag is set)"]
#[doc = "[max-size]   = string bound + 1"]
#[doc = "[max]        = max enum value"]
#[doc = "[bits-..]    = identified bits in the bitmask, split into high and low 32 bits"]
#[doc = "[alen]       = array length, number of cases"]
#[doc = "[sbound]     = bounded sequence maximum number of elements"]
#[doc = "[next-insn]  = (unsigned 16 bits) offset to instruction for next field, from start of insn"]
#[doc = "[elem-insn]  = (unsigned 16 bits) offset to first instruction for element, from start of insn"]
#[doc = "[cases]      = (unsigned 16 bits) offset to first case label, from start of insn"]
pub const dds_stream_opcode_DDS_OP_ADR: dds_stream_opcode = 16777216;
#[doc = " jump-to-subroutine (e.g. used for recursive types and appendable unions)"]
#[doc = "[JSR,   0, e]"]
#[doc = "where"]
#[doc = "e = (signed 16 bits) offset to first instruction in subroutine, from start of insn"]
#[doc = "instruction sequence must end in RTS, execution resumes at instruction"]
#[doc = "following JSR"]
pub const dds_stream_opcode_DDS_OP_JSR: dds_stream_opcode = 33554432;
#[doc = " jump-if-equal, used for union cases:"]
#[doc = "[JEQ, nBY, 0] [disc] [offset]"]
#[doc = "[JEQ, BLN, 0] [disc] [offset]"]
#[doc = "[JEQ, STR, 0] [disc] [offset]"]
#[doc = "[JEQ, s,   i] [disc] [offset]"]
#[doc = "[JEQ4, e | nBY, 0] [disc] [offset] 0"]
#[doc = "[JEQ4, e | STR, 0] [disc] [offset] 0"]
#[doc = "[JEQ4, e | ENU, f] [disc] [offset] [max]"]
#[doc = "[JEQ4, EXT, 0] *** not supported, use STU/UNI for external defined types"]
#[doc = "[JEQ4, e | s, i] [disc] [offset] [elem-size iff \"external\" flag e is set, else 0]"]
#[doc = "where"]
#[doc = "e  = external: stored as external data (pointer) (DDS_OP_FLAG_EXT)"]
#[doc = "s  = subtype other than {nBY,STR} for JEQ and {nBY,STR,ENU,EXT} for JEQ4"]
#[doc = "(note that BMK cannot be inline, because it needs 2 additional instructions"]
#[doc = "for the bits that are identified in the bitmask type)"]
#[doc = "i  = (unsigned 16 bits) offset to first instruction for case, from start of insn"]
#[doc = "instruction sequence must end in RTS, at which point executes continues"]
#[doc = "at the next field's instruction as specified by the union"]
#[doc = "f  = size flags for ENU instruction"]
#[doc = ""]
#[doc = "Note that the JEQ instruction is deprecated and replaced by the JEQ4 instruction. The"]
#[doc = "IDL compiler only generates JEQ4 for union cases, the JEQ instruction is included here"]
#[doc = "for backwards compatibility (topic descriptors generated with a previous version of IDLC)"]
pub const dds_stream_opcode_DDS_OP_JEQ: dds_stream_opcode = 50331648;
#[doc = " XCDR2 delimited CDR (inserts DHEADER before type)"]
#[doc = "[DLC, 0, 0]"]
pub const dds_stream_opcode_DDS_OP_DLC: dds_stream_opcode = 67108864;
#[doc = " XCDR2 parameter list CDR (inserts DHEADER before type and EMHEADER before each member)"]
#[doc = "[PLC, 0, 0]"]
#[doc = "followed by a list of JEQ instructions"]
pub const dds_stream_opcode_DDS_OP_PLC: dds_stream_opcode = 83886080;
#[doc = "[PLM,   f, elem-insn] [member id]"]
#[doc = "for members of aggregated mutable types (pl-cdr):"]
#[doc = "where"]
#[doc = "f           = flags:"]
#[doc = "- jump to base type (DDS_OP_FLAG_BASE)"]
#[doc = "[elem-insn] = (unsigned 16 bits) offset to instruction for element, from start of insn"]
#[doc = "when FLAG_BASE is set, this is the offset of the PLM list of the base type"]
#[doc = "[member id] = id for this member (0 in case FLAG_BASE is set)"]
pub const dds_stream_opcode_DDS_OP_PLM: dds_stream_opcode = 100663296;
#[doc = " Key offset list"]
#[doc = "[KOF, 0, n] [offset-1] ... [offset-n]"]
#[doc = "where"]
#[doc = "n      = number of key offsets in following ops"]
#[doc = "offset = Offset of the key field relative to the previous offset, repeated n times when key is"]
#[doc = "in a nested struct. In case of inheritance of mutable structs, a single offset of"]
#[doc = "the key member relative to the first op of the top-level type (index 0)."]
pub const dds_stream_opcode_DDS_OP_KOF: dds_stream_opcode = 117440512;
#[doc = " see comment for JEQ/JEQ4 above"]
pub const dds_stream_opcode_DDS_OP_JEQ4: dds_stream_opcode = 134217728;
#[doc = " @ingroup serialization"]
#[doc = " @brief Topic encoding instruction types"]
pub type dds_stream_opcode = ::std::os::raw::c_uint;
#[doc = "< one byte simple type (char, octet)"]
pub const dds_stream_typecode_DDS_OP_VAL_1BY: dds_stream_typecode = 1;
#[doc = "< two byte simple type ((unsigned) short)"]
pub const dds_stream_typecode_DDS_OP_VAL_2BY: dds_stream_typecode = 2;
#[doc = "< four byte simple type ((unsigned) long, float)"]
pub const dds_stream_typecode_DDS_OP_VAL_4BY: dds_stream_typecode = 3;
#[doc = "< eight byte simple type ((unsigned) long long, double)"]
pub const dds_stream_typecode_DDS_OP_VAL_8BY: dds_stream_typecode = 4;
#[doc = "< string"]
pub const dds_stream_typecode_DDS_OP_VAL_STR: dds_stream_typecode = 5;
#[doc = "< bounded string"]
pub const dds_stream_typecode_DDS_OP_VAL_BST: dds_stream_typecode = 6;
#[doc = "< sequence"]
pub const dds_stream_typecode_DDS_OP_VAL_SEQ: dds_stream_typecode = 7;
#[doc = "< array"]
pub const dds_stream_typecode_DDS_OP_VAL_ARR: dds_stream_typecode = 8;
#[doc = "< union"]
pub const dds_stream_typecode_DDS_OP_VAL_UNI: dds_stream_typecode = 9;
#[doc = "< struct"]
pub const dds_stream_typecode_DDS_OP_VAL_STU: dds_stream_typecode = 10;
#[doc = "< bounded sequence"]
pub const dds_stream_typecode_DDS_OP_VAL_BSQ: dds_stream_typecode = 11;
#[doc = "< enumerated value (long)"]
pub const dds_stream_typecode_DDS_OP_VAL_ENU: dds_stream_typecode = 12;
#[doc = "< field with external definition"]
pub const dds_stream_typecode_DDS_OP_VAL_EXT: dds_stream_typecode = 13;
#[doc = "< boolean"]
pub const dds_stream_typecode_DDS_OP_VAL_BLN: dds_stream_typecode = 14;
#[doc = "< bitmask"]
pub const dds_stream_typecode_DDS_OP_VAL_BMK: dds_stream_typecode = 15;
#[doc = " @ingroup serialization"]
#[doc = " @brief datatypes as recognized by serialization VM."]
pub type dds_stream_typecode = ::std::os::raw::c_uint;
#[doc = "< one byte simple type (char, octet)"]
pub const dds_stream_typecode_primary_DDS_OP_TYPE_1BY: dds_stream_typecode_primary = 65536;
#[doc = "< two byte simple type ((unsigned) short)"]
pub const dds_stream_typecode_primary_DDS_OP_TYPE_2BY: dds_stream_typecode_primary = 131072;
#[doc = "< four byte simple type ((unsigned) long, float)"]
pub const dds_stream_typecode_primary_DDS_OP_TYPE_4BY: dds_stream_typecode_primary = 196608;
#[doc = "< eight byte simple type ((unsigned) long long, double)"]
pub const dds_stream_typecode_primary_DDS_OP_TYPE_8BY: dds_stream_typecode_primary = 262144;
#[doc = "< string"]
pub const dds_stream_typecode_primary_DDS_OP_TYPE_STR: dds_stream_typecode_primary = 327680;
#[doc = "< bounded string"]
pub const dds_stream_typecode_primary_DDS_OP_TYPE_BST: dds_stream_typecode_primary = 393216;
#[doc = "< sequence"]
pub const dds_stream_typecode_primary_DDS_OP_TYPE_SEQ: dds_stream_typecode_primary = 458752;
#[doc = "< array"]
pub const dds_stream_typecode_primary_DDS_OP_TYPE_ARR: dds_stream_typecode_primary = 524288;
#[doc = "< union"]
pub const dds_stream_typecode_primary_DDS_OP_TYPE_UNI: dds_stream_typecode_primary = 589824;
#[doc = "< struct"]
pub const dds_stream_typecode_primary_DDS_OP_TYPE_STU: dds_stream_typecode_primary = 655360;
#[doc = "< bounded sequence"]
pub const dds_stream_typecode_primary_DDS_OP_TYPE_BSQ: dds_stream_typecode_primary = 720896;
#[doc = "< enumerated value (long)"]
pub const dds_stream_typecode_primary_DDS_OP_TYPE_ENU: dds_stream_typecode_primary = 786432;
#[doc = "< field with external definition"]
pub const dds_stream_typecode_primary_DDS_OP_TYPE_EXT: dds_stream_typecode_primary = 851968;
#[doc = "< boolean"]
pub const dds_stream_typecode_primary_DDS_OP_TYPE_BLN: dds_stream_typecode_primary = 917504;
#[doc = "< bitmask"]
pub const dds_stream_typecode_primary_DDS_OP_TYPE_BMK: dds_stream_typecode_primary = 983040;
#[doc = " @ingroup serialization"]
#[doc = " @brief primary type code for DDS_OP_ADR, DDS_OP_JEQ"]
#[doc = " Convinience pre-bitshifted values."]
pub type dds_stream_typecode_primary = ::std::os::raw::c_uint;
#[doc = "< one byte simple type (char, octet)"]
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_1BY: dds_stream_typecode_subtype = 256;
#[doc = "< two byte simple type ((unsigned) short)"]
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_2BY: dds_stream_typecode_subtype = 512;
#[doc = "< four byte simple type ((unsigned) long, float)"]
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_4BY: dds_stream_typecode_subtype = 768;
#[doc = "< eight byte simple type ((unsigned) long long, double)"]
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_8BY: dds_stream_typecode_subtype = 1024;
#[doc = "< string"]
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_STR: dds_stream_typecode_subtype = 1280;
#[doc = "< bounded string"]
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_BST: dds_stream_typecode_subtype = 1536;
#[doc = "< sequence"]
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_SEQ: dds_stream_typecode_subtype = 1792;
#[doc = "< array"]
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_ARR: dds_stream_typecode_subtype = 2048;
#[doc = "< union"]
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_UNI: dds_stream_typecode_subtype = 2304;
#[doc = "< struct"]
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_STU: dds_stream_typecode_subtype = 2560;
#[doc = "< bounded sequence"]
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_BSQ: dds_stream_typecode_subtype = 2816;
#[doc = "< enumerated value (long)"]
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_ENU: dds_stream_typecode_subtype = 3072;
#[doc = "< boolean"]
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_BLN: dds_stream_typecode_subtype = 3584;
#[doc = "< bitmask"]
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_BMK: dds_stream_typecode_subtype = 3840;
#[doc = " @ingroup serialization"]
#[doc = " @brief sub-type code"]
#[doc = "  - encodes element type for DDS_OP_TYPE_{SEQ,ARR},"]
#[doc = "  - discriminant type for DDS_OP_TYPE_UNI"]
#[doc = " Convinience pre-bitshifted values."]
pub type dds_stream_typecode_subtype = ::std::os::raw::c_uint;
#[doc = " @ingroup implementation"]
#[doc = " @brief Datastructure of a Sequence type"]
#[doc = " Container for a sequence of bytes. The general model of this type is also used in IDL output,"]
#[doc = " where the uint8_t * _buffer is replaced by the appropriate subtype of what is contained."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_sequence {
    #[doc = "< Allocated space in _buffer"]
    pub _maximum: u32,
    #[doc = "< Used space in _buffer"]
    pub _length: u32,
    #[doc = "< Sequence of bytes"]
    pub _buffer: *mut u8,
    #[doc = "< Whether a CycloneDDS _free method should free the contained buffer."]
    #[doc = "if you put in your own allocated _buffer set this to false to avoid"]
    #[doc = "CycloneDDS calling free() on it."]
    pub _release: bool,
}
#[test]
fn bindgen_test_layout_dds_sequence() {
    assert_eq!(
        ::std::mem::size_of::<dds_sequence>(),
        24usize,
        concat!("Size of: ", stringify!(dds_sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_sequence>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_sequence))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_sequence>()))._maximum as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sequence),
            "::",
            stringify!(_maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_sequence>()))._length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sequence),
            "::",
            stringify!(_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_sequence>()))._buffer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sequence),
            "::",
            stringify!(_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_sequence>()))._release as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sequence),
            "::",
            stringify!(_release)
        )
    );
}
impl Default for dds_sequence {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " @ingroup implementation"]
#[doc = " @brief Datastructure of a Sequence type"]
#[doc = " Container for a sequence of bytes. The general model of this type is also used in IDL output,"]
#[doc = " where the uint8_t * _buffer is replaced by the appropriate subtype of what is contained."]
pub type dds_sequence_t = dds_sequence;
#[doc = " @ingroup implementation"]
#[doc = " @brief Key Descriptor"]
#[doc = " Used to describe a named key field in a type with the offset from the start of a struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_key_descriptor {
    #[doc = "< name of keyfield"]
    pub m_name: *const ::std::os::raw::c_char,
    #[doc = "< offset from pointer"]
    pub m_offset: u32,
    #[doc = "< m_idx'th key of type"]
    pub m_idx: u32,
}
#[test]
fn bindgen_test_layout_dds_key_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<dds_key_descriptor>(),
        16usize,
        concat!("Size of: ", stringify!(dds_key_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_key_descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_key_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_key_descriptor>())).m_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_key_descriptor),
            "::",
            stringify!(m_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_key_descriptor>())).m_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_key_descriptor),
            "::",
            stringify!(m_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_key_descriptor>())).m_idx as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_key_descriptor),
            "::",
            stringify!(m_idx)
        )
    );
}
impl Default for dds_key_descriptor {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " @ingroup implementation"]
#[doc = " @brief Key Descriptor"]
#[doc = " Used to describe a named key field in a type with the offset from the start of a struct."]
pub type dds_key_descriptor_t = dds_key_descriptor;
#[doc = " @ingroup topic_definition"]
#[doc = " @brief Simple sized byte container to hold serialized type info"]
#[doc = " Holds XTypes information (TypeInformation, TypeMapping) for a"]
#[doc = " type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_type_meta_ser {
    #[doc = "< data pointer"]
    pub data: *mut ::std::os::raw::c_uchar,
    #[doc = "< data size"]
    pub sz: u32,
}
#[test]
fn bindgen_test_layout_dds_type_meta_ser() {
    assert_eq!(
        ::std::mem::size_of::<dds_type_meta_ser>(),
        16usize,
        concat!("Size of: ", stringify!(dds_type_meta_ser))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_type_meta_ser>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_type_meta_ser))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_type_meta_ser>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_type_meta_ser),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_type_meta_ser>())).sz as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_type_meta_ser),
            "::",
            stringify!(sz)
        )
    );
}
impl Default for dds_type_meta_ser {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " @brief Topic Descriptor"]
#[doc = " @ingroup topic_definition"]
#[doc = " @warning Unstable/Private API"]
#[doc = " Contains all meta information about a type, usually produced by the IDL compiler"]
#[doc = " Since this type is not intended for public consumption it can change without warning."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_topic_descriptor {
    #[doc = "< Size of topic type"]
    pub m_size: u32,
    #[doc = "< Alignment of topic type"]
    pub m_align: u32,
    #[doc = "< Flags"]
    pub m_flagset: u32,
    #[doc = "< Number of keys (can be 0)"]
    pub m_nkeys: u32,
    #[doc = "< Type name"]
    pub m_typename: *const ::std::os::raw::c_char,
    #[doc = "< Key descriptors (NULL iff m_nkeys 0)"]
    pub m_keys: *const dds_key_descriptor_t,
    #[doc = "< Number of ops in m_ops"]
    pub m_nops: u32,
    #[doc = "< Marshalling meta data"]
    pub m_ops: *const u32,
    #[doc = "< XML topic description meta data"]
    pub m_meta: *const ::std::os::raw::c_char,
    #[doc = "< XCDR2 serialized TypeInformation, only present if flag DDS_TOPIC_XTYPES_METADATA is set"]
    pub type_information: dds_type_meta_ser,
    #[doc = "< XCDR2 serialized TypeMapping: maps type-id to type object and minimal to complete type id,"]
    #[doc = "only present if flag DDS_TOPIC_XTYPES_METADATA is set"]
    pub type_mapping: dds_type_meta_ser,
    #[doc = "< restrictions on the data representations allowed for the top-level type for this topic,"]
    #[doc = "only present if flag DDS_TOPIC_RESTRICT_DATA_REPRESENTATION"]
    pub restrict_data_representation: u32,
}
#[test]
fn bindgen_test_layout_dds_topic_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<dds_topic_descriptor>(),
        96usize,
        concat!("Size of: ", stringify!(dds_topic_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_topic_descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_topic_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_topic_descriptor>())).m_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_topic_descriptor),
            "::",
            stringify!(m_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_topic_descriptor>())).m_align as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_topic_descriptor),
            "::",
            stringify!(m_align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_topic_descriptor>())).m_flagset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_topic_descriptor),
            "::",
            stringify!(m_flagset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_topic_descriptor>())).m_nkeys as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_topic_descriptor),
            "::",
            stringify!(m_nkeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_topic_descriptor>())).m_typename as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_topic_descriptor),
            "::",
            stringify!(m_typename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_topic_descriptor>())).m_keys as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_topic_descriptor),
            "::",
            stringify!(m_keys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_topic_descriptor>())).m_nops as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_topic_descriptor),
            "::",
            stringify!(m_nops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_topic_descriptor>())).m_ops as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_topic_descriptor),
            "::",
            stringify!(m_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_topic_descriptor>())).m_meta as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_topic_descriptor),
            "::",
            stringify!(m_meta)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_topic_descriptor>())).type_information as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_topic_descriptor),
            "::",
            stringify!(type_information)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_topic_descriptor>())).type_mapping as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_topic_descriptor),
            "::",
            stringify!(type_mapping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_topic_descriptor>())).restrict_data_representation
                as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_topic_descriptor),
            "::",
            stringify!(restrict_data_representation)
        )
    );
}
impl Default for dds_topic_descriptor {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " @brief Topic Descriptor"]
#[doc = " @ingroup topic_definition"]
#[doc = " @warning Unstable/Private API"]
#[doc = " Contains all meta information about a type, usually produced by the IDL compiler"]
#[doc = " Since this type is not intended for public consumption it can change without warning."]
pub type dds_topic_descriptor_t = dds_topic_descriptor;
#[doc = " @ingroup internal"]
#[doc = " @warning Private API"]
#[doc = " @brief Instance handles are uint64_t behind the scenes"]
pub type dds_instance_handle_t = u64;
#[doc = " @ingroup domain"]
#[doc = " @brief Domain IDs are 32 bit unsigned integers."]
pub type dds_domainid_t = u32;
#[doc = "< locate the topic anywhere CycloneDDS knows about"]
pub const dds_find_scope_DDS_FIND_SCOPE_GLOBAL: dds_find_scope = 0;
#[doc = "< locate the topic locally within domain boundaries"]
pub const dds_find_scope_DDS_FIND_SCOPE_LOCAL_DOMAIN: dds_find_scope = 1;
#[doc = "< locate the topic within the current participant"]
pub const dds_find_scope_DDS_FIND_SCOPE_PARTICIPANT: dds_find_scope = 2;
#[doc = " @ingroup topic"]
#[doc = " @brief Scope for dds_find_topic()"]
pub type dds_find_scope = ::std::os::raw::c_uint;
#[doc = " @ingroup topic"]
#[doc = " @brief Scope for dds_find_topic()"]
pub use self::dds_find_scope as dds_find_scope_t;
#[doc = " @brief QoS datatype"]
#[doc = " @ingroup qos"]
#[doc = " QoS structure is opaque"]
pub type dds_qos_t = dds_qos;
#[repr(u32)]
#[doc = " @brief Durability QoS: Applies to Topic, DataReader, DataWriter"]
#[doc = " @ingroup qos"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum dds_durability_kind {
    #[doc = "< Volatile durability"]
    DDS_DURABILITY_VOLATILE = 0,
    #[doc = "< Transient Local durability"]
    DDS_DURABILITY_TRANSIENT_LOCAL = 1,
    #[doc = "< Transient durability"]
    DDS_DURABILITY_TRANSIENT = 2,
    #[doc = "< Persistent durability"]
    DDS_DURABILITY_PERSISTENT = 3,
}
#[doc = " @brief Durability QoS: Applies to Topic, DataReader, DataWriter"]
#[doc = " @ingroup qos"]
pub use self::dds_durability_kind as dds_durability_kind_t;
#[repr(u32)]
#[doc = " @brief History QoS: Applies to Topic, DataReader, DataWriter"]
#[doc = " @ingroup qos"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum dds_history_kind {
    #[doc = "< Keep Last history"]
    DDS_HISTORY_KEEP_LAST = 0,
    #[doc = "< Keep All history"]
    DDS_HISTORY_KEEP_ALL = 1,
}
#[doc = " @brief History QoS: Applies to Topic, DataReader, DataWriter"]
#[doc = " @ingroup qos"]
pub use self::dds_history_kind as dds_history_kind_t;
#[repr(u32)]
#[doc = " @brief Ownership QoS: Applies to Topic, DataReader, DataWriter"]
#[doc = " @ingroup qos"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum dds_ownership_kind {
    #[doc = "< Shared Ownership"]
    DDS_OWNERSHIP_SHARED = 0,
    #[doc = "< Exclusive Ownership"]
    DDS_OWNERSHIP_EXCLUSIVE = 1,
}
#[doc = " @brief Ownership QoS: Applies to Topic, DataReader, DataWriter"]
#[doc = " @ingroup qos"]
pub use self::dds_ownership_kind as dds_ownership_kind_t;
#[repr(u32)]
#[doc = " @brief Liveliness QoS: Applies to Topic, DataReader, DataWriter"]
#[doc = " @ingroup qos"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum dds_liveliness_kind {
    #[doc = "< Automatic liveliness"]
    DDS_LIVELINESS_AUTOMATIC = 0,
    #[doc = "< Manual by Participant liveliness"]
    DDS_LIVELINESS_MANUAL_BY_PARTICIPANT = 1,
    #[doc = "< Manual by Topic liveliness"]
    DDS_LIVELINESS_MANUAL_BY_TOPIC = 2,
}
#[doc = " @brief Liveliness QoS: Applies to Topic, DataReader, DataWriter"]
#[doc = " @ingroup qos"]
pub use self::dds_liveliness_kind as dds_liveliness_kind_t;
#[repr(u32)]
#[doc = " @brief Reliability QoS: Applies to Topic, DataReader, DataWriter"]
#[doc = " @ingroup qos"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum dds_reliability_kind {
    #[doc = "< Best Effort reliability"]
    DDS_RELIABILITY_BEST_EFFORT = 0,
    #[doc = "< Reliable reliability"]
    DDS_RELIABILITY_RELIABLE = 1,
}
#[doc = " @brief Reliability QoS: Applies to Topic, DataReader, DataWriter"]
#[doc = " @ingroup qos"]
pub use self::dds_reliability_kind as dds_reliability_kind_t;
#[repr(u32)]
#[doc = " @brief DestinationOrder QoS: Applies to Topic, DataReader, DataWriter"]
#[doc = " @ingroup qos"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum dds_destination_order_kind {
    #[doc = "< order by reception timestamp"]
    DDS_DESTINATIONORDER_BY_RECEPTION_TIMESTAMP = 0,
    #[doc = "< order by source timestamp"]
    DDS_DESTINATIONORDER_BY_SOURCE_TIMESTAMP = 1,
}
#[doc = " @brief DestinationOrder QoS: Applies to Topic, DataReader, DataWriter"]
#[doc = " @ingroup qos"]
pub use self::dds_destination_order_kind as dds_destination_order_kind_t;
#[repr(u32)]
#[doc = " @brief Presentation QoS: Applies to Publisher, Subscriber"]
#[doc = " @ingroup qos"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum dds_presentation_access_scope_kind {
    #[doc = "< presentation scope per instance"]
    DDS_PRESENTATION_INSTANCE = 0,
    #[doc = "< presentation scope per topic"]
    DDS_PRESENTATION_TOPIC = 1,
    #[doc = "< presentation scope per group"]
    DDS_PRESENTATION_GROUP = 2,
}
#[doc = " @brief Presentation QoS: Applies to Publisher, Subscriber"]
#[doc = " @ingroup qos"]
pub use self::dds_presentation_access_scope_kind as dds_presentation_access_scope_kind_t;
#[repr(u32)]
#[doc = " @brief Ignore-local QoS: Applies to DataReader, DataWriter"]
#[doc = " @ingroup qos"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum dds_ignorelocal_kind {
    #[doc = "< Don't ignore local data"]
    DDS_IGNORELOCAL_NONE = 0,
    #[doc = "< Ignore local data from same participant"]
    DDS_IGNORELOCAL_PARTICIPANT = 1,
    #[doc = "< Ignore local data from same process"]
    DDS_IGNORELOCAL_PROCESS = 2,
}
#[doc = " @brief Ignore-local QoS: Applies to DataReader, DataWriter"]
#[doc = " @ingroup qos"]
pub use self::dds_ignorelocal_kind as dds_ignorelocal_kind_t;
#[doc = "< Do not allow type coercion"]
pub const dds_type_consistency_kind_DDS_TYPE_CONSISTENCY_DISALLOW_TYPE_COERCION:
    dds_type_consistency_kind = 0;
#[doc = "< Allow type coercion"]
pub const dds_type_consistency_kind_DDS_TYPE_CONSISTENCY_ALLOW_TYPE_COERCION:
    dds_type_consistency_kind = 1;
#[doc = " @brief Type-consistency QoS: Applies to DataReader, DataWriter"]
#[doc = " @ingroup qos"]
pub type dds_type_consistency_kind = ::std::os::raw::c_uint;
#[doc = " @brief Type-consistency QoS: Applies to DataReader, DataWriter"]
#[doc = " @ingroup qos"]
pub use self::dds_type_consistency_kind as dds_type_consistency_kind_t;
#[doc = " @brief Data Representation QoS: Applies to Topic, DataReader, DataWriter"]
#[doc = " @ingroup qos"]
pub type dds_data_representation_id_t = i16;
extern "C" {
    #[doc = " @ingroup qos"]
    #[doc = " @brief Allocate memory and initialize default QoS-policies"]
    #[doc = ""]
    #[doc = " @returns - Pointer to the initialized dds_qos_t structure, NULL if unsuccessful."]
    pub fn dds_create_qos() -> *mut dds_qos_t;
}
extern "C" {
    #[doc = " @ingroup qos"]
    #[doc = " @brief Delete memory allocated to QoS-policies structure"]
    #[doc = ""]
    #[doc = " @param[in] qos - Pointer to dds_qos_t structure"]
    pub fn dds_delete_qos(qos: *mut dds_qos_t);
}
extern "C" {
    #[doc = " @ingroup qos"]
    #[doc = " @brief Reset a QoS-policies structure to default values"]
    #[doc = ""]
    #[doc = " @param[in,out] qos - Pointer to the dds_qos_t structure"]
    pub fn dds_reset_qos(qos: *mut dds_qos_t);
}
extern "C" {
    #[doc = " @ingroup qos"]
    #[doc = " @brief Copy all QoS-policies from one structure to another"]
    #[doc = ""]
    #[doc = " @param[in,out] dst - Pointer to the destination dds_qos_t structure"]
    #[doc = " @param[in] src - Pointer to the source dds_qos_t structure"]
    #[doc = ""]
    #[doc = " @returns - Return-code indicating success or failure"]
    pub fn dds_copy_qos(dst: *mut dds_qos_t, src: *const dds_qos_t) -> dds_return_t;
}
extern "C" {
    #[doc = " @ingroup qos"]
    #[doc = " @brief Copy all QoS-policies from one structure to another, unless already set"]
    #[doc = ""]
    #[doc = " Policies are copied from src to dst, unless src already has the policy set to a non-default value."]
    #[doc = ""]
    #[doc = " @param[in,out] dst - Pointer to the destination qos structure"]
    #[doc = " @param[in] src - Pointer to the source qos structure"]
    pub fn dds_merge_qos(dst: *mut dds_qos_t, src: *const dds_qos_t);
}
extern "C" {
    #[doc = " @ingroup qos"]
    #[doc = " @brief Copy all QoS-policies from one structure to another, unless already set"]
    #[doc = ""]
    #[doc = " Policies are copied from src to dst, unless src already has the policy set to a non-default value."]
    #[doc = ""]
    #[doc = " @param[in,out] a - Pointer to the destination qos structure"]
    #[doc = " @param[in] b - Pointer to the source qos structure"]
    #[doc = ""]
    #[doc = " @returns whether the copy was successful."]
    pub fn dds_qos_equal(a: *const dds_qos_t, b: *const dds_qos_t) -> bool;
}
extern "C" {
    #[doc = " @ingroup qos_setters"]
    #[doc = " @brief Set the userdata of a qos structure."]
    #[doc = ""]
    #[doc = " @param[in,out] qos - Pointer to a dds_qos_t structure that will store the userdata"]
    #[doc = " @param[in] value - Pointer to the userdata"]
    #[doc = " @param[in] sz - Size of userdata stored in value"]
    pub fn dds_qset_userdata(qos: *mut dds_qos_t, value: *const ::std::os::raw::c_void, sz: size_t);
}
extern "C" {
    #[doc = " @ingroup qos_setters"]
    #[doc = " @brief Set the topicdata of a qos structure."]
    #[doc = ""]
    #[doc = " @param[in,out] qos - Pointer to a dds_qos_t structure that will store the topicdata"]
    #[doc = " @param[in] value - Pointer to the topicdata"]
    #[doc = " @param[in] sz - Size of the topicdata stored in value"]
    pub fn dds_qset_topicdata(
        qos: *mut dds_qos_t,
        value: *const ::std::os::raw::c_void,
        sz: size_t,
    );
}
extern "C" {
    #[doc = " @ingroup qos_setters"]
    #[doc = " @brief Set the groupdata of a qos structure."]
    #[doc = ""]
    #[doc = " @param[in,out] qos - Pointer to a dds_qos_t structure that will store the groupdata"]
    #[doc = " @param[in] value - Pointer to the group data"]
    #[doc = " @param[in] sz - Size of groupdata stored in value"]
    pub fn dds_qset_groupdata(
        qos: *mut dds_qos_t,
        value: *const ::std::os::raw::c_void,
        sz: size_t,
    );
}
extern "C" {
    #[doc = " @ingroup qos_setters"]
    #[doc = " @brief Set the durability policy of a qos structure."]
    #[doc = ""]
    #[doc = " @param[in,out] qos - Pointer to a dds_qos_t structure that will store the policy"]
    #[doc = " @param[in] kind - Durability kind value"]
    pub fn dds_qset_durability(qos: *mut dds_qos_t, kind: dds_durability_kind_t);
}
extern "C" {
    #[doc = " @ingroup qos_setters"]
    #[doc = " @brief Set the history policy of a qos structure."]
    #[doc = ""]
    #[doc = " Note that depth is only relevant for keep last. If you want limited history for keep all, use dds_qset_resource_limits()."]
    #[doc = ""]
    #[doc = " @param[in,out] qos - Pointer to a dds_qos_t structure that will store the policy"]
    #[doc = " @param[in] kind - History kind value"]
    #[doc = " @param[in] depth - History depth value"]
    pub fn dds_qset_history(qos: *mut dds_qos_t, kind: dds_history_kind_t, depth: i32);
}
extern "C" {
    #[doc = " @ingroup qos_setters"]
    #[doc = " @brief Set the resource limits policy of a qos structure."]
    #[doc = ""]
    #[doc = " @param[in,out] qos - Pointer to a dds_qos_t structure that will store the policy"]
    #[doc = " @param[in] max_samples - Number of samples resource-limit value"]
    #[doc = " @param[in] max_instances - Number of instances resource-limit value"]
    #[doc = " @param[in] max_samples_per_instance - Number of samples per instance resource-limit value"]
    pub fn dds_qset_resource_limits(
        qos: *mut dds_qos_t,
        max_samples: i32,
        max_instances: i32,
        max_samples_per_instance: i32,
    );
}
extern "C" {
    #[doc = " @ingroup qos_setters"]
    #[doc = " @brief Set the presentation policy of a qos structure."]
    #[doc = ""]
    #[doc = " @param[in,out] qos - Pointer to a dds_qos_t structure that will store the policy"]
    #[doc = " @param[in] access_scope - Access-scope kind"]
    #[doc = " @param[in] coherent_access - Coherent access enable value"]
    #[doc = " @param[in] ordered_access - Ordered access enable value"]
    pub fn dds_qset_presentation(
        qos: *mut dds_qos_t,
        access_scope: dds_presentation_access_scope_kind_t,
        coherent_access: bool,
        ordered_access: bool,
    );
}
extern "C" {
    #[doc = " @ingroup qos_setters"]
    #[doc = " @brief Set the lifespan policy of a qos structure."]
    #[doc = ""]
    #[doc = " @param[in,out] qos - Pointer to a dds_qos_t structure that will store the policy"]
    #[doc = " @param[in] lifespan - Lifespan duration (expiration time relative to source timestamp of a sample)"]
    pub fn dds_qset_lifespan(qos: *mut dds_qos_t, lifespan: dds_duration_t);
}
extern "C" {
    #[doc = " @ingroup qos_setters"]
    #[doc = " @brief Set the deadline policy of a qos structure."]
    #[doc = ""]
    #[doc = " @param[in,out] qos - Pointer to a dds_qos_t structure that will store the policy"]
    #[doc = " @param[in] deadline - Deadline duration"]
    pub fn dds_qset_deadline(qos: *mut dds_qos_t, deadline: dds_duration_t);
}
extern "C" {
    #[doc = " @ingroup qos_setters"]
    #[doc = " @brief Set the latency-budget policy of a qos structure"]
    #[doc = ""]
    #[doc = " @param[in,out] qos - Pointer to a dds_qos_t structure that will store the policy"]
    #[doc = " @param[in] duration - Latency budget duration"]
    pub fn dds_qset_latency_budget(qos: *mut dds_qos_t, duration: dds_duration_t);
}
extern "C" {
    #[doc = " @ingroup qos_setters"]
    #[doc = " @brief Set the ownership policy of a qos structure"]
    #[doc = ""]
    #[doc = " @param[in,out] qos - Pointer to a dds_qos_t structure that will store the policy"]
    #[doc = " @param[in] kind - Ownership kind"]
    pub fn dds_qset_ownership(qos: *mut dds_qos_t, kind: dds_ownership_kind_t);
}
extern "C" {
    #[doc = " @ingroup qos_setters"]
    #[doc = " @brief Set the ownership strength policy of a qos structure"]
    #[doc = ""]
    #[doc = " @param[in,out] qos - Pointer to a dds_qos_t structure that will store the policy"]
    #[doc = " @param[in] value - Ownership strength value"]
    pub fn dds_qset_ownership_strength(qos: *mut dds_qos_t, value: i32);
}
extern "C" {
    #[doc = " @ingroup qos_setters"]
    #[doc = " @brief Set the liveliness policy of a qos structure"]
    #[doc = ""]
    #[doc = " @param[in,out] qos - Pointer to a dds_qos_t structure that will store the policy"]
    #[doc = " @param[in] kind - Liveliness kind"]
    #[doc = " @param[in] lease_duration - Lease duration"]
    pub fn dds_qset_liveliness(
        qos: *mut dds_qos_t,
        kind: dds_liveliness_kind_t,
        lease_duration: dds_duration_t,
    );
}
extern "C" {
    #[doc = " @ingroup qos_setters"]
    #[doc = " @brief Set the time-based filter policy of a qos structure"]
    #[doc = ""]
    #[doc = " @param[in,out] qos - Pointer to a dds_qos_t structure that will store the policy"]
    #[doc = " @param[in] minimum_separation - Minimum duration between sample delivery for an instance"]
    pub fn dds_qset_time_based_filter(qos: *mut dds_qos_t, minimum_separation: dds_duration_t);
}
extern "C" {
    #[doc = " @ingroup qos_setters"]
    #[doc = " @brief Set the partition policy of a qos structure"]
    #[doc = ""]
    #[doc = " @param[in,out] qos - Pointer to a dds_qos_t structure that will store the policy"]
    #[doc = " @param[in] n - Number of partitions stored in ps"]
    #[doc = " @param[in] ps - Pointer to string(s) storing partition name(s)"]
    pub fn dds_qset_partition(qos: *mut dds_qos_t, n: u32, ps: *mut *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @ingroup qos_setters"]
    #[doc = " @brief Convenience function to set the partition policy of a qos structure to a"]
    #[doc = " single name.  Name may be a null pointer."]
    #[doc = ""]
    #[doc = " @param[in,out] qos - Pointer to a dds_qos_t structure that will store the policy"]
    #[doc = " @param[in] name - Pointer to the name"]
    pub fn dds_qset_partition1(qos: *mut dds_qos_t, name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @ingroup qos_setters"]
    #[doc = " @brief Set the reliability policy of a qos structure"]
    #[doc = ""]
    #[doc = " @param[in,out] qos - Pointer to a dds_qos_t structure that will store the policy"]
    #[doc = " @param[in] kind - Reliability kind"]
    #[doc = " @param[in] max_blocking_time - Max blocking duration applied when kind is reliable. This is how long the writer will block when its history is full."]
    pub fn dds_qset_reliability(
        qos: *mut dds_qos_t,
        kind: dds_reliability_kind_t,
        max_blocking_time: dds_duration_t,
    );
}
extern "C" {
    #[doc = " @ingroup qos_setters"]
    #[doc = " @brief Set the transport-priority policy of a qos structure"]
    #[doc = ""]
    #[doc = " @param[in,out] qos - Pointer to a dds_qos_t structure that will store the policy"]
    #[doc = " @param[in] value - Priority value"]
    pub fn dds_qset_transport_priority(qos: *mut dds_qos_t, value: i32);
}
extern "C" {
    #[doc = " @ingroup qos_setters"]
    #[doc = " @brief Set the destination-order policy of a qos structure"]
    #[doc = ""]
    #[doc = " @param[in,out] qos - Pointer to a dds_qos_t structure that will store the policy"]
    #[doc = " @param[in] kind - Destination-order kind"]
    pub fn dds_qset_destination_order(qos: *mut dds_qos_t, kind: dds_destination_order_kind_t);
}
extern "C" {
    #[doc = " @ingroup qos_setters"]
    #[doc = " @brief Set the writer data-lifecycle policy of a qos structure"]
    #[doc = ""]
    #[doc = " @param[in,out] qos - Pointer to a dds_qos_t structure that will store the policy"]
    #[doc = " @param[in] autodispose - Automatic disposal of unregistered instances"]
    pub fn dds_qset_writer_data_lifecycle(qos: *mut dds_qos_t, autodispose: bool);
}
extern "C" {
    #[doc = " @ingroup qos_setters"]
    #[doc = " @brief Set the reader data-lifecycle policy of a qos structure"]
    #[doc = ""]
    #[doc = " @param[in,out] qos - Pointer to a dds_qos_t structure that will store the policy"]
    #[doc = " @param[in] autopurge_nowriter_samples_delay - Delay for purging of samples from instances in a no-writers state"]
    #[doc = " @param[in] autopurge_disposed_samples_delay - Delay for purging of samples from disposed instances"]
    pub fn dds_qset_reader_data_lifecycle(
        qos: *mut dds_qos_t,
        autopurge_nowriter_samples_delay: dds_duration_t,
        autopurge_disposed_samples_delay: dds_duration_t,
    );
}
extern "C" {
    #[doc = " @ingroup qos_setters"]
    #[doc = " @brief Set the durability-service policy of a qos structure"]
    #[doc = ""]
    #[doc = " @param[in,out] qos - Pointer to a dds_qos_t structure that will store the policy"]
    #[doc = " @param[in] service_cleanup_delay - Delay for purging of abandoned instances from the durability service"]
    #[doc = " @param[in] history_kind - History policy kind applied by the durability service"]
    #[doc = " @param[in] history_depth - History policy depth applied by the durability service"]
    #[doc = " @param[in] max_samples - Number of samples resource-limit policy applied by the durability service"]
    #[doc = " @param[in] max_instances - Number of instances resource-limit policy applied by the durability service"]
    #[doc = " @param[in] max_samples_per_instance - Number of samples per instance resource-limit policy applied by the durability service"]
    pub fn dds_qset_durability_service(
        qos: *mut dds_qos_t,
        service_cleanup_delay: dds_duration_t,
        history_kind: dds_history_kind_t,
        history_depth: i32,
        max_samples: i32,
        max_instances: i32,
        max_samples_per_instance: i32,
    );
}
extern "C" {
    #[doc = " @ingroup qos_setters"]
    #[doc = " @brief Set the ignore-local policy of a qos structure"]
    #[doc = ""]
    #[doc = " @param[in,out] qos - Pointer to a dds_qos_t structure that will store the policy"]
    #[doc = " @param[in] ignore - True if readers and writers owned by the same participant should be ignored"]
    pub fn dds_qset_ignorelocal(qos: *mut dds_qos_t, ignore: dds_ignorelocal_kind_t);
}
extern "C" {
    #[doc = " @ingroup qos_getters"]
    #[doc = " @brief Get the userdata from a qos structure"]
    #[doc = ""]
    #[doc = " @param[in] qos - Pointer to a dds_qos_t structure storing the policy"]
    #[doc = " @param[in,out] value - Pointer that will store the userdata.  If sz = 0, then a null pointer, else it is a pointer to an allocated buffer of sz+1 bytes where the last byte is always 0"]
    #[doc = " @param[in,out] sz - Pointer that will store the size of userdata"]
    #[doc = ""]
    #[doc = " @returns - false iff any of the arguments is invalid or the qos is not present in the qos object"]
    pub fn dds_qget_userdata(
        qos: *const dds_qos_t,
        value: *mut *mut ::std::os::raw::c_void,
        sz: *mut size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @ingroup qos_getters"]
    #[doc = " @brief Get the topicdata from a qos structure"]
    #[doc = ""]
    #[doc = " @param[in] qos - Pointer to a dds_qos_t structure storing the policy"]
    #[doc = " @param[in,out] value - Pointer that will store the topicdata.  If sz = 0, then a null pointer, else it is a pointer to an allocated buffer of sz+1 bytes where the last byte is always 0"]
    #[doc = " @param[in,out] sz - Pointer that will store the size of topicdata"]
    #[doc = ""]
    #[doc = " @returns - false iff any of the arguments is invalid or the qos is not present in the qos object"]
    pub fn dds_qget_topicdata(
        qos: *const dds_qos_t,
        value: *mut *mut ::std::os::raw::c_void,
        sz: *mut size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @ingroup qos_getters"]
    #[doc = " @brief Get the groupdata from a qos structure"]
    #[doc = ""]
    #[doc = " @param[in] qos - Pointer to a dds_qos_t structure storing the policy"]
    #[doc = " @param[in,out] value - Pointer that will store the groupdata.  If sz = 0, then a null pointer, else it is a pointer to an allocated buffer of sz+1 bytes where the last byte is always 0"]
    #[doc = " @param[in,out] sz - Pointer that will store the size of groupdata"]
    #[doc = ""]
    #[doc = " @returns - false iff any of the arguments is invalid or the qos is not present in the qos object"]
    pub fn dds_qget_groupdata(
        qos: *const dds_qos_t,
        value: *mut *mut ::std::os::raw::c_void,
        sz: *mut size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @ingroup qos_getters"]
    #[doc = " @brief Get the durability policy from a qos structure"]
    #[doc = ""]
    #[doc = " @param[in] qos - Pointer to a dds_qos_t structure storing the policy"]
    #[doc = " @param[in,out] kind - Pointer that will store the durability kind"]
    #[doc = ""]
    #[doc = " @returns - false iff any of the arguments is invalid or the qos is not present in the qos object"]
    pub fn dds_qget_durability(qos: *const dds_qos_t, kind: *mut dds_durability_kind_t) -> bool;
}
extern "C" {
    #[doc = " @ingroup qos_getters"]
    #[doc = " @brief Get the history policy from a qos structure"]
    #[doc = ""]
    #[doc = " @param[in] qos - Pointer to a dds_qos_t structure storing the policy"]
    #[doc = " @param[in,out] kind - Pointer that will store the history kind (optional)"]
    #[doc = " @param[in,out] depth - Pointer that will store the history depth (optional)"]
    #[doc = ""]
    #[doc = " @returns - false iff any of the arguments is invalid or the qos is not present in the qos object"]
    pub fn dds_qget_history(
        qos: *const dds_qos_t,
        kind: *mut dds_history_kind_t,
        depth: *mut i32,
    ) -> bool;
}
extern "C" {
    #[doc = " @ingroup qos_getters"]
    #[doc = " @brief Get the resource-limits policy from a qos structure"]
    #[doc = ""]
    #[doc = " @param[in] qos - Pointer to a dds_qos_t structure storing the policy"]
    #[doc = " @param[in,out] max_samples - Pointer that will store the number of samples resource-limit (optional)"]
    #[doc = " @param[in,out] max_instances - Pointer that will store the number of instances resource-limit (optional)"]
    #[doc = " @param[in,out] max_samples_per_instance - Pointer that will store the number of samples per instance resource-limit (optional)"]
    #[doc = ""]
    #[doc = " @returns - false iff any of the arguments is invalid or the qos is not present in the qos object"]
    pub fn dds_qget_resource_limits(
        qos: *const dds_qos_t,
        max_samples: *mut i32,
        max_instances: *mut i32,
        max_samples_per_instance: *mut i32,
    ) -> bool;
}
extern "C" {
    #[doc = " @ingroup qos_getters"]
    #[doc = " @brief Get the presentation policy from a qos structure"]
    #[doc = ""]
    #[doc = " @param[in] qos - Pointer to a dds_qos_t structure storing the policy"]
    #[doc = " @param[in,out] access_scope - Pointer that will store access scope kind (optional)"]
    #[doc = " @param[in,out] coherent_access - Pointer that will store coherent access enable value (optional)"]
    #[doc = " @param[in,out] ordered_access - Pointer that will store orderede access enable value (optional)"]
    #[doc = ""]
    #[doc = " @returns - false iff any of the arguments is invalid or the qos is not present in the qos object"]
    pub fn dds_qget_presentation(
        qos: *const dds_qos_t,
        access_scope: *mut dds_presentation_access_scope_kind_t,
        coherent_access: *mut bool,
        ordered_access: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = " @ingroup qos_getters"]
    #[doc = " @brief Get the lifespan policy from a qos structure"]
    #[doc = ""]
    #[doc = " @param[in] qos - Pointer to a dds_qos_t structure storing the policy"]
    #[doc = " @param[in,out] lifespan - Pointer that will store lifespan duration"]
    #[doc = ""]
    #[doc = " @returns - false iff any of the arguments is invalid or the qos is not present in the qos object"]
    pub fn dds_qget_lifespan(qos: *const dds_qos_t, lifespan: *mut dds_duration_t) -> bool;
}
extern "C" {
    #[doc = " @ingroup qos_getters"]
    #[doc = " @brief Get the deadline policy from a qos structure"]
    #[doc = ""]
    #[doc = " @param[in] qos - Pointer to a dds_qos_t structure storing the policy"]
    #[doc = " @param[in,out] deadline - Pointer that will store deadline duration"]
    #[doc = ""]
    #[doc = " @returns - false iff any of the arguments is invalid or the qos is not present in the qos object"]
    pub fn dds_qget_deadline(qos: *const dds_qos_t, deadline: *mut dds_duration_t) -> bool;
}
extern "C" {
    #[doc = " @ingroup qos_getters"]
    #[doc = " @brief Get the latency-budget policy from a qos structure"]
    #[doc = ""]
    #[doc = " @param[in] qos - Pointer to a dds_qos_t structure storing the policy"]
    #[doc = " @param[in,out] duration - Pointer that will store latency-budget duration"]
    #[doc = ""]
    #[doc = " @returns - false iff any of the arguments is invalid or the qos is not present in the qos object"]
    pub fn dds_qget_latency_budget(qos: *const dds_qos_t, duration: *mut dds_duration_t) -> bool;
}
extern "C" {
    #[doc = " @ingroup qos_getters"]
    #[doc = " @brief Get the ownership policy from a qos structure"]
    #[doc = ""]
    #[doc = " @param[in] qos - Pointer to a dds_qos_t structure storing the policy"]
    #[doc = " @param[in,out] kind - Pointer that will store the ownership kind"]
    #[doc = ""]
    #[doc = " @returns - false iff any of the arguments is invalid or the qos is not present in the qos object"]
    pub fn dds_qget_ownership(qos: *const dds_qos_t, kind: *mut dds_ownership_kind_t) -> bool;
}
extern "C" {
    #[doc = " @ingroup qos_getters"]
    #[doc = " @brief Get the ownership strength qos policy"]
    #[doc = ""]
    #[doc = " @param[in] qos - Pointer to a dds_qos_t structure storing the policy"]
    #[doc = " @param[in,out] value - Pointer that will store the ownership strength value"]
    #[doc = ""]
    #[doc = " @returns - false iff any of the arguments is invalid or the qos is not present in the qos object"]
    pub fn dds_qget_ownership_strength(qos: *const dds_qos_t, value: *mut i32) -> bool;
}
extern "C" {
    #[doc = " @ingroup qos_getters"]
    #[doc = " @brief Get the liveliness qos policy"]
    #[doc = ""]
    #[doc = " @param[in] qos - Pointer to a dds_qos_t structure storing the policy"]
    #[doc = " @param[in,out] kind - Pointer that will store the liveliness kind (optional)"]
    #[doc = " @param[in,out] lease_duration - Pointer that will store the liveliness lease duration (optional)"]
    #[doc = ""]
    #[doc = " @returns - false iff any of the arguments is invalid or the qos is not present in the qos object"]
    pub fn dds_qget_liveliness(
        qos: *const dds_qos_t,
        kind: *mut dds_liveliness_kind_t,
        lease_duration: *mut dds_duration_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @ingroup qos_getters"]
    #[doc = " @brief Get the time-based filter qos policy"]
    #[doc = ""]
    #[doc = " @param[in] qos - Pointer to a dds_qos_t structure storing the policy"]
    #[doc = " @param[in,out] minimum_separation - Pointer that will store the minimum separation duration (optional)"]
    #[doc = ""]
    #[doc = " @returns - false iff any of the arguments is invalid or the qos is not present in the qos object"]
    pub fn dds_qget_time_based_filter(
        qos: *const dds_qos_t,
        minimum_separation: *mut dds_duration_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @ingroup qos_getters"]
    #[doc = " @brief Get the partition qos policy"]
    #[doc = ""]
    #[doc = " @param[in] qos - Pointer to a dds_qos_t structure storing the policy"]
    #[doc = " @param[in,out] n - Pointer that will store the number of partitions (optional)"]
    #[doc = " @param[in,out] ps - Pointer that will store the string(s) containing partition name(s) (optional)"]
    #[doc = ""]
    #[doc = " @returns - false iff any of the arguments is invalid or the qos is not present in the qos object"]
    pub fn dds_qget_partition(
        qos: *const dds_qos_t,
        n: *mut u32,
        ps: *mut *mut *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @ingroup qos_getters"]
    #[doc = " @brief Get the reliability qos policy"]
    #[doc = ""]
    #[doc = " @param[in] qos - Pointer to a dds_qos_t structure storing the policy"]
    #[doc = " @param[in,out] kind - Pointer that will store the reliability kind (optional)"]
    #[doc = " @param[in,out] max_blocking_time - Pointer that will store the max blocking time for reliable reliability (optional)"]
    #[doc = ""]
    #[doc = " @returns - false iff any of the arguments is invalid or the qos is not present in the qos object"]
    pub fn dds_qget_reliability(
        qos: *const dds_qos_t,
        kind: *mut dds_reliability_kind_t,
        max_blocking_time: *mut dds_duration_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @ingroup qos_getters"]
    #[doc = " @brief Get the transport priority qos policy"]
    #[doc = ""]
    #[doc = " @param[in] qos - Pointer to a dds_qos_t structure storing the policy"]
    #[doc = " @param[in,out] value - Pointer that will store the transport priority value"]
    #[doc = ""]
    #[doc = " @returns - false iff any of the arguments is invalid or the qos is not present in the qos object"]
    pub fn dds_qget_transport_priority(qos: *const dds_qos_t, value: *mut i32) -> bool;
}
extern "C" {
    #[doc = " @ingroup qos_getters"]
    #[doc = " @brief Get the destination-order qos policy"]
    #[doc = ""]
    #[doc = " @param[in] qos - Pointer to a dds_qos_t structure storing the policy"]
    #[doc = " @param[in,out] kind - Pointer that will store the destination-order kind"]
    #[doc = ""]
    #[doc = " @returns - false iff any of the arguments is invalid or the qos is not present in the qos object"]
    pub fn dds_qget_destination_order(
        qos: *const dds_qos_t,
        kind: *mut dds_destination_order_kind_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @ingroup qos_getters"]
    #[doc = " @brief Get the writer data-lifecycle qos policy"]
    #[doc = ""]
    #[doc = " @param[in] qos - Pointer to a dds_qos_t structure storing the policy"]
    #[doc = " @param[in,out] autodispose - Pointer that will store the autodispose unregistered instances enable value"]
    #[doc = ""]
    #[doc = " @returns - false iff any of the arguments is invalid or the qos is not present in the qos object"]
    pub fn dds_qget_writer_data_lifecycle(qos: *const dds_qos_t, autodispose: *mut bool) -> bool;
}
extern "C" {
    #[doc = " @ingroup qos_getters"]
    #[doc = " @brief Get the durability-service qos policy values."]
    #[doc = ""]
    #[doc = " @param[in] qos - Pointer to a dds_qos_t structure storing the policy"]
    #[doc = " @param[in,out]  service_cleanup_delay - Pointer that will store the delay for purging of abandoned instances from the durability service (optional)"]
    #[doc = " @param[in,out] history_kind - Pointer that will store history policy kind applied by the durability service (optional)"]
    #[doc = " @param[in,out] history_depth - Pointer that will store history policy depth applied by the durability service (optional)"]
    #[doc = " @param[in,out] max_samples - Pointer that will store number of samples resource-limit policy applied by the durability service (optional)"]
    #[doc = " @param[in,out] max_instances - Pointer that will store number of instances resource-limit policy applied by the durability service (optional)"]
    #[doc = " @param[in,out] max_samples_per_instance - Pointer that will store number of samples per instance resource-limit policy applied by the durability service (optional)"]
    #[doc = ""]
    #[doc = " @returns - false iff any of the arguments is invalid or the qos is not present in the qos object"]
    pub fn dds_qget_durability_service(
        qos: *const dds_qos_t,
        service_cleanup_delay: *mut dds_duration_t,
        history_kind: *mut dds_history_kind_t,
        history_depth: *mut i32,
        max_samples: *mut i32,
        max_instances: *mut i32,
        max_samples_per_instance: *mut i32,
    ) -> bool;
}
extern "C" {
    #[doc = " @ingroup qos_getters"]
    #[doc = " @brief Get the ignore-local qos policy"]
    #[doc = ""]
    #[doc = " @param[in] qos - Pointer to a dds_qos_t structure storing the policy"]
    #[doc = " @param[in,out] ignore - Pointer that will store whether to ignore readers/writers owned by the same participant (optional)"]
    #[doc = ""]
    #[doc = " @returns - false iff any of the arguments is invalid or the qos is not present in the qos object"]
    pub fn dds_qget_ignorelocal(qos: *const dds_qos_t, ignore: *mut dds_ignorelocal_kind_t)
        -> bool;
}
#[doc = " @ingroup dcps_status"]
#[doc = " @brief DCPS_Status_OfferedDeadlineMissed"]
#[doc = " DOC_TODO"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_offered_deadline_missed_status {
    #[doc = "< DOC_TODO"]
    pub total_count: u32,
    #[doc = "< DOC_TODO"]
    pub total_count_change: i32,
    #[doc = "< DOC_TODO"]
    pub last_instance_handle: dds_instance_handle_t,
}
#[test]
fn bindgen_test_layout_dds_offered_deadline_missed_status() {
    assert_eq!(
        ::std::mem::size_of::<dds_offered_deadline_missed_status>(),
        16usize,
        concat!("Size of: ", stringify!(dds_offered_deadline_missed_status))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_offered_deadline_missed_status>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(dds_offered_deadline_missed_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_offered_deadline_missed_status>())).total_count as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_offered_deadline_missed_status),
            "::",
            stringify!(total_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_offered_deadline_missed_status>())).total_count_change
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_offered_deadline_missed_status),
            "::",
            stringify!(total_count_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_offered_deadline_missed_status>())).last_instance_handle
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_offered_deadline_missed_status),
            "::",
            stringify!(last_instance_handle)
        )
    );
}
#[doc = " @ingroup dcps_status"]
#[doc = " @brief DCPS_Status_OfferedDeadlineMissed"]
#[doc = " DOC_TODO"]
pub type dds_offered_deadline_missed_status_t = dds_offered_deadline_missed_status;
#[doc = " @ingroup dcps_status"]
#[doc = " @brief DCPS_Status_OfferedIncompatibleQoS"]
#[doc = " DOC_TODO"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_offered_incompatible_qos_status {
    #[doc = "< DOC_TODO"]
    pub total_count: u32,
    #[doc = "< DOC_TODO"]
    pub total_count_change: i32,
    #[doc = "< DOC_TODO"]
    pub last_policy_id: u32,
}
#[test]
fn bindgen_test_layout_dds_offered_incompatible_qos_status() {
    assert_eq!(
        ::std::mem::size_of::<dds_offered_incompatible_qos_status>(),
        12usize,
        concat!("Size of: ", stringify!(dds_offered_incompatible_qos_status))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_offered_incompatible_qos_status>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dds_offered_incompatible_qos_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_offered_incompatible_qos_status>())).total_count as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_offered_incompatible_qos_status),
            "::",
            stringify!(total_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_offered_incompatible_qos_status>())).total_count_change
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_offered_incompatible_qos_status),
            "::",
            stringify!(total_count_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_offered_incompatible_qos_status>())).last_policy_id
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_offered_incompatible_qos_status),
            "::",
            stringify!(last_policy_id)
        )
    );
}
#[doc = " @ingroup dcps_status"]
#[doc = " @brief DCPS_Status_OfferedIncompatibleQoS"]
#[doc = " DOC_TODO"]
pub type dds_offered_incompatible_qos_status_t = dds_offered_incompatible_qos_status;
#[doc = " @ingroup dcps_status"]
#[doc = " @brief DCPS_Status_PublicationMatched"]
#[doc = " DOC_TODO"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_publication_matched_status {
    #[doc = "< DOC_TODO"]
    pub total_count: u32,
    #[doc = "< DOC_TODO"]
    pub total_count_change: i32,
    #[doc = "< DOC_TODO"]
    pub current_count: u32,
    #[doc = "< DOC_TODO"]
    pub current_count_change: i32,
    #[doc = "< DOC_TODO"]
    pub last_subscription_handle: dds_instance_handle_t,
}
#[test]
fn bindgen_test_layout_dds_publication_matched_status() {
    assert_eq!(
        ::std::mem::size_of::<dds_publication_matched_status>(),
        24usize,
        concat!("Size of: ", stringify!(dds_publication_matched_status))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_publication_matched_status>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_publication_matched_status))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_publication_matched_status>())).total_count as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_publication_matched_status),
            "::",
            stringify!(total_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_publication_matched_status>())).total_count_change
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_publication_matched_status),
            "::",
            stringify!(total_count_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_publication_matched_status>())).current_count as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_publication_matched_status),
            "::",
            stringify!(current_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_publication_matched_status>())).current_count_change
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_publication_matched_status),
            "::",
            stringify!(current_count_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_publication_matched_status>())).last_subscription_handle
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_publication_matched_status),
            "::",
            stringify!(last_subscription_handle)
        )
    );
}
#[doc = " @ingroup dcps_status"]
#[doc = " @brief DCPS_Status_PublicationMatched"]
#[doc = " DOC_TODO"]
pub type dds_publication_matched_status_t = dds_publication_matched_status;
#[doc = " @ingroup dcps_status"]
#[doc = " @brief DCPS_Status_LivelinessLost"]
#[doc = " DOC_TODO"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_liveliness_lost_status {
    #[doc = "< DOC_TODO"]
    pub total_count: u32,
    #[doc = "< DOC_TODO"]
    pub total_count_change: i32,
}
#[test]
fn bindgen_test_layout_dds_liveliness_lost_status() {
    assert_eq!(
        ::std::mem::size_of::<dds_liveliness_lost_status>(),
        8usize,
        concat!("Size of: ", stringify!(dds_liveliness_lost_status))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_liveliness_lost_status>(),
        4usize,
        concat!("Alignment of ", stringify!(dds_liveliness_lost_status))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_liveliness_lost_status>())).total_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_liveliness_lost_status),
            "::",
            stringify!(total_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_liveliness_lost_status>())).total_count_change as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_liveliness_lost_status),
            "::",
            stringify!(total_count_change)
        )
    );
}
#[doc = " @ingroup dcps_status"]
#[doc = " @brief DCPS_Status_LivelinessLost"]
#[doc = " DOC_TODO"]
pub type dds_liveliness_lost_status_t = dds_liveliness_lost_status;
#[doc = " @ingroup dcps_status"]
#[doc = " @brief DCPS_Status_SubscriptionMatched"]
#[doc = " DOC_TODO"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_subscription_matched_status {
    #[doc = "< DOC_TODO"]
    pub total_count: u32,
    #[doc = "< DOC_TODO"]
    pub total_count_change: i32,
    #[doc = "< DOC_TODO"]
    pub current_count: u32,
    #[doc = "< DOC_TODO"]
    pub current_count_change: i32,
    #[doc = "< DOC_TODO"]
    pub last_publication_handle: dds_instance_handle_t,
}
#[test]
fn bindgen_test_layout_dds_subscription_matched_status() {
    assert_eq!(
        ::std::mem::size_of::<dds_subscription_matched_status>(),
        24usize,
        concat!("Size of: ", stringify!(dds_subscription_matched_status))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_subscription_matched_status>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_subscription_matched_status))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_subscription_matched_status>())).total_count as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_subscription_matched_status),
            "::",
            stringify!(total_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_subscription_matched_status>())).total_count_change
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_subscription_matched_status),
            "::",
            stringify!(total_count_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_subscription_matched_status>())).current_count as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_subscription_matched_status),
            "::",
            stringify!(current_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_subscription_matched_status>())).current_count_change
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_subscription_matched_status),
            "::",
            stringify!(current_count_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_subscription_matched_status>())).last_publication_handle
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_subscription_matched_status),
            "::",
            stringify!(last_publication_handle)
        )
    );
}
#[doc = " @ingroup dcps_status"]
#[doc = " @brief DCPS_Status_SubscriptionMatched"]
#[doc = " DOC_TODO"]
pub type dds_subscription_matched_status_t = dds_subscription_matched_status;
#[doc = "< DOC_TODO"]
pub const dds_sample_rejected_status_kind_DDS_NOT_REJECTED: dds_sample_rejected_status_kind = 0;
#[doc = "< DOC_TODO"]
pub const dds_sample_rejected_status_kind_DDS_REJECTED_BY_INSTANCES_LIMIT:
    dds_sample_rejected_status_kind = 1;
#[doc = "< DOC_TODO"]
pub const dds_sample_rejected_status_kind_DDS_REJECTED_BY_SAMPLES_LIMIT:
    dds_sample_rejected_status_kind = 2;
#[doc = "< DOC_TODO"]
pub const dds_sample_rejected_status_kind_DDS_REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT:
    dds_sample_rejected_status_kind = 3;
#[doc = " @ingroup dcps_status"]
#[doc = " @brief Rejected Status"]
#[doc = " DOC_TODO"]
pub type dds_sample_rejected_status_kind = ::std::os::raw::c_uint;
#[doc = " @ingroup dcps_status"]
#[doc = " @brief DCPS_Status_SampleRejected"]
#[doc = " DOC_TODO"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_sample_rejected_status {
    #[doc = "< DOC_TODO"]
    pub total_count: u32,
    #[doc = "< DOC_TODO"]
    pub total_count_change: i32,
    #[doc = "< DOC_TODO"]
    pub last_reason: dds_sample_rejected_status_kind,
    #[doc = "< DOC_TODO"]
    pub last_instance_handle: dds_instance_handle_t,
}
#[test]
fn bindgen_test_layout_dds_sample_rejected_status() {
    assert_eq!(
        ::std::mem::size_of::<dds_sample_rejected_status>(),
        24usize,
        concat!("Size of: ", stringify!(dds_sample_rejected_status))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_sample_rejected_status>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_sample_rejected_status))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_sample_rejected_status>())).total_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_rejected_status),
            "::",
            stringify!(total_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_sample_rejected_status>())).total_count_change as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_rejected_status),
            "::",
            stringify!(total_count_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_sample_rejected_status>())).last_reason as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_rejected_status),
            "::",
            stringify!(last_reason)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_sample_rejected_status>())).last_instance_handle as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_rejected_status),
            "::",
            stringify!(last_instance_handle)
        )
    );
}
impl Default for dds_sample_rejected_status {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " @ingroup dcps_status"]
#[doc = " @brief DCPS_Status_SampleRejected"]
#[doc = " DOC_TODO"]
pub type dds_sample_rejected_status_t = dds_sample_rejected_status;
#[doc = " @ingroup dcps_status"]
#[doc = " @brief DCPS_Status_LivelinessChanged"]
#[doc = " DOC_TODO"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_liveliness_changed_status {
    #[doc = "< DOC_TODO"]
    pub alive_count: u32,
    #[doc = "< DOC_TODO"]
    pub not_alive_count: u32,
    #[doc = "< DOC_TODO"]
    pub alive_count_change: i32,
    #[doc = "< DOC_TODO"]
    pub not_alive_count_change: i32,
    #[doc = "< DOC_TODO"]
    pub last_publication_handle: dds_instance_handle_t,
}
#[test]
fn bindgen_test_layout_dds_liveliness_changed_status() {
    assert_eq!(
        ::std::mem::size_of::<dds_liveliness_changed_status>(),
        24usize,
        concat!("Size of: ", stringify!(dds_liveliness_changed_status))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_liveliness_changed_status>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_liveliness_changed_status))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_liveliness_changed_status>())).alive_count as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_liveliness_changed_status),
            "::",
            stringify!(alive_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_liveliness_changed_status>())).not_alive_count as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_liveliness_changed_status),
            "::",
            stringify!(not_alive_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_liveliness_changed_status>())).alive_count_change as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_liveliness_changed_status),
            "::",
            stringify!(alive_count_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_liveliness_changed_status>())).not_alive_count_change
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_liveliness_changed_status),
            "::",
            stringify!(not_alive_count_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_liveliness_changed_status>())).last_publication_handle
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_liveliness_changed_status),
            "::",
            stringify!(last_publication_handle)
        )
    );
}
#[doc = " @ingroup dcps_status"]
#[doc = " @brief DCPS_Status_LivelinessChanged"]
#[doc = " DOC_TODO"]
pub type dds_liveliness_changed_status_t = dds_liveliness_changed_status;
#[doc = " @ingroup dcps_status"]
#[doc = " @brief DCPS_Status_RequestedDeadlineMissed"]
#[doc = " DOC_TODO"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_requested_deadline_missed_status {
    #[doc = "< DOC_TODO"]
    pub total_count: u32,
    #[doc = "< DOC_TODO"]
    pub total_count_change: i32,
    #[doc = "< DOC_TODO"]
    pub last_instance_handle: dds_instance_handle_t,
}
#[test]
fn bindgen_test_layout_dds_requested_deadline_missed_status() {
    assert_eq!(
        ::std::mem::size_of::<dds_requested_deadline_missed_status>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(dds_requested_deadline_missed_status)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<dds_requested_deadline_missed_status>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(dds_requested_deadline_missed_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_requested_deadline_missed_status>())).total_count as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_requested_deadline_missed_status),
            "::",
            stringify!(total_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_requested_deadline_missed_status>())).total_count_change
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_requested_deadline_missed_status),
            "::",
            stringify!(total_count_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_requested_deadline_missed_status>())).last_instance_handle
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_requested_deadline_missed_status),
            "::",
            stringify!(last_instance_handle)
        )
    );
}
#[doc = " @ingroup dcps_status"]
#[doc = " @brief DCPS_Status_RequestedDeadlineMissed"]
#[doc = " DOC_TODO"]
pub type dds_requested_deadline_missed_status_t = dds_requested_deadline_missed_status;
#[doc = " @ingroup dcps_status"]
#[doc = " @brief DCPS_Status_RequestedIncompatibleQoS"]
#[doc = " DOC_TODO"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_requested_incompatible_qos_status {
    #[doc = "< DOC_TODO"]
    pub total_count: u32,
    #[doc = "< DOC_TODO"]
    pub total_count_change: i32,
    #[doc = "< DOC_TODO"]
    pub last_policy_id: u32,
}
#[test]
fn bindgen_test_layout_dds_requested_incompatible_qos_status() {
    assert_eq!(
        ::std::mem::size_of::<dds_requested_incompatible_qos_status>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(dds_requested_incompatible_qos_status)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<dds_requested_incompatible_qos_status>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dds_requested_incompatible_qos_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_requested_incompatible_qos_status>())).total_count
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_requested_incompatible_qos_status),
            "::",
            stringify!(total_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_requested_incompatible_qos_status>())).total_count_change
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_requested_incompatible_qos_status),
            "::",
            stringify!(total_count_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_requested_incompatible_qos_status>())).last_policy_id
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_requested_incompatible_qos_status),
            "::",
            stringify!(last_policy_id)
        )
    );
}
#[doc = " @ingroup dcps_status"]
#[doc = " @brief DCPS_Status_RequestedIncompatibleQoS"]
#[doc = " DOC_TODO"]
pub type dds_requested_incompatible_qos_status_t = dds_requested_incompatible_qos_status;
#[doc = " @ingroup dcps_status"]
#[doc = " @brief DCPS_Status_SampleLost"]
#[doc = " DOC_TODO"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_sample_lost_status {
    #[doc = "< DOC_TODO"]
    pub total_count: u32,
    #[doc = "< DOC_TODO"]
    pub total_count_change: i32,
}
#[test]
fn bindgen_test_layout_dds_sample_lost_status() {
    assert_eq!(
        ::std::mem::size_of::<dds_sample_lost_status>(),
        8usize,
        concat!("Size of: ", stringify!(dds_sample_lost_status))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_sample_lost_status>(),
        4usize,
        concat!("Alignment of ", stringify!(dds_sample_lost_status))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_sample_lost_status>())).total_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_lost_status),
            "::",
            stringify!(total_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_sample_lost_status>())).total_count_change as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_lost_status),
            "::",
            stringify!(total_count_change)
        )
    );
}
#[doc = " @ingroup dcps_status"]
#[doc = " @brief DCPS_Status_SampleLost"]
#[doc = " DOC_TODO"]
pub type dds_sample_lost_status_t = dds_sample_lost_status;
#[doc = " @ingroup dcps_status"]
#[doc = " @brief DCPS_Status_InconsistentTopic"]
#[doc = " DOC_TODO"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_inconsistent_topic_status {
    #[doc = "< DOC_TODO"]
    pub total_count: u32,
    #[doc = "< DOC_TODO"]
    pub total_count_change: i32,
}
#[test]
fn bindgen_test_layout_dds_inconsistent_topic_status() {
    assert_eq!(
        ::std::mem::size_of::<dds_inconsistent_topic_status>(),
        8usize,
        concat!("Size of: ", stringify!(dds_inconsistent_topic_status))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_inconsistent_topic_status>(),
        4usize,
        concat!("Alignment of ", stringify!(dds_inconsistent_topic_status))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_inconsistent_topic_status>())).total_count as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_inconsistent_topic_status),
            "::",
            stringify!(total_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_inconsistent_topic_status>())).total_count_change as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_inconsistent_topic_status),
            "::",
            stringify!(total_count_change)
        )
    );
}
#[doc = " @ingroup dcps_status"]
#[doc = " @brief DCPS_Status_InconsistentTopic"]
#[doc = " DOC_TODO"]
pub type dds_inconsistent_topic_status_t = dds_inconsistent_topic_status;
extern "C" {
    #[doc = " @ingroup dcps_status_getters"]
    #[doc = " @brief Get INCONSISTENT_TOPIC status"]
    #[doc = ""]
    #[doc = " This operation gets the status value corresponding to INCONSISTENT_TOPIC"]
    #[doc = " and reset the status. The value can be obtained, only if the status is enabled for an entity."]
    #[doc = " NULL value for status is allowed and it will reset the trigger value when status is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  topic  The entity to get the status"]
    #[doc = " @param[out] status The pointer to @ref dds_inconsistent_topic_status_t to get the status"]
    #[doc = ""]
    #[doc = " @returns  0 - Success"]
    #[doc = " @returns <0 - Failure"]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "                  An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "                  One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "                  The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "                  The entity has already been deleted."]
    pub fn dds_get_inconsistent_topic_status(
        topic: dds_entity_t,
        status: *mut dds_inconsistent_topic_status_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @ingroup dcps_status_getters"]
    #[doc = " @brief Get PUBLICATION_MATCHED status"]
    #[doc = ""]
    #[doc = " This operation gets the status value corresponding to PUBLICATION_MATCHED"]
    #[doc = " and reset the status. The value can be obtained, only if the status is enabled for an entity."]
    #[doc = " NULL value for status is allowed and it will reset the trigger value when status is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  writer  The entity to get the status"]
    #[doc = " @param[out] status  The pointer to @ref dds_publication_matched_status_t to get the status"]
    #[doc = ""]
    #[doc = " @returns  0 - Success"]
    #[doc = " @returns <0 - Failure"]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "                  An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "                  One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "                  The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "                  The entity has already been deleted."]
    pub fn dds_get_publication_matched_status(
        writer: dds_entity_t,
        status: *mut dds_publication_matched_status_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @ingroup dcps_status_getters"]
    #[doc = " @brief Get LIVELINESS_LOST status"]
    #[doc = ""]
    #[doc = " This operation gets the status value corresponding to LIVELINESS_LOST"]
    #[doc = " and reset the status. The value can be obtained, only if the status is enabled for an entity."]
    #[doc = " NULL value for status is allowed and it will reset the trigger value when status is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  writer  The entity to get the status"]
    #[doc = " @param[out] status  The pointer to @ref dds_liveliness_lost_status_t to get the status"]
    #[doc = ""]
    #[doc = " @returns  0 - Success"]
    #[doc = " @returns <0 - Failure"]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "                  An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "                  One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "                  The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "                  The entity has already been deleted."]
    pub fn dds_get_liveliness_lost_status(
        writer: dds_entity_t,
        status: *mut dds_liveliness_lost_status_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @ingroup dcps_status_getters"]
    #[doc = " @brief Get OFFERED_DEADLINE_MISSED status"]
    #[doc = ""]
    #[doc = " This operation gets the status value corresponding to OFFERED_DEADLINE_MISSED"]
    #[doc = " and reset the status. The value can be obtained, only if the status is enabled for an entity."]
    #[doc = " NULL value for status is allowed and it will reset the trigger value when status is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  writer  The entity to get the status"]
    #[doc = " @param[out] status  The pointer to @ref dds_offered_deadline_missed_status_t to get the status"]
    #[doc = ""]
    #[doc = " @returns  0 - Success"]
    #[doc = " @returns <0 - Failure"]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "                  An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "                  One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "                  The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "                  The entity has already been deleted."]
    pub fn dds_get_offered_deadline_missed_status(
        writer: dds_entity_t,
        status: *mut dds_offered_deadline_missed_status_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @ingroup dcps_status_getters"]
    #[doc = " @brief Get OFFERED_INCOMPATIBLE_QOS status"]
    #[doc = ""]
    #[doc = " This operation gets the status value corresponding to OFFERED_INCOMPATIBLE_QOS"]
    #[doc = " and reset the status. The value can be obtained, only if the status is enabled for an entity."]
    #[doc = " NULL value for status is allowed and it will reset the trigger value when status is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  writer  The writer entity to get the status"]
    #[doc = " @param[out] status  The pointer to @ref dds_offered_incompatible_qos_status_t to get the status"]
    #[doc = ""]
    #[doc = " @returns  0 - Success"]
    #[doc = " @returns <0 - Failure"]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "                  An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "                  One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "                  The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "                  The entity has already been deleted."]
    pub fn dds_get_offered_incompatible_qos_status(
        writer: dds_entity_t,
        status: *mut dds_offered_incompatible_qos_status_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @ingroup dcps_status_getters"]
    #[doc = " @brief Get SUBSCRIPTION_MATCHED status"]
    #[doc = ""]
    #[doc = " This operation gets the status value corresponding to SUBSCRIPTION_MATCHED"]
    #[doc = " and reset the status. The value can be obtained, only if the status is enabled for an entity."]
    #[doc = " NULL value for status is allowed and it will reset the trigger value when status is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  reader  The reader entity to get the status"]
    #[doc = " @param[out] status  The pointer to @ref dds_subscription_matched_status_t to get the status"]
    #[doc = ""]
    #[doc = " @returns  0 - Success"]
    #[doc = " @returns <0 - Failure"]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "                  An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "                  One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "                  The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "                  The entity has already been deleted."]
    pub fn dds_get_subscription_matched_status(
        reader: dds_entity_t,
        status: *mut dds_subscription_matched_status_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @ingroup dcps_status_getters"]
    #[doc = " @brief Get LIVELINESS_CHANGED status"]
    #[doc = ""]
    #[doc = " This operation gets the status value corresponding to LIVELINESS_CHANGED"]
    #[doc = " and reset the status. The value can be obtained, only if the status is enabled for an entity."]
    #[doc = " NULL value for status is allowed and it will reset the trigger value when status is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  reader  The entity to get the status"]
    #[doc = " @param[out] status  The pointer to @ref dds_liveliness_changed_status_t to get the status"]
    #[doc = ""]
    #[doc = " @returns  0 - Success"]
    #[doc = " @returns <0 - Failure"]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "                  An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "                  One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "                  The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "                  The entity has already been deleted."]
    pub fn dds_get_liveliness_changed_status(
        reader: dds_entity_t,
        status: *mut dds_liveliness_changed_status_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @ingroup dcps_status_getters"]
    #[doc = " @brief Get SAMPLE_REJECTED status"]
    #[doc = ""]
    #[doc = " This operation gets the status value corresponding to SAMPLE_REJECTED"]
    #[doc = " and reset the status. The value can be obtained, only if the status is enabled for an entity."]
    #[doc = " NULL value for status is allowed and it will reset the trigger value when status is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  reader  The entity to get the status"]
    #[doc = " @param[out] status  The pointer to @ref dds_sample_rejected_status_t to get the status"]
    #[doc = ""]
    #[doc = " @returns  0 - Success"]
    #[doc = " @returns <0 - Failure"]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "                  An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "                  One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "                  The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "                  The entity has already been deleted."]
    pub fn dds_get_sample_rejected_status(
        reader: dds_entity_t,
        status: *mut dds_sample_rejected_status_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @ingroup dcps_status_getters"]
    #[doc = " @brief Get SAMPLE_LOST status"]
    #[doc = ""]
    #[doc = " This operation gets the status value corresponding to SAMPLE_LOST"]
    #[doc = " and reset the status. The value can be obtained, only if the status is enabled for an entity."]
    #[doc = " NULL value for status is allowed and it will reset the trigger value when status is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  reader  The entity to get the status"]
    #[doc = " @param[out] status  The pointer to @ref dds_sample_lost_status_t to get the status"]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure"]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "            Success"]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "            An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "            One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "            The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "            The entity has already been deleted."]
    pub fn dds_get_sample_lost_status(
        reader: dds_entity_t,
        status: *mut dds_sample_lost_status_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @ingroup dcps_status_getters"]
    #[doc = " @brief Get REQUESTED_DEADLINE_MISSED status"]
    #[doc = ""]
    #[doc = " This operation gets the status value corresponding to REQUESTED_DEADLINE_MISSED"]
    #[doc = " and reset the status. The value can be obtained, only if the status is enabled for an entity."]
    #[doc = " NULL value for status is allowed and it will reset the trigger value when status is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  reader  The entity to get the status"]
    #[doc = " @param[out] status  The pointer to @ref dds_requested_deadline_missed_status_t to get the status"]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure"]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "            Success"]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "            An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "            One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "            The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "            The entity has already been deleted."]
    pub fn dds_get_requested_deadline_missed_status(
        reader: dds_entity_t,
        status: *mut dds_requested_deadline_missed_status_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @ingroup dcps_status_getters"]
    #[doc = " @brief Get REQUESTED_INCOMPATIBLE_QOS status"]
    #[doc = ""]
    #[doc = " This operation gets the status value corresponding to REQUESTED_INCOMPATIBLE_QOS"]
    #[doc = " and reset the status. The value can be obtained, only if the status is enabled for an entity."]
    #[doc = " NULL value for status is allowed and it will reset the trigger value when status is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  reader  The entity to get the status"]
    #[doc = " @param[out] status  The pointer to @ref dds_requested_incompatible_qos_status_t to get the status"]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure"]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "            Success"]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "            An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "            One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "            The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "            The entity has already been deleted."]
    pub fn dds_get_requested_incompatible_qos_status(
        reader: dds_entity_t,
        status: *mut dds_requested_incompatible_qos_status_t,
    ) -> dds_return_t;
}
pub type dds_on_inconsistent_topic_fn = ::std::option::Option<
    unsafe extern "C" fn(
        topic: dds_entity_t,
        status: dds_inconsistent_topic_status_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type dds_on_liveliness_lost_fn = ::std::option::Option<
    unsafe extern "C" fn(
        writer: dds_entity_t,
        status: dds_liveliness_lost_status_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type dds_on_offered_deadline_missed_fn = ::std::option::Option<
    unsafe extern "C" fn(
        writer: dds_entity_t,
        status: dds_offered_deadline_missed_status_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type dds_on_offered_incompatible_qos_fn = ::std::option::Option<
    unsafe extern "C" fn(
        writer: dds_entity_t,
        status: dds_offered_incompatible_qos_status_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type dds_on_data_on_readers_fn = ::std::option::Option<
    unsafe extern "C" fn(subscriber: dds_entity_t, arg: *mut ::std::os::raw::c_void),
>;
pub type dds_on_sample_lost_fn = ::std::option::Option<
    unsafe extern "C" fn(
        reader: dds_entity_t,
        status: dds_sample_lost_status_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type dds_on_data_available_fn = ::std::option::Option<
    unsafe extern "C" fn(reader: dds_entity_t, arg: *mut ::std::os::raw::c_void),
>;
pub type dds_on_sample_rejected_fn = ::std::option::Option<
    unsafe extern "C" fn(
        reader: dds_entity_t,
        status: dds_sample_rejected_status_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type dds_on_liveliness_changed_fn = ::std::option::Option<
    unsafe extern "C" fn(
        reader: dds_entity_t,
        status: dds_liveliness_changed_status_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type dds_on_requested_deadline_missed_fn = ::std::option::Option<
    unsafe extern "C" fn(
        reader: dds_entity_t,
        status: dds_requested_deadline_missed_status_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type dds_on_requested_incompatible_qos_fn = ::std::option::Option<
    unsafe extern "C" fn(
        reader: dds_entity_t,
        status: dds_requested_incompatible_qos_status_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type dds_on_publication_matched_fn = ::std::option::Option<
    unsafe extern "C" fn(
        writer: dds_entity_t,
        status: dds_publication_matched_status_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type dds_on_subscription_matched_fn = ::std::option::Option<
    unsafe extern "C" fn(
        reader: dds_entity_t,
        status: dds_subscription_matched_status_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief DDS Listener struct (opaque)"]
#[doc = " @ingroup listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_listener {
    _unused: [u8; 0],
}
#[doc = " @brief DDS Listener type (opaque)"]
#[doc = " @ingroup listener"]
pub type dds_listener_t = dds_listener;
extern "C" {
    #[doc = " @ingroup listener"]
    #[doc = " @brief Allocate memory and initializes to default values (@ref DDS_LUNSET) of a listener"]
    #[doc = ""]
    #[doc = " @param[in] arg optional pointer that will be passed on to the listener callbacks"]
    #[doc = ""]
    #[doc = " @returns Returns a pointer to the allocated memory for dds_listener_t structure."]
    pub fn dds_create_listener(arg: *mut ::std::os::raw::c_void) -> *mut dds_listener_t;
}
extern "C" {
    #[doc = " @ingroup listener"]
    #[doc = " @brief Delete the memory allocated to listener structure"]
    #[doc = ""]
    #[doc = " @param[in] listener pointer to the listener struct to delete"]
    pub fn dds_delete_listener(listener: *mut dds_listener_t);
}
extern "C" {
    #[doc = " @ingroup listener"]
    #[doc = " @brief Reset the listener structure contents to @ref DDS_LUNSET"]
    #[doc = ""]
    #[doc = " @param[in,out] listener pointer to the listener struct to reset"]
    pub fn dds_reset_listener(listener: *mut dds_listener_t);
}
extern "C" {
    #[doc = " @ingroup listener"]
    #[doc = " @brief Copy the listener callbacks from source to destination"]
    #[doc = ""]
    #[doc = " @param[in,out] dst The pointer to the destination listener structure, where the content is to copied"]
    #[doc = " @param[in] src The pointer to the source listener structure to be copied"]
    pub fn dds_copy_listener(dst: *mut dds_listener_t, src: *const dds_listener_t);
}
extern "C" {
    #[doc = " @ingroup listener"]
    #[doc = " @brief Copy the listener callbacks from source to destination, unless already set"]
    #[doc = ""]
    #[doc = " Any listener callbacks already set in @p dst (including NULL) are skipped, only"]
    #[doc = " those set to DDS_LUNSET are copied from @p src."]
    #[doc = ""]
    #[doc = " @param[in,out] dst The pointer to the destination listener structure, where the content is merged"]
    #[doc = " @param[in] src The pointer to the source listener structure to be copied"]
    pub fn dds_merge_listener(dst: *mut dds_listener_t, src: *const dds_listener_t);
}
extern "C" {
    #[doc = " @ingroup listener_setters"]
    #[doc = " @brief Set the inconsistent_topic callback in the listener structure."]
    #[doc = ""]
    #[doc = " Equivalent to calling @ref dds_lset_inconsistent_topic_arg with arg set to the argument passed in"]
    #[doc = " dds_create_listener() and reset_on_invoke to true, and throwing away the result."]
    #[doc = ""]
    #[doc = " @param[in,out] listener listener structure to update"]
    #[doc = " @param[in] callback the callback to set or a null pointer"]
    pub fn dds_lset_inconsistent_topic(
        listener: *mut dds_listener_t,
        callback: dds_on_inconsistent_topic_fn,
    );
}
extern "C" {
    #[doc = " @ingroup listener_setters"]
    #[doc = " @brief Set the liveliness_lost callback in the listener structure."]
    #[doc = ""]
    #[doc = " Equivalent to calling @ref dds_lset_liveliness_lost_arg with arg set to the argument passed in"]
    #[doc = " dds_create_listener() and reset_on_invoke to true, and throwing away the result."]
    #[doc = ""]
    #[doc = " @param[in,out] listener listener structure to update"]
    #[doc = " @param[in] callback the callback to set or a null pointer"]
    pub fn dds_lset_liveliness_lost(
        listener: *mut dds_listener_t,
        callback: dds_on_liveliness_lost_fn,
    );
}
extern "C" {
    #[doc = " @ingroup listener_setters"]
    #[doc = " @brief Set the offered_deadline_missed callback in the listener structure."]
    #[doc = ""]
    #[doc = " Equivalent to calling @ref dds_lset_offered_deadline_missed_arg with arg set to the argument passed in"]
    #[doc = " dds_create_listener() and reset_on_invoke to true, and throwing away the result."]
    #[doc = ""]
    #[doc = " @param[in,out] listener listener structure to update"]
    #[doc = " @param[in] callback the callback to set or a null pointer"]
    pub fn dds_lset_offered_deadline_missed(
        listener: *mut dds_listener_t,
        callback: dds_on_offered_deadline_missed_fn,
    );
}
extern "C" {
    #[doc = " @ingroup listener_setters"]
    #[doc = " @brief Set the offered_incompatible_qos callback in the listener structure."]
    #[doc = ""]
    #[doc = " Equivalent to calling @ref dds_lset_offered_incompatible_qos_arg with arg set to the argument passed in"]
    #[doc = " dds_create_listener() and reset_on_invoke to true, and throwing away the result."]
    #[doc = ""]
    #[doc = " @param[in,out] listener listener structure to update"]
    #[doc = " @param[in] callback the callback to set or a null pointer"]
    pub fn dds_lset_offered_incompatible_qos(
        listener: *mut dds_listener_t,
        callback: dds_on_offered_incompatible_qos_fn,
    );
}
extern "C" {
    #[doc = " @ingroup listener_setters"]
    #[doc = " @brief Set the data_on_readers callback in the listener structure."]
    #[doc = ""]
    #[doc = " Equivalent to calling @ref dds_lset_data_on_readers_arg with arg set to the argument passed in"]
    #[doc = " dds_create_listener() and reset_on_invoke to true, and throwing away the result."]
    #[doc = ""]
    #[doc = " @param[in,out] listener listener structure to update"]
    #[doc = " @param[in] callback the callback to set or a null pointer"]
    pub fn dds_lset_data_on_readers(
        listener: *mut dds_listener_t,
        callback: dds_on_data_on_readers_fn,
    );
}
extern "C" {
    #[doc = " @ingroup listener_setters"]
    #[doc = " @brief Set the sample_lost callback in the listener structure."]
    #[doc = ""]
    #[doc = " Equivalent to calling @ref dds_lset_sample_lost_arg with arg set to the argument passed in"]
    #[doc = " dds_create_listener() and reset_on_invoke to true, and throwing away the result."]
    #[doc = ""]
    #[doc = " @param[in,out] listener listener structure to update"]
    #[doc = " @param[in] callback the callback to set or a null pointer"]
    pub fn dds_lset_sample_lost(listener: *mut dds_listener_t, callback: dds_on_sample_lost_fn);
}
extern "C" {
    #[doc = " @ingroup listener_setters"]
    #[doc = " @brief Set the data_available callback in the listener structure."]
    #[doc = ""]
    #[doc = " Equivalent to calling @ref dds_lset_data_available_arg with arg set to the argument passed in"]
    #[doc = " dds_create_listener() and reset_on_invoke to true, and throwing away the result."]
    #[doc = ""]
    #[doc = " @param[in,out] listener listener structure to update"]
    #[doc = " @param[in] callback the callback to set or a null pointer"]
    pub fn dds_lset_data_available(
        listener: *mut dds_listener_t,
        callback: dds_on_data_available_fn,
    );
}
extern "C" {
    #[doc = " @ingroup listener_setters"]
    #[doc = " @brief Set the sample_rejected callback in the listener structure."]
    #[doc = ""]
    #[doc = " Equivalent to calling @ref dds_lset_sample_rejected_arg with arg set to the argument passed in"]
    #[doc = " dds_create_listener() and reset_on_invoke to true, and throwing away the result."]
    #[doc = ""]
    #[doc = " @param[in,out] listener listener structure to update"]
    #[doc = " @param[in] callback the callback to set or a null pointer"]
    pub fn dds_lset_sample_rejected(
        listener: *mut dds_listener_t,
        callback: dds_on_sample_rejected_fn,
    );
}
extern "C" {
    #[doc = " @ingroup listener_setters"]
    #[doc = " @brief Set the liveliness_changed callback in the listener structure."]
    #[doc = ""]
    #[doc = " Equivalent to calling @ref dds_lset_liveliness_changed_arg with arg set to the argument passed in"]
    #[doc = " dds_create_listener() and reset_on_invoke to true, and throwing away the result."]
    #[doc = ""]
    #[doc = " @param[in,out] listener listener structure to update"]
    #[doc = " @param[in] callback the callback to set or a null pointer"]
    pub fn dds_lset_liveliness_changed(
        listener: *mut dds_listener_t,
        callback: dds_on_liveliness_changed_fn,
    );
}
extern "C" {
    #[doc = " @ingroup listener_setters"]
    #[doc = " @brief Set the requested_deadline_missed callback in the listener structure."]
    #[doc = ""]
    #[doc = " Equivalent to calling @ref dds_lset_requested_deadline_missed_arg with arg set to the argument passed in"]
    #[doc = " dds_create_listener() and reset_on_invoke to true, and throwing away the result."]
    #[doc = ""]
    #[doc = " @param[in,out] listener listener structure to update"]
    #[doc = " @param[in] callback the callback to set or a null pointer"]
    pub fn dds_lset_requested_deadline_missed(
        listener: *mut dds_listener_t,
        callback: dds_on_requested_deadline_missed_fn,
    );
}
extern "C" {
    #[doc = " @ingroup listener_setters"]
    #[doc = " @brief Set the requested_incompatible_qos callback in the listener structure."]
    #[doc = ""]
    #[doc = " Equivalent to calling @ref dds_lset_requested_incompatible_qos_arg with arg set to the argument passed in"]
    #[doc = " dds_create_listener() and reset_on_invoke to true, and throwing away the result."]
    #[doc = ""]
    #[doc = " @param[in,out] listener listener structure to update"]
    #[doc = " @param[in] callback the callback to set or a null pointer"]
    pub fn dds_lset_requested_incompatible_qos(
        listener: *mut dds_listener_t,
        callback: dds_on_requested_incompatible_qos_fn,
    );
}
extern "C" {
    #[doc = " @ingroup listener_setters"]
    #[doc = " @brief Set the publication_matched callback in the listener structure."]
    #[doc = ""]
    #[doc = " Equivalent to calling @ref dds_lset_publication_matched_arg with arg set to the argument passed in"]
    #[doc = " dds_create_listener() and reset_on_invoke to true, and throwing away the result."]
    #[doc = ""]
    #[doc = " @param[in,out] listener listener structure to update"]
    #[doc = " @param[in] callback the callback to set or a null pointer"]
    pub fn dds_lset_publication_matched(
        listener: *mut dds_listener_t,
        callback: dds_on_publication_matched_fn,
    );
}
extern "C" {
    #[doc = " @ingroup listener_setters"]
    #[doc = " @brief Set the subscription_matched callback in the listener structure."]
    #[doc = ""]
    #[doc = " Equivalent to calling @ref dds_lset_subscription_matched_arg with arg set to the argument passed in"]
    #[doc = " dds_create_listener() and reset_on_invoke to true, and throwing away the result."]
    #[doc = ""]
    #[doc = " @param[in,out] listener listener structure to update"]
    #[doc = " @param[in] callback the callback to set or a null pointer"]
    pub fn dds_lset_subscription_matched(
        listener: *mut dds_listener_t,
        callback: dds_on_subscription_matched_fn,
    );
}
extern "C" {
    #[doc = " @ingroup listener_getters"]
    #[doc = " @brief Get the inconsistent_topic callback from the listener structure"]
    #[doc = ""]
    #[doc = " Equivalent to calling @ref dds_lget_inconsistent_topic_arg with arg and reset_on_invoke set to a null pointer and throwing away the result."]
    #[doc = ""]
    #[doc = " @param[in] listener The pointer to the listener structure, where the callback will be retrieved from"]
    #[doc = " @param[out] callback Callback function; may be a null pointer"]
    pub fn dds_lget_inconsistent_topic(
        listener: *const dds_listener_t,
        callback: *mut dds_on_inconsistent_topic_fn,
    );
}
extern "C" {
    #[doc = " @ingroup listener_getters"]
    #[doc = " @brief Get the liveliness_lost callback from the listener structure."]
    #[doc = ""]
    #[doc = " Equivalent to calling @ref dds_lget_liveliness_lost_arg with arg and reset_on_invoke set to a null pointer and throwing away the result."]
    #[doc = ""]
    #[doc = " @param[in] listener The pointer to the listener structure, where the callback will be retrieved from"]
    #[doc = " @param[out] callback Callback function; may be a null pointer"]
    pub fn dds_lget_liveliness_lost(
        listener: *const dds_listener_t,
        callback: *mut dds_on_liveliness_lost_fn,
    );
}
extern "C" {
    #[doc = " @ingroup listener_getters"]
    #[doc = " @brief Get the offered_deadline_missed callback from the listener structure."]
    #[doc = ""]
    #[doc = " Equivalent to calling @ref dds_lget_offered_deadline_missed_arg with arg and reset_on_invoke set to a null pointer and throwing away the result."]
    #[doc = ""]
    #[doc = " @param[in] listener The pointer to the listener structure, where the callback will be retrieved from"]
    #[doc = " @param[out] callback Callback function; may be a null pointer"]
    pub fn dds_lget_offered_deadline_missed(
        listener: *const dds_listener_t,
        callback: *mut dds_on_offered_deadline_missed_fn,
    );
}
extern "C" {
    #[doc = " @ingroup listener_getters"]
    #[doc = " @brief Get the offered_incompatible_qos callback from the listener structure."]
    #[doc = ""]
    #[doc = " Equivalent to calling @ref dds_lget_offered_incompatible_qos_arg with arg and reset_on_invoke set to a null pointer and throwing away the result."]
    #[doc = ""]
    #[doc = " @param[in] listener The pointer to the listener structure, where the callback will be retrieved from"]
    #[doc = " @param[out] callback Callback function; may be a null pointer"]
    pub fn dds_lget_offered_incompatible_qos(
        listener: *const dds_listener_t,
        callback: *mut dds_on_offered_incompatible_qos_fn,
    );
}
extern "C" {
    #[doc = " @ingroup listener_getters"]
    #[doc = " @brief Get the data_on_readers callback from the listener structure."]
    #[doc = ""]
    #[doc = " Equivalent to calling @ref dds_lget_data_on_readers_arg with arg and reset_on_invoke set to a null pointer and throwing away the result."]
    #[doc = ""]
    #[doc = " @param[in] listener The pointer to the listener structure, where the callback will be retrieved from"]
    #[doc = " @param[out] callback Callback function; may be a null pointer"]
    pub fn dds_lget_data_on_readers(
        listener: *const dds_listener_t,
        callback: *mut dds_on_data_on_readers_fn,
    );
}
extern "C" {
    #[doc = " @ingroup listener_getters"]
    #[doc = " @brief Get the sample_lost callback from the listener structure."]
    #[doc = ""]
    #[doc = " Equivalent to calling @ref dds_lget_sample_lost_arg with arg and reset_on_invoke set to a null pointer and throwing away the result."]
    #[doc = ""]
    #[doc = " @param[in] listener The pointer to the listener structure, where the callback will be retrieved from"]
    #[doc = " @param[out] callback Callback function; may be a null pointer"]
    pub fn dds_lget_sample_lost(
        listener: *const dds_listener_t,
        callback: *mut dds_on_sample_lost_fn,
    );
}
extern "C" {
    #[doc = " @ingroup listener_getters"]
    #[doc = " @brief Get the data_available callback from the listener structure."]
    #[doc = ""]
    #[doc = " Equivalent to calling @ref dds_lget_data_available_arg with arg and reset_on_invoke set to a null pointer and throwing away the result."]
    #[doc = ""]
    #[doc = " @param[in] listener The pointer to the listener structure, where the callback will be retrieved from"]
    #[doc = " @param[out] callback Callback function; may be a null pointer"]
    pub fn dds_lget_data_available(
        listener: *const dds_listener_t,
        callback: *mut dds_on_data_available_fn,
    );
}
extern "C" {
    #[doc = " @ingroup listener_getters"]
    #[doc = " @brief Get the sample_rejected callback from the listener structure."]
    #[doc = ""]
    #[doc = " Equivalent to calling @ref dds_lget_sample_rejected_arg with arg and reset_on_invoke set to a null pointer and throwing away the result."]
    #[doc = ""]
    #[doc = " @param[in] listener The pointer to the listener structure, where the callback will be retrieved from"]
    #[doc = " @param[out] callback Callback function; may be a null pointer"]
    pub fn dds_lget_sample_rejected(
        listener: *const dds_listener_t,
        callback: *mut dds_on_sample_rejected_fn,
    );
}
extern "C" {
    #[doc = " @ingroup listener_getters"]
    #[doc = " @brief Get the liveliness_changed callback from the listener structure."]
    #[doc = ""]
    #[doc = " Equivalent to calling @ref dds_lget_liveliness_changed_arg with arg and reset_on_invoke set to a null pointer and throwing away the result."]
    #[doc = ""]
    #[doc = " @param[in] listener The pointer to the listener structure, where the callback will be retrieved from"]
    #[doc = " @param[out] callback Callback function; may be a null pointer"]
    pub fn dds_lget_liveliness_changed(
        listener: *const dds_listener_t,
        callback: *mut dds_on_liveliness_changed_fn,
    );
}
extern "C" {
    #[doc = " @ingroup listener_getters"]
    #[doc = " @brief Get the requested_deadline_missed callback from the listener structure."]
    #[doc = ""]
    #[doc = " Equivalent to calling @ref dds_lget_requested_deadline_missed_arg with arg and reset_on_invoke set to a null pointer and throwing away the result."]
    #[doc = ""]
    #[doc = " @param[in] listener The pointer to the listener structure, where the callback will be retrieved from"]
    #[doc = " @param[out] callback Callback function; may be a null pointer"]
    pub fn dds_lget_requested_deadline_missed(
        listener: *const dds_listener_t,
        callback: *mut dds_on_requested_deadline_missed_fn,
    );
}
extern "C" {
    #[doc = " @ingroup listener_getters"]
    #[doc = " @brief Get the requested_incompatible_qos callback from the listener structure."]
    #[doc = ""]
    #[doc = " Equivalent to calling @ref dds_lget_requested_incompatible_qos_arg with arg and reset_on_invoke set to a null pointer and throwing away the result."]
    #[doc = ""]
    #[doc = " @param[in] listener The pointer to the listener structure, where the callback will be retrieved from"]
    #[doc = " @param[out] callback Callback function; may be a null pointer"]
    pub fn dds_lget_requested_incompatible_qos(
        listener: *const dds_listener_t,
        callback: *mut dds_on_requested_incompatible_qos_fn,
    );
}
extern "C" {
    #[doc = " @ingroup listener_getters"]
    #[doc = " @brief Get the publication_matched callback from the listener structure."]
    #[doc = ""]
    #[doc = " Equivalent to calling @ref dds_lget_publication_matched_arg with arg and reset_on_invoke set to a null pointer and throwing away the result."]
    #[doc = ""]
    #[doc = " @param[in] listener The pointer to the listener structure, where the callback will be retrieved from"]
    #[doc = " @param[out] callback Callback function; may be a null pointer"]
    pub fn dds_lget_publication_matched(
        listener: *const dds_listener_t,
        callback: *mut dds_on_publication_matched_fn,
    );
}
extern "C" {
    #[doc = " @ingroup listener_getters"]
    #[doc = " @brief Get the subscription_matched callback from the listener structure."]
    #[doc = ""]
    #[doc = " Equivalent to calling @ref dds_lget_subscription_matched_arg with arg and reset_on_invoke set to a null pointer and throwing away the result."]
    #[doc = ""]
    #[doc = " @param[in] listener The pointer to the listener structure, where the callback will be retrieved from"]
    #[doc = " @param[out] callback Callback function; may be a null pointer"]
    pub fn dds_lget_subscription_matched(
        listener: *const dds_listener_t,
        callback: *mut dds_on_subscription_matched_fn,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddsi_typeid {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddsi_typeinfo {
    _unused: [u8; 0],
}
#[doc = " @brief DDS Type Information (XTypes)"]
#[doc = " @ingroup dds"]
#[doc = " DOC_TODO"]
pub type dds_typeinfo_t = ddsi_typeinfo;
#[doc = " @brief Reader History Cache"]
#[doc = " @ingroup dds"]
#[doc = " DOC_TODO"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_rhc {
    _unused: [u8; 0],
}
#[doc = " @brief DDSI parameter list"]
#[doc = " @ingroup dds"]
#[doc = " DOC_TODO"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddsi_plist {
    _unused: [u8; 0],
}
#[doc = " @ingroup deprecated"]
#[doc = " @warning The DDSI sertopic functionality was moved to ddsi_sertype."]
#[doc = " It has been retained as a symbol to ensure binary compatibility."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddsi_sertopic {
    _unused: [u8; 0],
}
#[doc = "< See @ref DDS_INCONSISTENT_TOPIC_STATUS"]
pub const dds_status_id_DDS_INCONSISTENT_TOPIC_STATUS_ID: dds_status_id = 0;
#[doc = "< See @ref DDS_OFFERED_DEADLINE_MISSED_STATUS"]
pub const dds_status_id_DDS_OFFERED_DEADLINE_MISSED_STATUS_ID: dds_status_id = 1;
#[doc = "< See @ref DDS_REQUESTED_DEADLINE_MISSED_STATUS"]
pub const dds_status_id_DDS_REQUESTED_DEADLINE_MISSED_STATUS_ID: dds_status_id = 2;
#[doc = "< See @ref DDS_OFFERED_INCOMPATIBLE_QOS_STATUS"]
pub const dds_status_id_DDS_OFFERED_INCOMPATIBLE_QOS_STATUS_ID: dds_status_id = 3;
#[doc = "< See @ref DDS_REQUESTED_INCOMPATIBLE_QOS_STATUS"]
pub const dds_status_id_DDS_REQUESTED_INCOMPATIBLE_QOS_STATUS_ID: dds_status_id = 4;
#[doc = "< See @ref DDS_SAMPLE_LOST_STATUS"]
pub const dds_status_id_DDS_SAMPLE_LOST_STATUS_ID: dds_status_id = 5;
#[doc = "< See @ref DDS_SAMPLE_REJECTED_STATUS"]
pub const dds_status_id_DDS_SAMPLE_REJECTED_STATUS_ID: dds_status_id = 6;
#[doc = "< See @ref DDS_DATA_ON_READERS_STATUS"]
pub const dds_status_id_DDS_DATA_ON_READERS_STATUS_ID: dds_status_id = 7;
#[doc = "< See @ref DDS_DATA_AVAILABLE_STATUS"]
pub const dds_status_id_DDS_DATA_AVAILABLE_STATUS_ID: dds_status_id = 8;
#[doc = "< See @ref DDS_LIVELINESS_LOST_STATUS"]
pub const dds_status_id_DDS_LIVELINESS_LOST_STATUS_ID: dds_status_id = 9;
#[doc = "< See @ref DDS_LIVELINESS_CHANGED_STATUS"]
pub const dds_status_id_DDS_LIVELINESS_CHANGED_STATUS_ID: dds_status_id = 10;
#[doc = "< See @ref DDS_PUBLICATION_MATCHED_STATUS"]
pub const dds_status_id_DDS_PUBLICATION_MATCHED_STATUS_ID: dds_status_id = 11;
#[doc = "< See @ref DDS_SUBSCRIPTION_MATCHED_STATUS"]
pub const dds_status_id_DDS_SUBSCRIPTION_MATCHED_STATUS_ID: dds_status_id = 12;
#[doc = " @defgroup entity_status (Entity Status)"]
#[doc = " @ingroup entity"]
#[doc = " All entities have a set of \"status conditions\""]
#[doc = " (following the DCPS spec), read peeks, take reads & resets (analogously to read &"]
#[doc = " take operations on reader). The \"mask\" allows operating only on a subset of the statuses."]
#[doc = " Enabled status analogously to DCPS spec."]
#[doc = " @{"]
#[doc = " @brief These identifiers are used to generate the bitshifted identifiers."]
#[doc = " By using bitflags instead of these IDs the process of building status masks is"]
#[doc = " simplified to using simple binary OR operations."]
#[doc = " DOC_TODO fix the refs"]
pub type dds_status_id = ::std::os::raw::c_uint;
#[doc = " @defgroup entity_status (Entity Status)"]
#[doc = " @ingroup entity"]
#[doc = " All entities have a set of \"status conditions\""]
#[doc = " (following the DCPS spec), read peeks, take reads & resets (analogously to read &"]
#[doc = " take operations on reader). The \"mask\" allows operating only on a subset of the statuses."]
#[doc = " Enabled status analogously to DCPS spec."]
#[doc = " @{"]
#[doc = " @brief These identifiers are used to generate the bitshifted identifiers."]
#[doc = " By using bitflags instead of these IDs the process of building status masks is"]
#[doc = " simplified to using simple binary OR operations."]
#[doc = " DOC_TODO fix the refs"]
pub use self::dds_status_id as dds_status_id_t;
#[doc = "<DataReader has already accessed the sample by read"]
pub const dds_sample_state_DDS_SST_READ: dds_sample_state = 1;
#[doc = "<DataReader has not accessed the sample before"]
pub const dds_sample_state_DDS_SST_NOT_READ: dds_sample_state = 2;
#[doc = " Read state for a data value"]
pub type dds_sample_state = ::std::os::raw::c_uint;
#[doc = " Read state for a data value"]
pub use self::dds_sample_state as dds_sample_state_t;
#[doc = " DataReader is accessing the sample for the first time when the instance is alive"]
pub const dds_view_state_DDS_VST_NEW: dds_view_state = 4;
#[doc = " DataReader accessed the sample before"]
pub const dds_view_state_DDS_VST_OLD: dds_view_state = 8;
#[doc = " View state of an instance relative to the samples"]
pub type dds_view_state = ::std::os::raw::c_uint;
#[doc = " View state of an instance relative to the samples"]
pub use self::dds_view_state as dds_view_state_t;
#[doc = " Samples received for the instance from the live data writers"]
pub const dds_instance_state_DDS_IST_ALIVE: dds_instance_state = 16;
#[doc = " Instance was explicitly disposed by the data writer"]
pub const dds_instance_state_DDS_IST_NOT_ALIVE_DISPOSED: dds_instance_state = 32;
#[doc = " Instance has been declared as not alive by data reader as there are no live data writers writing that instance"]
pub const dds_instance_state_DDS_IST_NOT_ALIVE_NO_WRITERS: dds_instance_state = 64;
#[doc = " Defines the state of the instance"]
pub type dds_instance_state = ::std::os::raw::c_uint;
#[doc = " Defines the state of the instance"]
pub use self::dds_instance_state as dds_instance_state_t;
#[doc = " Contains information about the associated data value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_sample_info {
    #[doc = " Sample state"]
    pub sample_state: dds_sample_state_t,
    #[doc = " View state"]
    pub view_state: dds_view_state_t,
    #[doc = " Instance state"]
    pub instance_state: dds_instance_state_t,
    #[doc = " Indicates whether there is a data associated with a sample"]
    #[doc = "  - true, indicates the data is valid"]
    #[doc = "  - false, indicates the data is invalid, no data to read"]
    pub valid_data: bool,
    #[doc = " timestamp of a data instance when it is written"]
    pub source_timestamp: dds_time_t,
    #[doc = " handle to the data instance"]
    pub instance_handle: dds_instance_handle_t,
    #[doc = " handle to the publisher"]
    pub publication_handle: dds_instance_handle_t,
    #[doc = " count of instance state change from NOT_ALIVE_DISPOSED to ALIVE"]
    pub disposed_generation_count: u32,
    #[doc = " count of instance state change from NOT_ALIVE_NO_WRITERS to ALIVE"]
    pub no_writers_generation_count: u32,
    #[doc = " indicates the number of samples of the same instance that follow the current one in the collection"]
    pub sample_rank: u32,
    #[doc = " difference in generations between the sample and most recent sample of the same instance that appears in the returned collection"]
    pub generation_rank: u32,
    #[doc = " difference in generations between the sample and most recent sample of the same instance when read/take was called"]
    pub absolute_generation_rank: u32,
}
#[test]
fn bindgen_test_layout_dds_sample_info() {
    assert_eq!(
        ::std::mem::size_of::<dds_sample_info>(),
        64usize,
        concat!("Size of: ", stringify!(dds_sample_info))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_sample_info>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_sample_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_sample_info>())).sample_state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_info),
            "::",
            stringify!(sample_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_sample_info>())).view_state as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_info),
            "::",
            stringify!(view_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_sample_info>())).instance_state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_info),
            "::",
            stringify!(instance_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_sample_info>())).valid_data as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_info),
            "::",
            stringify!(valid_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_sample_info>())).source_timestamp as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_info),
            "::",
            stringify!(source_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_sample_info>())).instance_handle as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_info),
            "::",
            stringify!(instance_handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_sample_info>())).publication_handle as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_info),
            "::",
            stringify!(publication_handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_sample_info>())).disposed_generation_count as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_info),
            "::",
            stringify!(disposed_generation_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_sample_info>())).no_writers_generation_count as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_info),
            "::",
            stringify!(no_writers_generation_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_sample_info>())).sample_rank as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_info),
            "::",
            stringify!(sample_rank)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_sample_info>())).generation_rank as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_info),
            "::",
            stringify!(generation_rank)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_sample_info>())).absolute_generation_rank as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_info),
            "::",
            stringify!(absolute_generation_rank)
        )
    );
}
impl Default for dds_sample_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Contains information about the associated data value"]
pub type dds_sample_info_t = dds_sample_info;
#[doc = " @brief Structure of a GUID in any builtin topic sample."]
#[doc = " @ingroup builtintopic"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_builtintopic_guid {
    #[doc = "< 16-byte unique identifier"]
    pub v: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_dds_builtintopic_guid() {
    assert_eq!(
        ::std::mem::size_of::<dds_builtintopic_guid>(),
        16usize,
        concat!("Size of: ", stringify!(dds_builtintopic_guid))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_builtintopic_guid>(),
        1usize,
        concat!("Alignment of ", stringify!(dds_builtintopic_guid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_builtintopic_guid>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_builtintopic_guid),
            "::",
            stringify!(v)
        )
    );
}
#[doc = " @brief Structure of a GUID in any builtin topic sample."]
#[doc = " @ingroup builtintopic"]
#[doc = " @ref dds_builtintopic_guid_t is a bit of a weird name for what everyone just calls a GUID,"]
#[doc = " so let us try and switch to using the more logical one."]
pub type dds_guid_t = dds_builtintopic_guid;
#[doc = " @brief Sample structure of the Builtin topic DcpsPublication and DcpsSubscription."]
#[doc = " @ingroup builtintopic"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_builtintopic_endpoint {
    #[doc = "< The GUID that uniquely identifies the endpoint on the network"]
    pub key: dds_guid_t,
    #[doc = "< The GUID of the participant this endpoint belongs to."]
    pub participant_key: dds_guid_t,
    #[doc = "< The instance handle the participant assigned to this enpoint."]
    pub participant_instance_handle: dds_instance_handle_t,
    #[doc = "< The name of the topic, potentially unicode."]
    pub topic_name: *mut ::std::os::raw::c_char,
    #[doc = "< The name of the type, potentially unicode."]
    pub type_name: *mut ::std::os::raw::c_char,
    #[doc = "< The QoS of the endpoint"]
    pub qos: *mut dds_qos_t,
}
#[test]
fn bindgen_test_layout_dds_builtintopic_endpoint() {
    assert_eq!(
        ::std::mem::size_of::<dds_builtintopic_endpoint>(),
        64usize,
        concat!("Size of: ", stringify!(dds_builtintopic_endpoint))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_builtintopic_endpoint>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_builtintopic_endpoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_builtintopic_endpoint>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_builtintopic_endpoint),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_builtintopic_endpoint>())).participant_key as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_builtintopic_endpoint),
            "::",
            stringify!(participant_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_builtintopic_endpoint>())).participant_instance_handle
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_builtintopic_endpoint),
            "::",
            stringify!(participant_instance_handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_builtintopic_endpoint>())).topic_name as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_builtintopic_endpoint),
            "::",
            stringify!(topic_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_builtintopic_endpoint>())).type_name as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_builtintopic_endpoint),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_builtintopic_endpoint>())).qos as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_builtintopic_endpoint),
            "::",
            stringify!(qos)
        )
    );
}
impl Default for dds_builtintopic_endpoint {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " @brief Sample structure of the Builtin topic DcpsPublication and DcpsSubscription."]
#[doc = " @ingroup builtintopic"]
pub type dds_builtintopic_endpoint_t = dds_builtintopic_endpoint;
extern "C" {
    #[doc = " @brief Enable entity."]
    #[doc = " @ingroup entity"]
    #[doc = ""]
    #[doc = " @note Delayed entity enabling is not supported yet (CHAM-96)."]
    #[doc = ""]
    #[doc = " This operation enables the dds_entity_t. Created dds_entity_t objects can start in"]
    #[doc = " either an enabled or disabled state. This is controlled by the value of the"]
    #[doc = " entityfactory policy on the corresponding parent entity for the given"]
    #[doc = " entity. Enabled entities are immediately activated at creation time meaning"]
    #[doc = " all their immutable QoS settings can no longer be changed. Disabled Entities are not"]
    #[doc = " yet activated, so it is still possible to change their immutable QoS settings. However,"]
    #[doc = " once activated the immutable QoS settings can no longer be changed."]
    #[doc = " Creating disabled entities can make sense when the creator of the DDS_Entity"]
    #[doc = " does not yet know which QoS settings to apply, thus allowing another piece of code"]
    #[doc = " to set the QoS later on."]
    #[doc = ""]
    #[doc = " The default setting of DDS_EntityFactoryQosPolicy is such that, by default,"]
    #[doc = " entities are created in an enabled state so that it is not necessary to explicitly call"]
    #[doc = " dds_enable on newly-created entities."]
    #[doc = ""]
    #[doc = " The dds_enable operation produces the same results no matter how"]
    #[doc = " many times it is performed. Calling dds_enable on an already"]
    #[doc = " enabled DDS_Entity returns DDS_RETCODE_OK and has no effect."]
    #[doc = ""]
    #[doc = " If an Entity has not yet been enabled, the only operations that can be invoked"]
    #[doc = " on it are: the ones to set, get or copy the QosPolicy settings, the ones that set"]
    #[doc = " (or get) the Listener, the ones that get the Status and the dds_get_status_changes"]
    #[doc = " operation (although the status of a disabled entity never changes). Other operations"]
    #[doc = " will return the error DDS_RETCODE_NOT_ENABLED."]
    #[doc = ""]
    #[doc = " Entities created with a parent that is disabled, are created disabled regardless of"]
    #[doc = " the setting of the entityfactory policy."]
    #[doc = ""]
    #[doc = " If the entityfactory policy has autoenable_created_entities"]
    #[doc = " set to TRUE, the dds_enable operation on the parent will"]
    #[doc = " automatically enable all child entities created with the parent."]
    #[doc = ""]
    #[doc = " The Listeners associated with an Entity are not called until the"]
    #[doc = " Entity is enabled. Conditions associated with an Entity that"]
    #[doc = " is not enabled are \"inactive\", that is, have a trigger_value which is FALSE."]
    #[doc = ""]
    #[doc = " @param[in]  entity  The entity to enable."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The listeners of to the entity have been successfully been copied"]
    #[doc = "             into the specified listener parameter."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    #[doc = " @retval DDS_RETCODE_PRECONDITION_NOT_MET"]
    #[doc = "             The parent of the given Entity is not enabled."]
    pub fn dds_enable(entity: dds_entity_t) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Delete given entity."]
    #[doc = " @ingroup entity"]
    #[doc = ""]
    #[doc = " This operation will delete the given entity. It will also automatically"]
    #[doc = " delete all its children, childrens' children, etc entities."]
    #[doc = ""]
    #[doc = " @param[in]  entity  Entity to delete."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The entity and its children (recursive are deleted)."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_delete(entity: dds_entity_t) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Get entity publisher."]
    #[doc = " @ingroup entity"]
    #[doc = ""]
    #[doc = " This operation returns the publisher to which the given entity belongs."]
    #[doc = " For instance, it will return the Publisher that was used when"]
    #[doc = " creating a DataWriter (when that DataWriter was provided here)."]
    #[doc = ""]
    #[doc = " @param[in]  writer  Entity from which to get its publisher."]
    #[doc = ""]
    #[doc = " @returns A valid entity or an error code."]
    #[doc = ""]
    #[doc = " @retval >0"]
    #[doc = "             A valid publisher handle."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_get_publisher(writer: dds_entity_t) -> dds_entity_t;
}
extern "C" {
    #[doc = " @brief Get entity subscriber."]
    #[doc = " @ingroup entity"]
    #[doc = ""]
    #[doc = " This operation returns the subscriber to which the given entity belongs."]
    #[doc = " For instance, it will return the Subscriber that was used when"]
    #[doc = " creating a DataReader (when that DataReader was provided here)."]
    #[doc = ""]
    #[doc = " @param[in]  entity  Entity from which to get its subscriber."]
    #[doc = ""]
    #[doc = " @returns A valid subscriber handle or an error code."]
    #[doc = ""]
    #[doc = " @retval >0"]
    #[doc = "             A valid subscriber handle."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    #[doc = " DOC_TODO: Link to generic dds entity relations documentation."]
    pub fn dds_get_subscriber(entity: dds_entity_t) -> dds_entity_t;
}
extern "C" {
    #[doc = " @brief Get entity datareader."]
    #[doc = " @ingroup entity"]
    #[doc = ""]
    #[doc = " This operation returns the datareader to which the given entity belongs."]
    #[doc = " For instance, it will return the DataReader that was used when"]
    #[doc = " creating a ReadCondition (when that ReadCondition was provided here)."]
    #[doc = ""]
    #[doc = " @param[in]  entity  Entity from which to get its datareader."]
    #[doc = ""]
    #[doc = " @returns A valid reader handle or an error code."]
    #[doc = ""]
    #[doc = " @retval >0"]
    #[doc = "             A valid reader handle."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    #[doc = " DOC_TODO: Link to generic dds entity relations documentation."]
    pub fn dds_get_datareader(entity: dds_entity_t) -> dds_entity_t;
}
extern "C" {
    #[doc = " @brief Get the mask of a condition."]
    #[doc = " @ingroup condition"]
    #[doc = ""]
    #[doc = " This operation returns the mask that was used to create the given"]
    #[doc = " condition."]
    #[doc = ""]
    #[doc = " @param[in]  condition  Read or Query condition that has a mask."]
    #[doc = " @param[out] mask       Where to store the mask of the condition."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             Success (given mask is set)."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The mask arg is NULL."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_get_mask(condition: dds_entity_t, mask: *mut u32) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Returns the instance handle that represents the entity."]
    #[doc = " @ingroup entity"]
    #[doc = ""]
    #[doc = " @param[in]   entity  Entity of which to get the instance handle."]
    #[doc = " @param[out]  ihdl    Pointer to dds_instance_handle_t."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             Success."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " DOC_TODO: Check list of return codes is complete."]
    pub fn dds_get_instance_handle(
        entity: dds_entity_t,
        ihdl: *mut dds_instance_handle_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Read the status set for the entity"]
    #[doc = " @ingroup entity_status"]
    #[doc = ""]
    #[doc = " This operation reads the status(es) set for the entity based on"]
    #[doc = " the enabled status and mask set. It does not clear the read status(es)."]
    #[doc = ""]
    #[doc = " @param[in]  entity  Entity on which the status has to be read."]
    #[doc = " @param[out] status  Returns the status set on the entity, based on the enabled status."]
    #[doc = " @param[in]  mask    Filter the status condition to be read, 0 means all statuses"]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             Success."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The entity parameter is not a valid parameter, status is a null pointer or"]
    #[doc = "             mask has bits set outside the status range."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object or mask has status"]
    #[doc = "             bits set that are undefined for the type of entity."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_read_status(entity: dds_entity_t, status: *mut u32, mask: u32) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Read the status set for the entity"]
    #[doc = " @ingroup entity_status"]
    #[doc = ""]
    #[doc = " This operation reads the status(es) set for the entity based on the enabled"]
    #[doc = " status and mask set. It clears the status set after reading."]
    #[doc = ""]
    #[doc = " @param[in]  entity  Entity on which the status has to be read."]
    #[doc = " @param[out] status  Returns the status set on the entity, based on the enabled status."]
    #[doc = " @param[in]  mask    Filter the status condition to be read, 0 means all statuses"]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             Success."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The entity parameter is not a valid parameter, status is a null pointer or"]
    #[doc = "             mask has bits set outside the status range."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object or mask has status"]
    #[doc = "             bits set that are undefined for the type of entity."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_take_status(entity: dds_entity_t, status: *mut u32, mask: u32) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Get changed status(es)"]
    #[doc = " @ingroup entity_status"]
    #[doc = ""]
    #[doc = " This operation returns the status changes since they were last read."]
    #[doc = ""]
    #[doc = " @param[in]  entity  Entity on which the statuses are read."]
    #[doc = " @param[out] status  Returns the current set of triggered statuses."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             Success."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The entity parameter is not a valid parameter."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_get_status_changes(entity: dds_entity_t, status: *mut u32) -> dds_return_t;
}
extern "C" {
    #[doc = " @anchor dds_get_status_mask"]
    #[doc = " @brief Get enabled status on entity"]
    #[doc = " @ingroup entity_status"]
    #[doc = ""]
    #[doc = " This operation returns the status enabled on the entity"]
    #[doc = ""]
    #[doc = " @param[in]  entity  Entity to get the status."]
    #[doc = " @param[out] mask    Mask of enabled statuses set on the entity."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             Success."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The entity parameter is not a valid parameter."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_get_status_mask(entity: dds_entity_t, mask: *mut u32) -> dds_return_t;
}
extern "C" {
    #[doc = " @deprecated Get enabled status on entity. Use \\ref dds_get_status_mask instead."]
    #[doc = " @ingroup deprecated"]
    #[doc = ""]
    #[doc = " @param[in] entity  Entity to get the status."]
    #[doc = " @param[out] mask   Mask of enabled statuses set on the entity."]
    #[doc = " @returns A dds_return_t indicating success of failure."]
    pub fn dds_get_enabled_status(entity: dds_entity_t, mask: *mut u32) -> dds_return_t;
}
extern "C" {
    #[doc = " @anchor dds_set_status_mask"]
    #[doc = " @brief Set status enabled on entity"]
    #[doc = " @ingroup entity_status"]
    #[doc = ""]
    #[doc = " This operation enables the status(es) based on the mask set"]
    #[doc = ""]
    #[doc = " @param[in]  entity  Entity to enable the status."]
    #[doc = " @param[in]  mask    Status value that indicates the status to be enabled."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             Success."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The entity parameter is not a valid parameter."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_set_status_mask(entity: dds_entity_t, mask: u32) -> dds_return_t;
}
extern "C" {
    #[doc = " @deprecated Set enabled status on entity. Use \\ref dds_set_status_mask instead."]
    #[doc = " @ingroup deprecated"]
    #[doc = ""]
    #[doc = " @param[in] entity  Entity to enable the status."]
    #[doc = " @param[out] mask   Status value that indicates the status to be enabled."]
    #[doc = " @returns A dds_return_t indicating success of failure."]
    pub fn dds_set_enabled_status(entity: dds_entity_t, mask: u32) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Get entity QoS policies."]
    #[doc = " @ingroup entity_qos"]
    #[doc = ""]
    #[doc = " This operation allows access to the existing set of QoS policies"]
    #[doc = " for the entity."]
    #[doc = ""]
    #[doc = " @param[in]  entity  Entity on which to get qos."]
    #[doc = " @param[out] qos     Pointer to the qos structure that returns the set policies."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure. The QoS object will have"]
    #[doc = " at least all QoS relevant for the entity present and the corresponding dds_qget_..."]
    #[doc = " will return true."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The existing set of QoS policy values applied to the entity"]
    #[doc = "             has successfully been copied into the specified qos parameter."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The qos parameter is NULL."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    #[doc = ""]
    #[doc = " DOC_TODO: Link to generic QoS information documentation."]
    pub fn dds_get_qos(entity: dds_entity_t, qos: *mut dds_qos_t) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Set entity QoS policies."]
    #[doc = " @ingroup entity_qos"]
    #[doc = ""]
    #[doc = " This operation replaces the existing set of Qos Policy settings for an"]
    #[doc = " entity. The parameter qos must contain the struct with the QosPolicy"]
    #[doc = " settings which is checked for self-consistency."]
    #[doc = ""]
    #[doc = " The set of QosPolicy settings specified by the qos parameter are applied on"]
    #[doc = " top of the existing QoS, replacing the values of any policies previously set"]
    #[doc = " (provided, the operation returned DDS_RETCODE_OK)."]
    #[doc = ""]
    #[doc = " Not all policies are changeable when the entity is enabled."]
    #[doc = ""]
    #[doc = " @note Currently only Latency Budget and Ownership Strength are changeable QoS"]
    #[doc = "       that can be set."]
    #[doc = ""]
    #[doc = " @param[in]  entity  Entity from which to get qos."]
    #[doc = " @param[in]  qos     Pointer to the qos structure that provides the policies."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The new QoS policies are set."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The qos parameter is NULL."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    #[doc = " @retval DDS_RETCODE_IMMUTABLE_POLICY"]
    #[doc = "             The entity is enabled and one or more of the policies of the QoS"]
    #[doc = "             are immutable."]
    #[doc = " @retval DDS_RETCODE_INCONSISTENT_POLICY"]
    #[doc = "             A few policies within the QoS are not consistent with each other."]
    #[doc = ""]
    #[doc = " DOC_TODO: Link to generic QoS information documentation."]
    pub fn dds_set_qos(entity: dds_entity_t, qos: *const dds_qos_t) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Get entity listeners."]
    #[doc = " @ingroup entity_listener"]
    #[doc = ""]
    #[doc = " This operation allows access to the existing listeners attached to"]
    #[doc = " the entity."]
    #[doc = ""]
    #[doc = " @param[in]  entity   Entity on which to get the listeners."]
    #[doc = " @param[out] listener Pointer to the listener structure that returns the"]
    #[doc = "                      set of listener callbacks."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The listeners of to the entity have been successfully been"]
    #[doc = "             copied into the specified listener parameter."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The listener parameter is NULL."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    #[doc = ""]
    #[doc = " DOC_TODO: Link to (generic) Listener and status information."]
    pub fn dds_get_listener(entity: dds_entity_t, listener: *mut dds_listener_t) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Set entity listeners."]
    #[doc = " @ingroup entity_listener"]
    #[doc = ""]
    #[doc = " This operation attaches a dds_listener_t to the dds_entity_t. Only one"]
    #[doc = " Listener can be attached to each Entity. If a Listener was already"]
    #[doc = " attached, this operation will replace it with the new one. In other"]
    #[doc = " words, all related callbacks are replaced (possibly with NULL)."]
    #[doc = ""]
    #[doc = " When listener parameter is NULL, all listener callbacks that were possibly"]
    #[doc = " set on the Entity will be removed."]
    #[doc = ""]
    #[doc = " @note Not all listener callbacks are related to all entities."]
    #[doc = ""]
    #[doc = " ## Communication Status"]
    #[doc = " For each communication status, the StatusChangedFlag flag is initially set to"]
    #[doc = " FALSE. It becomes TRUE whenever that plain communication status changes. For"]
    #[doc = " each plain communication status activated in the mask, the associated"]
    #[doc = " Listener callback is invoked and the communication status is reset"]
    #[doc = " to FALSE, as the listener implicitly accesses the status which is passed as a"]
    #[doc = " parameter to that operation."]
    #[doc = " The status is reset prior to calling the listener, so if the application calls"]
    #[doc = " the get_<status_name> from inside the listener it will see the"]
    #[doc = " status already reset."]
    #[doc = ""]
    #[doc = " ## Status Propagation"]
    #[doc = " In case a related callback within the Listener is not set, the Listener of"]
    #[doc = " the Parent entity is called recursively, until a Listener with the appropriate"]
    #[doc = " callback set has been found and called. This allows the application to set"]
    #[doc = " (for instance) a default behaviour in the Listener of the containing Publisher"]
    #[doc = " and a DataWriter specific behaviour when needed. In case the callback is not"]
    #[doc = " set in the Publishers' Listener either, the communication status will be"]
    #[doc = " propagated to the Listener of the DomainParticipant of the containing"]
    #[doc = " DomainParticipant. In case the callback is not set in the DomainParticipants'"]
    #[doc = " Listener either, the Communication Status flag will be set, resulting in a"]
    #[doc = " possible WaitSet trigger."]
    #[doc = ""]
    #[doc = " @param[in]  entity    Entity on which to get the listeners."]
    #[doc = " @param[in]  listener  Pointer to the listener structure that contains the"]
    #[doc = "                       set of listener callbacks (maybe NULL)."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The listeners of to the entity have been successfully been"]
    #[doc = "             copied into the specified listener parameter."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    #[doc = " DOC_TODO: Link to (generic) Listener and status information."]
    pub fn dds_set_listener(entity: dds_entity_t, listener: *const dds_listener_t) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Creates a new instance of a DDS participant in a domain"]
    #[doc = " @ingroup domain_participant"]
    #[doc = ""]
    #[doc = " If domain is set (not DDS_DOMAIN_DEFAULT) then it must match if the domain has also"]
    #[doc = " been configured or an error status will be returned."]
    #[doc = " Currently only a single domain can be configured by providing configuration file."]
    #[doc = " If no configuration file exists, the default domain is configured as 0."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param[in]  domain The domain in which to create the participant (can be DDS_DOMAIN_DEFAULT). DDS_DOMAIN_DEFAULT is for using the domain in the configuration."]
    #[doc = " @param[in]  qos The QoS to set on the new participant (can be NULL)."]
    #[doc = " @param[in]  listener Any listener functions associated with the new participant (can be NULL)."]
    #[doc = ""]
    #[doc = " @returns A valid participant handle or an error code."]
    #[doc = ""]
    #[doc = " @retval >0"]
    #[doc = "             A valid participant handle."]
    #[doc = " @retval DDS_RETCODE_NOT_ALLOWED_BY_SECURITY"]
    #[doc = "             An invalid DDS Security configuration was specified (whether"]
    #[doc = "             that be missing or incorrect entries, expired certificates,"]
    #[doc = "             or anything else related to the security settings and"]
    #[doc = "             implementation)."]
    #[doc = " @retval DDS_RETCODE_PRECONDITION_NOT_MET"]
    #[doc = "             Some security properties specified in the QoS, but the Cyclone"]
    #[doc = "             build does not include support for DDS Security."]
    #[doc = " @retval DDS_RETCODE_OUT_OF_RESOURCES"]
    #[doc = "             Some resource limit (maximum participants, memory, handles,"]
    #[doc = "             &c.) prevented creation of the participant."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             The \"CYCLONEDDS_URI\" environment variable lists non-existent"]
    #[doc = "             or invalid configuration files, or contains invalid embedded"]
    #[doc = "             configuration items; or an unspecified internal error has"]
    #[doc = "             occurred."]
    pub fn dds_create_participant(
        domain: dds_domainid_t,
        qos: *const dds_qos_t,
        listener: *const dds_listener_t,
    ) -> dds_entity_t;
}
extern "C" {
    #[doc = " @brief Creates a domain with a given configuration"]
    #[doc = " @ingroup domain"]
    #[doc = ""]
    #[doc = " To explicitly create a domain based on a configuration passed as a string."]
    #[doc = ""]
    #[doc = " It will not be created if a domain with the given domain id already exists."]
    #[doc = " This could have been created implicitly by a dds_create_participant()."]
    #[doc = ""]
    #[doc = " Please be aware that the given domain_id always takes precedence over the"]
    #[doc = " configuration."]
    #[doc = ""]
    #[doc = " | domain_id | domain id in config | result                        |"]
    #[doc = " |:----------|:--------------------|:------------------------------|"]
    #[doc = " | n         | any (or absent)     | n, config is used             |"]
    #[doc = " | n         | m == n              | n, config is used             |"]
    #[doc = " | n         | m != n              | n, config is ignored: default |"]
    #[doc = ""]
    #[doc = " Config models:"]
    #[doc = "  -# @code{xml}"]
    #[doc = "     <CycloneDDS>"]
    #[doc = "        <Domain id=\"X\">...</Domain>"]
    #[doc = "        <!-- <Domain .../> -->"]
    #[doc = "      </CycloneDDS>"]
    #[doc = "      @endcode"]
    #[doc = "      where ... is all that can today be set in children of CycloneDDS"]
    #[doc = "      with the exception of the id"]
    #[doc = "  -# @code{xml}"]
    #[doc = "     <CycloneDDS>"]
    #[doc = "        <Domain><Id>X</Id></Domain>"]
    #[doc = "        <!-- more things here ... -->"]
    #[doc = "     </CycloneDDS>"]
    #[doc = "     @endcode"]
    #[doc = "     Legacy form, domain id must be the first element in the file with"]
    #[doc = "     a value (if nothing has been set previously, it a warning is good"]
    #[doc = "     enough)"]
    #[doc = ""]
    #[doc = " Using NULL or \"\" as config will create a domain with default settings."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param[in]  domain The domain to be created. DEFAULT_DOMAIN is not allowed."]
    #[doc = " @param[in]  config A configuration string containing file names and/or XML fragments representing the configuration."]
    #[doc = ""]
    #[doc = " @returns A valid entity handle or an error code."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             Illegal value for domain id or the configfile parameter is NULL."]
    #[doc = " @retval DDS_RETCODE_PRECONDITION_NOT_MET"]
    #[doc = "             The domain already existed and cannot be created again."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    pub fn dds_create_domain(
        domain: dds_domainid_t,
        config: *const ::std::os::raw::c_char,
    ) -> dds_entity_t;
}
extern "C" {
    #[doc = " @brief Get entity parent."]
    #[doc = " @ingroup entity"]
    #[doc = ""]
    #[doc = " This operation returns the parent to which the given entity belongs."]
    #[doc = " For instance, it will return the Participant that was used when"]
    #[doc = " creating a Publisher (when that Publisher was provided here)."]
    #[doc = ""]
    #[doc = " When a reader or a writer are created with a participant, then a"]
    #[doc = " subscriber or publisher are created implicitly."]
    #[doc = " This function will return the implicit parent and not the used"]
    #[doc = " participant."]
    #[doc = ""]
    #[doc = " @param[in]  entity  Entity from which to get its parent."]
    #[doc = ""]
    #[doc = " @returns A valid entity handle or an error code."]
    #[doc = ""]
    #[doc = " @retval >0"]
    #[doc = "             A valid entity handle."]
    #[doc = " @retval DDS_ENTITY_NIL"]
    #[doc = "             Called with a participant."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    #[doc = " DOC_TODO: Link to generic dds entity relations documentation."]
    pub fn dds_get_parent(entity: dds_entity_t) -> dds_entity_t;
}
extern "C" {
    #[doc = " @brief Get entity participant."]
    #[doc = " @ingroup entity"]
    #[doc = ""]
    #[doc = " This operation returns the participant to which the given entity belongs."]
    #[doc = " For instance, it will return the Participant that was used when"]
    #[doc = " creating a Publisher that was used to create a DataWriter (when that"]
    #[doc = " DataWriter was provided here)."]
    #[doc = ""]
    #[doc = " DOC_TODO: Link to generic dds entity relations documentation."]
    #[doc = ""]
    #[doc = " @param[in]  entity  Entity from which to get its participant."]
    #[doc = ""]
    #[doc = " @returns A valid entity or an error code."]
    #[doc = ""]
    #[doc = " @retval >0"]
    #[doc = "             A valid participant handle."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_get_participant(entity: dds_entity_t) -> dds_entity_t;
}
extern "C" {
    #[doc = " @brief Get entity children."]
    #[doc = " @ingroup entity"]
    #[doc = ""]
    #[doc = " This operation returns the children that the entity contains."]
    #[doc = " For instance, it will return all the Topics, Publishers and Subscribers"]
    #[doc = " of the Participant that was used to create those entities (when that"]
    #[doc = " Participant is provided here)."]
    #[doc = ""]
    #[doc = " This functions takes a pre-allocated list to put the children in and"]
    #[doc = " will return the number of found children. It is possible that the given"]
    #[doc = " size of the list is not the same as the number of found children. If"]
    #[doc = " less children are found, then the last few entries in the list are"]
    #[doc = " untouched. When more children are found, then only 'size' number of"]
    #[doc = " entries are inserted into the list, but still complete count of the"]
    #[doc = " found children is returned. Which children are returned in the latter"]
    #[doc = " case is undefined."]
    #[doc = ""]
    #[doc = " When supplying NULL as list and 0 as size, you can use this to acquire"]
    #[doc = " the number of children without having to pre-allocate a list."]
    #[doc = ""]
    #[doc = " When a reader or a writer are created with a participant, then a"]
    #[doc = " subscriber or publisher are created implicitly."]
    #[doc = " When used on the participant, this function will return the implicit"]
    #[doc = " subscriber and/or publisher and not the related reader/writer."]
    #[doc = ""]
    #[doc = " @param[in]  entity   Entity from which to get its children."]
    #[doc = " @param[out] children Pre-allocated array to contain the found children."]
    #[doc = " @param[in]  size     Size of the pre-allocated children's list."]
    #[doc = ""]
    #[doc = " @returns Number of children or an error code."]
    #[doc = ""]
    #[doc = " @retval >=0"]
    #[doc = "             Number of found children (can be larger than 'size')."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The children parameter is NULL, while a size is provided."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_get_children(
        entity: dds_entity_t,
        children: *mut dds_entity_t,
        size: size_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Get the domain id to which this entity is attached."]
    #[doc = " @ingroup entity"]
    #[doc = ""]
    #[doc = " When creating a participant entity, it is attached to a certain domain."]
    #[doc = " All the children (like Publishers) and childrens' children (like"]
    #[doc = " DataReaders), etc are also attached to that domain."]
    #[doc = ""]
    #[doc = " This function will return the original domain ID when called on"]
    #[doc = " any of the entities within that hierarchy.  For entities not associated"]
    #[doc = " with a domain, the id is set to DDS_DOMAIN_DEFAULT."]
    #[doc = ""]
    #[doc = " @param[in]  entity   Entity from which to get its children."]
    #[doc = " @param[out] id       Pointer to put the domain ID in."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             Domain ID was returned."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The id parameter is NULL."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_get_domainid(entity: dds_entity_t, id: *mut dds_domainid_t) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Get participants of a domain."]
    #[doc = " @ingroup domain"]
    #[doc = ""]
    #[doc = " This operation acquires the participants created on a domain and returns"]
    #[doc = " the number of found participants."]
    #[doc = ""]
    #[doc = " This function takes a domain id with the size of pre-allocated participant's"]
    #[doc = " list in and will return the number of found participants. It is possible that"]
    #[doc = " the given size of the list is not the same as the number of found participants."]
    #[doc = " If less participants are found, then the last few entries in an array stay"]
    #[doc = " untouched. If more participants are found and the array is too small, then the"]
    #[doc = " participants returned are undefined."]
    #[doc = ""]
    #[doc = " @param[in]  domain_id    The domain id."]
    #[doc = " @param[out] participants The participant for domain."]
    #[doc = " @param[in]  size         Size of the pre-allocated participant's list."]
    #[doc = ""]
    #[doc = " @returns Number of participants found or and error code."]
    #[doc = ""]
    #[doc = " @retval >0"]
    #[doc = "             Number of participants found."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The participant parameter is NULL, while a size is provided."]
    pub fn dds_lookup_participant(
        domain_id: dds_domainid_t,
        participants: *mut dds_entity_t,
        size: size_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Creates a new topic with default type handling."]
    #[doc = " @ingroup topic"]
    #[doc = ""]
    #[doc = " The type name for the topic is taken from the generated descriptor. Topic"]
    #[doc = " matching is done on a combination of topic name and type name. Each successful"]
    #[doc = " call to dds_create_topic creates a new topic entity sharing the same QoS"]
    #[doc = " settings with all other topics of the same name."]
    #[doc = ""]
    #[doc = " @param[in]  participant  Participant on which to create the topic."]
    #[doc = " @param[in]  descriptor   An IDL generated topic descriptor."]
    #[doc = " @param[in]  name         Name of the topic."]
    #[doc = " @param[in]  qos          QoS to set on the new topic (can be NULL)."]
    #[doc = " @param[in]  listener     Any listener functions associated with the new topic (can be NULL)."]
    #[doc = ""]
    #[doc = " @returns A valid, unique topic handle or an error code."]
    #[doc = ""]
    #[doc = " @retval >=0"]
    #[doc = "             A valid unique topic handle."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             Either participant, descriptor, name or qos is invalid."]
    #[doc = " @retval DDS_RETCODE_INCONSISTENT_POLICY"]
    #[doc = "             QoS mismatch between qos and an existing topic's QoS."]
    #[doc = " @retval DDS_RETCODE_PRECONDITION_NOT_MET"]
    #[doc = "             Mismatch between type name in descriptor and pre-existing"]
    #[doc = "             topic's type name."]
    pub fn dds_create_topic(
        participant: dds_entity_t,
        descriptor: *const dds_topic_descriptor_t,
        name: *const ::std::os::raw::c_char,
        qos: *const dds_qos_t,
        listener: *const dds_listener_t,
    ) -> dds_entity_t;
}
extern "C" {
    #[doc = " @brief Creates a new topic with provided type handling."]
    #[doc = " @ingroup topic"]
    #[doc = ""]
    #[doc = " The name for the type is taken from the provided \"sertype\" object. Type"]
    #[doc = " matching is done on a combination of topic name and type name. Each successful"]
    #[doc = " call to dds_create_topic creates a new topic entity sharing the same QoS"]
    #[doc = " settings with all other topics of the same name."]
    #[doc = ""]
    #[doc = " In case this function returns a valid handle, the ownership of the provided"]
    #[doc = " sertype is handed over to Cyclone. On return, the caller gets in the sertype parameter a"]
    #[doc = " pointer to the sertype that is actually used by the topic. This can be the provided sertype"]
    #[doc = " (if this sertype was not yet known in the domain), or a sertype thas was"]
    #[doc = " already known in the domain."]
    #[doc = ""]
    #[doc = " @param[in]     participant  Participant on which to create the topic."]
    #[doc = " @param[in]     name         Topic name"]
    #[doc = " @param[in,out] sertype      Internal description of the type . On return, the sertype parameter is set to the actual sertype that is used by the topic."]
    #[doc = " @param[in]     qos          QoS to set on the new topic (can be NULL)."]
    #[doc = " @param[in]     listener     Any listener functions associated with the new topic (can be NULL)."]
    #[doc = " @param[in]     sedp_plist   Topic description to be published as part of discovery (if NULL, not published)."]
    #[doc = ""]
    #[doc = " @returns A valid, unique topic handle or an error code. Iff a valid handle, the domain takes ownership of provided serdata."]
    #[doc = ""]
    #[doc = " @retval >=0"]
    #[doc = "             A valid unique topic handle."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             Either participant, descriptor, name or qos is invalid."]
    #[doc = " @retval DDS_RETCODE_INCONSISTENT_POLICY"]
    #[doc = "             QoS mismatch between qos and an existing topic's QoS."]
    #[doc = " @retval DDS_RETCODE_PRECONDITION_NOT_MET"]
    #[doc = "             Mismatch between type name in sertype and pre-existing"]
    #[doc = "             topic's type name."]
    pub fn dds_create_topic_sertype(
        participant: dds_entity_t,
        name: *const ::std::os::raw::c_char,
        sertype: *mut *mut ddsi_sertype,
        qos: *const dds_qos_t,
        listener: *const dds_listener_t,
        sedp_plist: *const ddsi_plist,
    ) -> dds_entity_t;
}
extern "C" {
    #[doc = " @deprecated Creates a new topic with provided type handling."]
    #[doc = " @ingroup deprecated"]
    #[doc = " Use @ref dds_create_topic_sertype instead."]
    #[doc = ""]
    #[doc = " @param[in]     participant  Participant on which to create the topic."]
    #[doc = " @param[in,out] sertopic     Legacy internal description of the type. On return, the sertype parameter is set to the actual sertype that is used by the topic."]
    #[doc = " @param[in]     qos          QoS to set on the new topic (can be NULL)."]
    #[doc = " @param[in]     listener     Any listener functions associated with the new topic (can be NULL)."]
    #[doc = " @param[in]     sedp_plist   Topic description to be published as part of discovery (if NULL, not published)."]
    #[doc = ""]
    #[doc = " @returns       A valid, unique topic handle or an error code."]
    pub fn dds_create_topic_arbitrary(
        participant: dds_entity_t,
        sertopic: *mut ddsi_sertopic,
        qos: *const dds_qos_t,
        listener: *const dds_listener_t,
        sedp_plist: *const ddsi_plist,
    ) -> dds_entity_t;
}
extern "C" {
    #[doc = " @brief Finds a locally created or discovered remote topic by topic name and type information"]
    #[doc = " @ingroup topic"]
    #[doc = ""]
    #[doc = " Finds a locally created topic or a discovered remote topic based on the topic"]
    #[doc = " name and type. In case the topic is not found, this function will wait for"]
    #[doc = " the topic to become available until the provided time out."]
    #[doc = ""]
    #[doc = " When using the scope DDS_FIND_SCOPE_LOCAL_DOMAIN, there will be no requests sent"]
    #[doc = " over the network for resolving the type in case it is unresolved. This also applies"]
    #[doc = " to dependent types: in case a dependency of the provided type is unresolved, no"]
    #[doc = " requests will be sent for resolving the type when using LOCAL_DOMAIN scope."]
    #[doc = ""]
    #[doc = " In case the scope is DDS_FIND_SCOPE_GLOBAL, for unresolved types (or dependencies)"]
    #[doc = " a type lookup request will be sent."]
    #[doc = ""]
    #[doc = " In case no type information is provided and multiple (discovered) topics exist"]
    #[doc = " with the provided name, an arbitrary topic with that name will be returned."]
    #[doc = " In this scenario, it would be better to read DCPSTopic data and use that to"]
    #[doc = " get the required topic meta-data."]
    #[doc = ""]
    #[doc = " The returned topic should be released with dds_delete."]
    #[doc = ""]
    #[doc = " @param[in]  scope        The scope used to find the topic. In case topic discovery is not enabled in the build, SCOPE_GLOBAL cannot be used."]
    #[doc = " @param[in]  participant  The handle of the participant the found topic will be created in"]
    #[doc = " @param[in]  name         The name of the topic to find."]
    #[doc = " @param[in]  type_info    The type information of the topic to find. Optional, and should not be provided in case topic discovery is not enabled in the build."]
    #[doc = " @param[in]  timeout      The timeout for waiting for the topic to become available"]
    #[doc = ""]
    #[doc = " @returns A valid topic handle or an error code."]
    #[doc = ""]
    #[doc = " @retval >0"]
    #[doc = "             A valid topic handle."]
    #[doc = " @retval 0"]
    #[doc = "             No topic of this name exists"]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             Participant or type information was invalid."]
    #[doc = " @retval DDS_RETCODE_PRECONDITION_NOT_MET"]
    #[doc = "             The provided type could not be found."]
    pub fn dds_find_topic(
        scope: dds_find_scope_t,
        participant: dds_entity_t,
        name: *const ::std::os::raw::c_char,
        type_info: *const dds_typeinfo_t,
        timeout: dds_duration_t,
    ) -> dds_entity_t;
}
extern "C" {
    #[doc = " @brief Returns the name of a given topic."]
    #[doc = " @ingroup topic"]
    #[doc = ""]
    #[doc = " @param[in]  topic  The topic."]
    #[doc = " @param[out] name   Buffer to write the topic name to."]
    #[doc = " @param[in]  size   Number of bytes available in the buffer."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @return Actual length of topic name (name is truncated if return value >= size) or error"]
    pub fn dds_get_name(
        topic: dds_entity_t,
        name: *mut ::std::os::raw::c_char,
        size: size_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Returns the type name of a given topic."]
    #[doc = " @ingroup topic"]
    #[doc = ""]
    #[doc = " @param[in]  topic  The topic."]
    #[doc = " @param[out] name   Buffer to write the topic type name to."]
    #[doc = " @param[in]  size   Number of bytes available in the buffer."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @return Actual length of type name (name is truncated if return value >= size) or error"]
    pub fn dds_get_type_name(
        topic: dds_entity_t,
        name: *mut ::std::os::raw::c_char,
        size: size_t,
    ) -> dds_return_t;
}
#[doc = " @anchor dds_topic_filter_sample_fn"]
#[doc = " @brief Topic filter function that only needs to look at the sample."]
#[doc = " @ingroup topic_filter"]
#[doc = " @warning Unstable API"]
pub type dds_topic_filter_sample_fn =
    ::std::option::Option<unsafe extern "C" fn(sample: *const ::std::os::raw::c_void) -> bool>;
#[doc = " @anchor dds_topic_filter_fn"]
#[doc = " @brief See \\ref dds_topic_filter_sample_fn"]
#[doc = " @ingroup topic_filter"]
#[doc = " @warning Unstable API"]
pub type dds_topic_filter_fn = dds_topic_filter_sample_fn;
extern "C" {
    #[doc = " @brief Sets a filter on a topic. To be replaced by proper filtering on readers,"]
    #[doc = " @ingroup topic_filter"]
    #[doc = " @warning Unstable API"]
    #[doc = " @deprecated use @ref dds_set_topic_filter_and_arg or @ref dds_set_topic_filter_extended instead"]
    #[doc = ""]
    #[doc = " Not thread-safe with respect to data being read/written using readers/writers"]
    #[doc = " using this topic.  Be sure to create a topic entity specific to the reader you"]
    #[doc = " want to filter, then set the filter function, and only then create the reader."]
    #[doc = " And don't change it unless you know there are no concurrent writes."]
    #[doc = ""]
    #[doc = " @param[in]  topic   The topic on which the content filter is set."]
    #[doc = " @param[in]  filter  The filter function used to filter topic samples."]
    pub fn dds_set_topic_filter(topic: dds_entity_t, filter: dds_topic_filter_fn);
}
extern "C" {
    #[doc = " @brief Gets the filter for a topic."]
    #[doc = " @ingroup topic_filter"]
    #[doc = " @deprecated Use dds_get_topic_filter_and_arg() or dds_get_topic_filter_extended() instead."]
    #[doc = " @warning Unstable API"]
    #[doc = ""]
    #[doc = " To be replaced by proper filtering on readers."]
    #[doc = ""]
    #[doc = " @param[in]  topic  The topic from which to get the filter."]
    #[doc = ""]
    #[doc = " @returns The topic filter, or 0 when of type other than \"sample\"."]
    pub fn dds_get_topic_filter(topic: dds_entity_t) -> dds_topic_filter_fn;
}
extern "C" {
    #[doc = " @brief Creates a new instance of a DDS subscriber"]
    #[doc = " @ingroup subscriber"]
    #[doc = ""]
    #[doc = " @param[in]  participant The participant on which the subscriber is being created."]
    #[doc = " @param[in]  qos         The QoS to set on the new subscriber (can be NULL)."]
    #[doc = " @param[in]  listener    Any listener functions associated with the new subscriber (can be NULL)."]
    #[doc = ""]
    #[doc = " @returns A valid subscriber handle or an error code."]
    #[doc = ""]
    #[doc = " @retval >0"]
    #[doc = "             A valid subscriber handle."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             One of the parameters is invalid."]
    pub fn dds_create_subscriber(
        participant: dds_entity_t,
        qos: *const dds_qos_t,
        listener: *const dds_listener_t,
    ) -> dds_entity_t;
}
extern "C" {
    #[doc = " @brief Creates a new instance of a DDS publisher"]
    #[doc = " @ingroup publisher"]
    #[doc = ""]
    #[doc = " @param[in]  participant The participant to create a publisher for."]
    #[doc = " @param[in]  qos         The QoS to set on the new publisher (can be NULL)."]
    #[doc = " @param[in]  listener    Any listener functions associated with the new publisher (can be NULL)."]
    #[doc = ""]
    #[doc = " @returns A valid publisher handle or an error code."]
    #[doc = ""]
    #[doc = " @retval >0"]
    #[doc = "            A valid publisher handle."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "            An internal error has occurred."]
    pub fn dds_create_publisher(
        participant: dds_entity_t,
        qos: *const dds_qos_t,
        listener: *const dds_listener_t,
    ) -> dds_entity_t;
}
extern "C" {
    #[doc = " @brief Suspends the publications of the Publisher"]
    #[doc = " @ingroup publisher"]
    #[doc = ""]
    #[doc = " This operation is a hint to the Service so it can optimize its performance by e.g., collecting"]
    #[doc = " modifications to DDS writers and then batching them. The Service is not required to use the hint."]
    #[doc = ""]
    #[doc = " Every invocation of this operation must be matched by a corresponding call to @see dds_resume"]
    #[doc = " indicating that the set of modifications has completed."]
    #[doc = ""]
    #[doc = " @param[in]  publisher The publisher for which all publications will be suspended."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             Publications suspended successfully."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The pub parameter is not a valid publisher."]
    #[doc = " @retval DDS_RETCODE_UNSUPPORTED"]
    #[doc = "             Operation is not supported."]
    pub fn dds_suspend(publisher: dds_entity_t) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Resumes the publications of the Publisher"]
    #[doc = " @ingroup publisher"]
    #[doc = ""]
    #[doc = " This operation is a hint to the Service to indicate that the application has"]
    #[doc = " completed changes initiated by a previous dds_suspend(). The Service is not"]
    #[doc = " required to use the hint."]
    #[doc = ""]
    #[doc = " The call to resume_publications must match a previous call to @see suspend_publications."]
    #[doc = ""]
    #[doc = " @param[in]  publisher The publisher for which all publications will be resumed."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             Publications resumed successfully."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The pub parameter is not a valid publisher."]
    #[doc = " @retval DDS_RETCODE_PRECONDITION_NOT_MET"]
    #[doc = "             No previous matching dds_suspend()."]
    #[doc = " @retval DDS_RETCODE_UNSUPPORTED"]
    #[doc = "             Operation is not supported."]
    pub fn dds_resume(publisher: dds_entity_t) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Waits at most for the duration timeout for acks for data in the publisher or writer."]
    #[doc = " @ingroup publication"]
    #[doc = ""]
    #[doc = " This operation blocks the calling thread until either all data written by the publisher"]
    #[doc = " or writer is acknowledged by all matched reliable reader entities, or else the duration"]
    #[doc = " specified by the timeout parameter elapses, whichever happens first."]
    #[doc = ""]
    #[doc = " @param[in]  publisher_or_writer Publisher or writer whose acknowledgments must be waited for"]
    #[doc = " @param[in]  timeout             How long to wait for acknowledgments before time out"]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             All acknowledgments successfully received with the timeout."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The publisher_or_writer is not a valid publisher or writer."]
    #[doc = " @retval DDS_RETCODE_TIMEOUT"]
    #[doc = "             Timeout expired before all acknowledgments from reliable reader entities were received."]
    #[doc = " @retval DDS_RETCODE_UNSUPPORTED"]
    #[doc = "             Operation is not supported."]
    pub fn dds_wait_for_acks(
        publisher_or_writer: dds_entity_t,
        timeout: dds_duration_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Creates a new instance of a DDS reader."]
    #[doc = " @ingroup reader"]
    #[doc = ""]
    #[doc = " When a participant is used to create a reader, an implicit subscriber is created."]
    #[doc = " This implicit subscriber will be deleted automatically when the created reader"]
    #[doc = " is deleted."]
    #[doc = ""]
    #[doc = " @param[in]  participant_or_subscriber The participant or subscriber on which the reader is being created."]
    #[doc = " @param[in]  topic                     The topic to read."]
    #[doc = " @param[in]  qos                       The QoS to set on the new reader (can be NULL)."]
    #[doc = " @param[in]  listener                  Any listener functions associated with the new reader (can be NULL)."]
    #[doc = ""]
    #[doc = " @returns A valid reader handle or an error code."]
    #[doc = ""]
    #[doc = " @retval >0"]
    #[doc = "            A valid reader handle."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "            An internal error occurred."]
    #[doc = ""]
    #[doc = " DOC_TODO: Complete list of error codes"]
    pub fn dds_create_reader(
        participant_or_subscriber: dds_entity_t,
        topic: dds_entity_t,
        qos: *const dds_qos_t,
        listener: *const dds_listener_t,
    ) -> dds_entity_t;
}
extern "C" {
    #[doc = " @brief Creates a new instance of a DDS reader with a custom history cache."]
    #[doc = " @ingroup reader"]
    #[doc = ""]
    #[doc = " When a participant is used to create a reader, an implicit subscriber is created."]
    #[doc = " This implicit subscriber will be deleted automatically when the created reader"]
    #[doc = " is deleted."]
    #[doc = ""]
    #[doc = " @param[in]  participant_or_subscriber The participant or subscriber on which the reader is being created."]
    #[doc = " @param[in]  topic                     The topic to read."]
    #[doc = " @param[in]  qos                       The QoS to set on the new reader (can be NULL)."]
    #[doc = " @param[in]  listener                  Any listener functions associated with the new reader (can be NULL)."]
    #[doc = " @param[in]  rhc                       Reader history cache to use, reader becomes the owner"]
    #[doc = ""]
    #[doc = " @returns A valid reader handle or an error code."]
    #[doc = ""]
    #[doc = " @retval >0"]
    #[doc = "            A valid reader handle."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "            An internal error occurred."]
    #[doc = ""]
    #[doc = " DOC_TODO: Complete list of error codes"]
    pub fn dds_create_reader_rhc(
        participant_or_subscriber: dds_entity_t,
        topic: dds_entity_t,
        qos: *const dds_qos_t,
        listener: *const dds_listener_t,
        rhc: *mut dds_rhc,
    ) -> dds_entity_t;
}
extern "C" {
    #[doc = " @brief Wait until reader receives all historic data"]
    #[doc = " @ingroup reader"]
    #[doc = ""]
    #[doc = " The operation blocks the calling thread until either all \"historical\" data is"]
    #[doc = " received, or else the duration specified by the max_wait parameter elapses, whichever happens"]
    #[doc = " first. A return value of 0 indicates that all the \"historical\" data was received; a return"]
    #[doc = " value of TIMEOUT indicates that max_wait elapsed before all the data was received."]
    #[doc = ""]
    #[doc = " @param[in]  reader    The reader on which to wait for historical data."]
    #[doc = " @param[in]  max_wait  How long to wait for historical data before time out."]
    #[doc = ""]
    #[doc = " @returns a status, 0 on success, TIMEOUT on timeout or a negative value to indicate error."]
    #[doc = ""]
    #[doc = " DOC_TODO: Complete list of error codes"]
    pub fn dds_reader_wait_for_historical_data(
        reader: dds_entity_t,
        max_wait: dds_duration_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Creates a new instance of a DDS writer."]
    #[doc = " @ingroup writer"]
    #[doc = ""]
    #[doc = " When a participant is used to create a writer, an implicit publisher is created."]
    #[doc = " This implicit publisher will be deleted automatically when the created writer"]
    #[doc = " is deleted."]
    #[doc = ""]
    #[doc = " @param[in]  participant_or_publisher The participant or publisher on which the writer is being created."]
    #[doc = " @param[in]  topic The topic to write."]
    #[doc = " @param[in]  qos The QoS to set on the new writer (can be NULL)."]
    #[doc = " @param[in]  listener Any listener functions associated with the new writer (can be NULL)."]
    #[doc = ""]
    #[doc = " @returns A valid writer handle or an error code."]
    #[doc = ""]
    #[doc = " @returns >0"]
    #[doc = "              A valid writer handle."]
    #[doc = " @returns DDS_RETCODE_ERROR"]
    #[doc = "              An internal error occurred."]
    #[doc = ""]
    #[doc = " DOC_TODO: Complete list of error codes"]
    pub fn dds_create_writer(
        participant_or_publisher: dds_entity_t,
        topic: dds_entity_t,
        qos: *const dds_qos_t,
        listener: *const dds_listener_t,
    ) -> dds_entity_t;
}
extern "C" {
    #[doc = " @brief Registers an instance"]
    #[doc = " @ingroup writing"]
    #[doc = ""]
    #[doc = " This operation registers an instance with a key value to the data writer and"]
    #[doc = " returns an instance handle that could be used for successive write & dispose"]
    #[doc = " operations. When the handle is not allocated, the function will return an"]
    #[doc = " error and the handle will be un-touched."]
    #[doc = ""]
    #[doc = " @param[in]  writer  The writer to which instance has be associated."]
    #[doc = " @param[out] handle  The instance handle."]
    #[doc = " @param[in]  data    The instance with the key value."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "            The operation was successful."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "            One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "            The operation is invoked on an inappropriate object."]
    pub fn dds_register_instance(
        writer: dds_entity_t,
        handle: *mut dds_instance_handle_t,
        data: *const ::std::os::raw::c_void,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Unregisters an instance by instance"]
    #[doc = " @ingroup writing"]
    #[doc = ""]
    #[doc = " This operation reverses the action of register instance, removes all information regarding"]
    #[doc = " the instance and unregisters an instance with a key value from the data writer."]
    #[doc = ""]
    #[doc = " @param[in]  writer  The writer to which instance is associated."]
    #[doc = " @param[in]  data    The instance with the key value."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The operation was successful."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    pub fn dds_unregister_instance(
        writer: dds_entity_t,
        data: *const ::std::os::raw::c_void,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Unregisters an instance by instance handle"]
    #[doc = " @ingroup writing"]
    #[doc = ""]
    #[doc = " This operation unregisters the instance which is identified by the key fields of the given"]
    #[doc = " typed instance handle."]
    #[doc = ""]
    #[doc = " @param[in]  writer  The writer to which instance is associated."]
    #[doc = " @param[in]  handle  The instance handle."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The operation was successful."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    pub fn dds_unregister_instance_ih(
        writer: dds_entity_t,
        handle: dds_instance_handle_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Unregisters an instance by instance with timestamp"]
    #[doc = " @ingroup writing"]
    #[doc = ""]
    #[doc = " This operation reverses the action of register instance, removes all information regarding"]
    #[doc = " the instance and unregisters an instance with a key value from the data writer. It also"]
    #[doc = " provides a value for the timestamp explicitly."]
    #[doc = ""]
    #[doc = " @param[in]  writer    The writer to which instance is associated."]
    #[doc = " @param[in]  data      The instance with the key value."]
    #[doc = " @param[in]  timestamp The timestamp used at registration."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The operation was successful."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    pub fn dds_unregister_instance_ts(
        writer: dds_entity_t,
        data: *const ::std::os::raw::c_void,
        timestamp: dds_time_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Unregisters an instance by instance handle with timestamp"]
    #[doc = " @ingroup writing"]
    #[doc = ""]
    #[doc = " This operation unregisters an instance with a key value from the handle. Instance can be identified"]
    #[doc = " from instance handle. If an unregistered key ID is passed as an instance data, an error is logged and"]
    #[doc = " not flagged as return value."]
    #[doc = ""]
    #[doc = " @param[in]  writer    The writer to which instance is associated."]
    #[doc = " @param[in]  handle    The instance handle."]
    #[doc = " @param[in]  timestamp The timestamp used at registration."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The operation was successful"]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             One of the given arguments is not valid"]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object"]
    pub fn dds_unregister_instance_ih_ts(
        writer: dds_entity_t,
        handle: dds_instance_handle_t,
        timestamp: dds_time_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief This operation modifies and disposes a data instance."]
    #[doc = " @ingroup writing"]
    #[doc = ""]
    #[doc = " This operation requests the Data Distribution Service to modify the instance and"]
    #[doc = " mark it for deletion. Copies of the instance and its corresponding samples, which are"]
    #[doc = " stored in every connected reader and, dependent on the QoS policy settings (also in"]
    #[doc = " the Transient and Persistent stores) will be modified and marked for deletion by"]
    #[doc = " setting their dds_instance_state_t to DDS_IST_NOT_ALIVE_DISPOSED."]
    #[doc = ""]
    #[doc = " @par Blocking"]
    #[doc = " If the history QoS policy is set to DDS_HISTORY_KEEP_ALL, the"]
    #[doc = " dds_writedispose operation on the writer may block if the modification"]
    #[doc = " would cause data to be lost because one of the limits, specified in the"]
    #[doc = " resource_limits QoS policy, to be exceeded. In case the synchronous"]
    #[doc = " attribute value of the reliability Qos policy is set to true for"]
    #[doc = " communicating writers and readers then the writer will wait until"]
    #[doc = " all synchronous readers have acknowledged the data. Under these"]
    #[doc = " circumstances, the max_blocking_time attribute of the reliability"]
    #[doc = " QoS policy configures the maximum time the dds_writedispose operation"]
    #[doc = " may block."]
    #[doc = " If max_blocking_time elapses before the writer is able to store the"]
    #[doc = " modification without exceeding the limits and all expected acknowledgements"]
    #[doc = " are received, the dds_writedispose operation will fail and returns"]
    #[doc = " DDS_RETCODE_TIMEOUT."]
    #[doc = ""]
    #[doc = " @param[in]  writer The writer to dispose the data instance from."]
    #[doc = " @param[in]  data   The data to be written and disposed."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The sample is written and the instance is marked for deletion."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             At least one of the arguments is invalid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    #[doc = " @retval DDS_RETCODE_TIMEOUT"]
    #[doc = "             Either the current action overflowed the available resources as"]
    #[doc = "             specified by the combination of the reliability QoS policy,"]
    #[doc = "             history QoS policy and resource_limits QoS policy, or the"]
    #[doc = "             current action was waiting for data delivery acknowledgement"]
    #[doc = "             by synchronous readers. This caused blocking of this operation,"]
    #[doc = "             which could not be resolved before max_blocking_time of the"]
    #[doc = "             reliability QoS policy elapsed."]
    pub fn dds_writedispose(
        writer: dds_entity_t,
        data: *const ::std::os::raw::c_void,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief This operation modifies and disposes a data instance with a specific"]
    #[doc = "        timestamp."]
    #[doc = " @ingroup writing"]
    #[doc = ""]
    #[doc = " This operation performs the same functions as dds_writedispose() except that"]
    #[doc = " the application provides the value for the source_timestamp that is made"]
    #[doc = " available to connected reader objects. This timestamp is important for the"]
    #[doc = " interpretation of the destination_order QoS policy."]
    #[doc = ""]
    #[doc = " @param[in]  writer    The writer to dispose the data instance from."]
    #[doc = " @param[in]  data      The data to be written and disposed."]
    #[doc = " @param[in]  timestamp The timestamp used as source timestamp."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The sample is written and the instance is marked for deletion."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             At least one of the arguments is invalid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    #[doc = " @retval DDS_RETCODE_TIMEOUT"]
    #[doc = "             Either the current action overflowed the available resources as"]
    #[doc = "             specified by the combination of the reliability QoS policy,"]
    #[doc = "             history QoS policy and resource_limits QoS policy, or the"]
    #[doc = "             current action was waiting for data delivery acknowledgement"]
    #[doc = "             by synchronous readers. This caused blocking of this operation,"]
    #[doc = "             which could not be resolved before max_blocking_time of the"]
    #[doc = "             reliability QoS policy elapsed."]
    pub fn dds_writedispose_ts(
        writer: dds_entity_t,
        data: *const ::std::os::raw::c_void,
        timestamp: dds_time_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief This operation disposes an instance, identified by the data sample."]
    #[doc = " @ingroup writing"]
    #[doc = ""]
    #[doc = " This operation requests the Data Distribution Service to modify the instance and"]
    #[doc = " mark it for deletion. Copies of the instance and its corresponding samples, which are"]
    #[doc = " stored in every connected reader and, dependent on the QoS policy settings (also in"]
    #[doc = " the Transient and Persistent stores) will be modified and marked for deletion by"]
    #[doc = " setting their dds_instance_state_t to DDS_IST_NOT_ALIVE_DISPOSED."]
    #[doc = ""]
    #[doc = " @par Blocking"]
    #[doc = " If the history QoS policy is set to DDS_HISTORY_KEEP_ALL, the"]
    #[doc = " dds_writedispose operation on the writer may block if the modification"]
    #[doc = " would cause data to be lost because one of the limits, specified in the"]
    #[doc = " resource_limits QoS policy, to be exceeded. In case the synchronous"]
    #[doc = " attribute value of the reliability Qos policy is set to true for"]
    #[doc = " communicating writers and readers then the writer will wait until"]
    #[doc = " all synchronous readers have acknowledged the data. Under these"]
    #[doc = " circumstances, the max_blocking_time attribute of the reliability"]
    #[doc = " QoS policy configures the maximum time the dds_writedispose operation"]
    #[doc = " may block."]
    #[doc = " If max_blocking_time elapses before the writer is able to store the"]
    #[doc = " modification without exceeding the limits and all expected acknowledgements"]
    #[doc = " are received, the dds_writedispose operation will fail and returns"]
    #[doc = " DDS_RETCODE_TIMEOUT."]
    #[doc = ""]
    #[doc = " @param[in]  writer The writer to dispose the data instance from."]
    #[doc = " @param[in]  data   The data sample that identifies the instance"]
    #[doc = "                    to be disposed."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The sample is written and the instance is marked for deletion."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             At least one of the arguments is invalid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    #[doc = " @retval DDS_RETCODE_TIMEOUT"]
    #[doc = "             Either the current action overflowed the available resources as"]
    #[doc = "             specified by the combination of the reliability QoS policy,"]
    #[doc = "             history QoS policy and resource_limits QoS policy, or the"]
    #[doc = "             current action was waiting for data delivery acknowledgement"]
    #[doc = "             by synchronous readers. This caused blocking of this operation,"]
    #[doc = "             which could not be resolved before max_blocking_time of the"]
    #[doc = "             reliability QoS policy elapsed."]
    pub fn dds_dispose(writer: dds_entity_t, data: *const ::std::os::raw::c_void) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief This operation disposes an instance with a specific timestamp, identified by the data sample."]
    #[doc = " @ingroup writing"]
    #[doc = ""]
    #[doc = " This operation performs the same functions as dds_dispose() except that"]
    #[doc = " the application provides the value for the source_timestamp that is made"]
    #[doc = " available to connected reader objects. This timestamp is important for the"]
    #[doc = " interpretation of the destination_order QoS policy."]
    #[doc = ""]
    #[doc = " @param[in]  writer    The writer to dispose the data instance from."]
    #[doc = " @param[in]  data      The data sample that identifies the instance"]
    #[doc = "                       to be disposed."]
    #[doc = " @param[in]  timestamp The timestamp used as source timestamp."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The sample is written and the instance is marked for deletion"]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred"]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             At least one of the arguments is invalid"]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object"]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted"]
    #[doc = " @retval DDS_RETCODE_TIMEOUT"]
    #[doc = "             Either the current action overflowed the available resources as"]
    #[doc = "             specified by the combination of the reliability QoS policy,"]
    #[doc = "             history QoS policy and resource_limits QoS policy, or the"]
    #[doc = "             current action was waiting for data delivery acknowledgment"]
    #[doc = "             by synchronous readers. This caused blocking of this operation,"]
    #[doc = "             which could not be resolved before max_blocking_time of the"]
    #[doc = "             reliability QoS policy elapsed."]
    pub fn dds_dispose_ts(
        writer: dds_entity_t,
        data: *const ::std::os::raw::c_void,
        timestamp: dds_time_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief This operation disposes an instance, identified by the instance handle."]
    #[doc = " @ingroup writing"]
    #[doc = ""]
    #[doc = " This operation requests the Data Distribution Service to modify the instance and"]
    #[doc = " mark it for deletion. Copies of the instance and its corresponding samples, which are"]
    #[doc = " stored in every connected reader and, dependent on the QoS policy settings (also in"]
    #[doc = " the Transient and Persistent stores) will be modified and marked for deletion by"]
    #[doc = " setting their dds_instance_state_t to DDS_IST_NOT_ALIVE_DISPOSED."]
    #[doc = ""]
    #[doc = " @par Instance Handle"]
    #[doc = " The given instance handle must correspond to the value that was returned by either"]
    #[doc = " the dds_register_instance operation, dds_register_instance_ts or dds_lookup_instance."]
    #[doc = " If there is no correspondence, then the result of the operation is unspecified."]
    #[doc = ""]
    #[doc = " @param[in]  writer The writer to dispose the data instance from."]
    #[doc = " @param[in]  handle The handle to identify an instance."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The sample is written and the instance is marked for deletion."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             At least one of the arguments is invalid"]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object"]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted"]
    #[doc = " @retval DDS_RETCODE_PRECONDITION_NOT_MET"]
    #[doc = "             The instance handle has not been registered with this writer"]
    pub fn dds_dispose_ih(writer: dds_entity_t, handle: dds_instance_handle_t) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief This operation disposes an instance with a specific timestamp, identified by the instance handle."]
    #[doc = " @ingroup writing"]
    #[doc = ""]
    #[doc = " This operation performs the same functions as dds_dispose_ih() except that"]
    #[doc = " the application provides the value for the source_timestamp that is made"]
    #[doc = " available to connected reader objects. This timestamp is important for the"]
    #[doc = " interpretation of the destination_order QoS policy."]
    #[doc = ""]
    #[doc = " @param[in]  writer    The writer to dispose the data instance from."]
    #[doc = " @param[in]  handle    The handle to identify an instance."]
    #[doc = " @param[in]  timestamp The timestamp used as source timestamp."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The sample is written and the instance is marked for deletion."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             At least one of the arguments is invalid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    #[doc = " @retval DDS_RETCODE_PRECONDITION_NOT_MET"]
    #[doc = "             The instance handle has not been registered with this writer."]
    pub fn dds_dispose_ih_ts(
        writer: dds_entity_t,
        handle: dds_instance_handle_t,
        timestamp: dds_time_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Write the value of a data instance"]
    #[doc = " @ingroup writing"]
    #[doc = ""]
    #[doc = " With this API, the value of the source timestamp is automatically made"]
    #[doc = " available to the data reader by the service."]
    #[doc = ""]
    #[doc = " @param[in]  writer The writer entity."]
    #[doc = " @param[in]  data Value to be written."]
    #[doc = ""]
    #[doc = " @returns dds_return_t indicating success or failure."]
    pub fn dds_write(writer: dds_entity_t, data: *const ::std::os::raw::c_void) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Flush a writers batched writes"]
    #[doc = " @ingroup writing"]
    #[doc = ""]
    #[doc = " When using the WriteBatch mode you can manually batch small writes into larger"]
    #[doc = " datapackets for network efficiency. The normal dds_write() calls will no longer"]
    #[doc = " automatically decide when to send data, you will do that manually using this function."]
    #[doc = ""]
    #[doc = " DOC_TODO check if my assumptions about how this function works are correct"]
    #[doc = ""]
    #[doc = " @param[in]  writer The writer entity."]
    pub fn dds_write_flush(writer: dds_entity_t);
}
extern "C" {
    #[doc = " @brief Write a serialized value of a data instance"]
    #[doc = " @ingroup writing"]
    #[doc = ""]
    #[doc = " This call causes the writer to write the serialized value that is provided"]
    #[doc = " in the serdata argument.  Timestamp and statusinfo fields are set to the"]
    #[doc = " current time and 0 (indicating a regular write), respectively."]
    #[doc = ""]
    #[doc = " @param[in]  writer The writer entity."]
    #[doc = " @param[in]  serdata Serialized value to be written."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The writer successfully wrote the serialized value."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    #[doc = " @retval DDS_RETCODE_TIMEOUT"]
    #[doc = "             The writer failed to write the serialized value reliably within the specified max_blocking_time."]
    pub fn dds_writecdr(writer: dds_entity_t, serdata: *mut ddsi_serdata) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Write the value of a data instance along with the source timestamp passed."]
    #[doc = " @ingroup writing"]
    #[doc = ""]
    #[doc = " @param[in]  writer The writer entity."]
    #[doc = " @param[in]  data Value to be written."]
    #[doc = " @param[in]  timestamp Source timestamp."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    pub fn dds_write_ts(
        writer: dds_entity_t,
        data: *const ::std::os::raw::c_void,
        timestamp: dds_time_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Creates a readcondition associated to the given reader."]
    #[doc = " @ingroup readcondition"]
    #[doc = ""]
    #[doc = " The readcondition allows specifying which samples are of interest in"]
    #[doc = " a data reader's history, by means of a mask. The mask is or'd with"]
    #[doc = " the flags that are dds_sample_state_t, dds_view_state_t and"]
    #[doc = " dds_instance_state_t."]
    #[doc = ""]
    #[doc = " Based on the mask value set, the readcondition gets triggered when"]
    #[doc = " data is available on the reader."]
    #[doc = ""]
    #[doc = " Waitsets allow waiting for an event on some of any set of entities."]
    #[doc = " This means that the readcondition can be used to wake up a waitset when"]
    #[doc = " data is in the reader history with states that matches the given mask."]
    #[doc = ""]
    #[doc = " @note The parent reader and every of its associated conditions (whether"]
    #[doc = "       they are readconditions or queryconditions) share the same resources."]
    #[doc = "       This means that one of these entities reads or takes data, the states"]
    #[doc = "       of the data will change for other entities automatically. For instance,"]
    #[doc = "       if one reads a sample, then the sample state will become 'read' for all"]
    #[doc = "       associated reader/conditions. Or if one takes a sample, then it's not"]
    #[doc = "       available to any other associated reader/condition."]
    #[doc = ""]
    #[doc = " @param[in]  reader  Reader to associate the condition to."]
    #[doc = " @param[in]  mask    Interest (dds_sample_state_t|dds_view_state_t|dds_instance_state_t)."]
    #[doc = ""]
    #[doc = " @returns A valid condition handle or an error code."]
    #[doc = ""]
    #[doc = " @retval >0"]
    #[doc = "             A valid condition handle"]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_create_readcondition(reader: dds_entity_t, mask: u32) -> dds_entity_t;
}
#[doc = " @brief Function signature for a querycondition filter"]
#[doc = " @ingroup querycondition"]
pub type dds_querycondition_filter_fn =
    ::std::option::Option<unsafe extern "C" fn(sample: *const ::std::os::raw::c_void) -> bool>;
extern "C" {
    #[doc = " @brief Creates a queryondition associated to the given reader."]
    #[doc = " @ingroup querycondition"]
    #[doc = ""]
    #[doc = " The queryondition allows specifying which samples are of interest in"]
    #[doc = " a data reader's history, by means of a mask and a filter. The mask is"]
    #[doc = " or'd with the flags that are dds_sample_state_t, dds_view_state_t and"]
    #[doc = " dds_instance_state_t."]
    #[doc = ""]
    #[doc = " Based on the mask value set and data that matches the filter, the"]
    #[doc = " querycondition gets triggered when data is available on the reader."]
    #[doc = ""]
    #[doc = " Waitsets allow waiting for an event on some of any set of entities."]
    #[doc = " This means that the querycondition can be used to wake up a waitset when"]
    #[doc = " data is in the reader history with states that matches the given mask"]
    #[doc = " and filter."]
    #[doc = ""]
    #[doc = " @note The parent reader and every of its associated conditions (whether"]
    #[doc = "       they are readconditions or queryconditions) share the same resources."]
    #[doc = "       This means that one of these entities reads or takes data, the states"]
    #[doc = "       of the data will change for other entities automatically. For instance,"]
    #[doc = "       if one reads a sample, then the sample state will become 'read' for all"]
    #[doc = "       associated reader/conditions. Or if one takes a sample, then it's not"]
    #[doc = "       available to any other associated reader/condition."]
    #[doc = ""]
    #[doc = " @param[in]  reader  Reader to associate the condition to."]
    #[doc = " @param[in]  mask    Interest (dds_sample_state_t|dds_view_state_t|dds_instance_state_t)."]
    #[doc = " @param[in]  filter  Callback that the application can use to filter specific samples."]
    #[doc = ""]
    #[doc = " @returns A valid condition handle or an error code"]
    #[doc = ""]
    #[doc = " @retval >=0"]
    #[doc = "             A valid condition handle."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_create_querycondition(
        reader: dds_entity_t,
        mask: u32,
        filter: dds_querycondition_filter_fn,
    ) -> dds_entity_t;
}
extern "C" {
    #[doc = " @brief Creates a guardcondition."]
    #[doc = " @ingroup guardcondition"]
    #[doc = ""]
    #[doc = " Waitsets allow waiting for an event on some of any set of entities."]
    #[doc = " This means that the guardcondition can be used to wake up a waitset when"]
    #[doc = " data is in the reader history with states that matches the given mask."]
    #[doc = ""]
    #[doc = " @param[in]   participant  Participant on which to create the guardcondition."]
    #[doc = ""]
    #[doc = " @returns A valid condition handle or an error code."]
    #[doc = ""]
    #[doc = " @retval >0"]
    #[doc = "             A valid condition handle"]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_create_guardcondition(participant: dds_entity_t) -> dds_entity_t;
}
extern "C" {
    #[doc = " @brief Sets the trigger status of a guardcondition."]
    #[doc = " @ingroup guardcondition"]
    #[doc = ""]
    #[doc = " @param[in]   guardcond  Guard condition to set the trigger status of."]
    #[doc = " @param[in]   triggered  The triggered status to set."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             Operation successful"]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_set_guardcondition(guardcond: dds_entity_t, triggered: bool) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Reads the trigger status of a guardcondition."]
    #[doc = " @ingroup guardcondition"]
    #[doc = ""]
    #[doc = " @param[in]   guardcond  Guard condition to read the trigger status of."]
    #[doc = " @param[out]  triggered  The triggered status read from the guard condition."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             Operation successful"]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_read_guardcondition(guardcond: dds_entity_t, triggered: *mut bool) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Reads and resets the trigger status of a guardcondition."]
    #[doc = " @ingroup guardcondition"]
    #[doc = ""]
    #[doc = " @param[in]   guardcond  Guard condition to read and reset the trigger status of."]
    #[doc = " @param[out]  triggered  The triggered status read from the guard condition."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             Operation successful"]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_take_guardcondition(guardcond: dds_entity_t, triggered: *mut bool) -> dds_return_t;
}
#[doc = " @brief Waitset attachment argument."]
#[doc = " @ingroup waitset"]
#[doc = ""]
#[doc = " Every entity that is attached to the waitset can be accompanied by such"]
#[doc = " an attachment argument. When the waitset wait is unblocked because of an"]
#[doc = " entity that triggered, then the returning array will be populated with"]
#[doc = " these attachment arguments that are related to the triggered entity."]
pub type dds_attach_t = isize;
extern "C" {
    #[doc = " @brief Create a waitset and allocate the resources required"]
    #[doc = " @ingroup waitset"]
    #[doc = ""]
    #[doc = " A WaitSet object allows an application to wait until one or more of the"]
    #[doc = " conditions of the attached entities evaluates to TRUE or until the timeout"]
    #[doc = " expires."]
    #[doc = ""]
    #[doc = " @param[in]  participant  Domain participant which the WaitSet contains."]
    #[doc = ""]
    #[doc = " @returns A valid waitset handle or an error code."]
    #[doc = ""]
    #[doc = " @retval >=0"]
    #[doc = "             A valid waitset handle."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_create_waitset(participant: dds_entity_t) -> dds_entity_t;
}
extern "C" {
    #[doc = " @brief Acquire previously attached entities."]
    #[doc = " @ingroup waitset"]
    #[doc = ""]
    #[doc = " This functions takes a pre-allocated list to put the entities in and"]
    #[doc = " will return the number of found entities. It is possible that the given"]
    #[doc = " size of the list is not the same as the number of found entities. If"]
    #[doc = " less entities are found, then the last few entries in the list are"]
    #[doc = " untouched. When more entities are found, then only 'size' number of"]
    #[doc = " entries are inserted into the list, but still the complete count of the"]
    #[doc = " found entities is returned. Which entities are returned in the latter"]
    #[doc = " case is undefined."]
    #[doc = ""]
    #[doc = " @param[in]  waitset  Waitset from which to get its attached entities."]
    #[doc = " @param[out] entities Pre-allocated array to contain the found entities."]
    #[doc = " @param[in]  size     Size of the pre-allocated entities' list."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t with the number of children or an error code."]
    #[doc = ""]
    #[doc = " @retval >=0"]
    #[doc = "             Number of children found (can be larger than 'size')."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The entities parameter is NULL, while a size is provided."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The waitset has already been deleted."]
    pub fn dds_waitset_get_entities(
        waitset: dds_entity_t,
        entities: *mut dds_entity_t,
        size: size_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief This operation attaches an Entity to the WaitSet."]
    #[doc = " @ingroup waitset"]
    #[doc = ""]
    #[doc = " This operation attaches an Entity to the WaitSet. The dds_waitset_wait()"]
    #[doc = " will block when none of the attached entities are triggered. 'Triggered'"]
    #[doc = " (dds_triggered()) doesn't mean the same for every entity:"]
    #[doc = "  - Reader/Writer/Publisher/Subscriber/Topic/Participant"]
    #[doc = "      - These are triggered when their status changed."]
    #[doc = "  - WaitSet"]
    #[doc = "      - Triggered when trigger value was set to true by the application."]
    #[doc = "        It stays triggered until application sets the trigger value to"]
    #[doc = "        false (dds_waitset_set_trigger()). This can be used to wake up an"]
    #[doc = "        waitset for different reasons (f.i. termination) than the 'normal'"]
    #[doc = "        status change (like new data)."]
    #[doc = "  - ReadCondition/QueryCondition"]
    #[doc = "      - Triggered when data is available on the related Reader that matches"]
    #[doc = "        the Condition."]
    #[doc = ""]
    #[doc = " Multiple entities can be attached to a single waitset. A particular entity"]
    #[doc = " can be attached to multiple waitsets. However, a particular entity can not"]
    #[doc = " be attached to a particular waitset multiple times."]
    #[doc = ""]
    #[doc = " @param[in]  waitset  The waitset to attach the given entity to."]
    #[doc = " @param[in]  entity   The entity to attach."]
    #[doc = " @param[in]  x        Blob that will be supplied when the waitset wait is"]
    #[doc = "                      triggered by the given entity."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             Entity attached."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The given waitset or entity are not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The waitset has already been deleted."]
    #[doc = " @retval DDS_RETCODE_PRECONDITION_NOT_MET"]
    #[doc = "             The entity was already attached."]
    pub fn dds_waitset_attach(
        waitset: dds_entity_t,
        entity: dds_entity_t,
        x: dds_attach_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief This operation detaches an Entity from the WaitSet."]
    #[doc = " @ingroup waitset"]
    #[doc = ""]
    #[doc = " @param[in]  waitset  The waitset to detach the given entity from."]
    #[doc = " @param[in]  entity   The entity to detach."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             Entity detached."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The given waitset or entity are not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The waitset has already been deleted."]
    #[doc = " @retval DDS_RETCODE_PRECONDITION_NOT_MET"]
    #[doc = "             The entity is not attached."]
    pub fn dds_waitset_detach(waitset: dds_entity_t, entity: dds_entity_t) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Sets the trigger_value associated with a waitset."]
    #[doc = " @ingroup waitset"]
    #[doc = ""]
    #[doc = " When the waitset is attached to itself and the trigger value is"]
    #[doc = " set to 'true', then the waitset will wake up just like with an"]
    #[doc = " other status change of the attached entities."]
    #[doc = ""]
    #[doc = " This can be used to forcefully wake up a waitset, for instance"]
    #[doc = " when the application wants to shut down. So, when the trigger"]
    #[doc = " value is true, the waitset will wake up or not wait at all."]
    #[doc = ""]
    #[doc = " The trigger value will remain true until the application sets it"]
    #[doc = " false again deliberately."]
    #[doc = ""]
    #[doc = " @param[in]  waitset  The waitset to set the trigger value on."]
    #[doc = " @param[in]  trigger  The trigger value to set."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             Trigger value set."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The given waitset is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The waitset has already been deleted."]
    pub fn dds_waitset_set_trigger(waitset: dds_entity_t, trigger: bool) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief This operation allows an application thread to wait for the a status"]
    #[doc = "        change or other trigger on (one of) the entities that are attached to"]
    #[doc = "        the WaitSet."]
    #[doc = " @ingroup waitset"]
    #[doc = ""]
    #[doc = " The dds_waitset_wait() operation blocks until the some of the attached"]
    #[doc = " entities have triggered or \"reltimeout\" has elapsed."]
    #[doc = " 'Triggered' (dds_triggered()) doesn't mean the same for every entity:"]
    #[doc = "  - Reader/Writer/Publisher/Subscriber/Topic/Participant"]
    #[doc = "      - These are triggered when their status changed."]
    #[doc = "  - WaitSet"]
    #[doc = "      - Triggered when trigger value was set to true by the application."]
    #[doc = "        It stays triggered until application sets the trigger value to"]
    #[doc = "        false (dds_waitset_set_trigger()). This can be used to wake up an"]
    #[doc = "        waitset for different reasons (f.i. termination) than the 'normal'"]
    #[doc = "        status change (like new data)."]
    #[doc = "  - ReadCondition/QueryCondition"]
    #[doc = "      - Triggered when data is available on the related Reader that matches"]
    #[doc = "        the Condition."]
    #[doc = ""]
    #[doc = " This functions takes a pre-allocated list to put the \"xs\" blobs in (that"]
    #[doc = " were provided during the attach of the related entities) and will return"]
    #[doc = " the number of triggered entities. It is possible that the given size"]
    #[doc = " of the list is not the same as the number of triggered entities. If less"]
    #[doc = " entities were triggered, then the last few entries in the list are"]
    #[doc = " untouched. When more entities are triggered, then only 'size' number of"]
    #[doc = " entries are inserted into the list, but still the complete count of the"]
    #[doc = " triggered entities is returned. Which \"xs\" blobs are returned in the"]
    #[doc = " latter case is undefined."]
    #[doc = ""]
    #[doc = " In case of a time out, the return value is 0."]
    #[doc = ""]
    #[doc = " Deleting the waitset while the application is blocked results in an"]
    #[doc = " error code (i.e. < 0) returned by \"wait\"."]
    #[doc = ""]
    #[doc = " Multiple threads may block on a single waitset at the same time;"]
    #[doc = " the calls are entirely independent."]
    #[doc = ""]
    #[doc = " An empty waitset never triggers (i.e., dds_waitset_wait on an empty"]
    #[doc = " waitset is essentially equivalent to a sleep)."]
    #[doc = ""]
    #[doc = " The \"dds_waitset_wait_until\" operation is the same as the"]
    #[doc = " \"dds_waitset_wait\" except that it takes an absolute timeout."]
    #[doc = ""]
    #[doc = " @param[in]  waitset    The waitset to set the trigger value on."]
    #[doc = " @param[out] xs         Pre-allocated list to store the 'blobs' that were"]
    #[doc = "                        provided during the attach of the triggered entities."]
    #[doc = " @param[in]  nxs        The size of the pre-allocated blobs list."]
    #[doc = " @param[in]  reltimeout Relative timeout"]
    #[doc = ""]
    #[doc = " @returns A dds_return_t with the number of entities triggered or an error code"]
    #[doc = ""]
    #[doc = " @retval >0"]
    #[doc = "             Number of entities triggered."]
    #[doc = " @retval  0"]
    #[doc = "             Time out (no entities were triggered)."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The given waitset is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The waitset has already been deleted."]
    pub fn dds_waitset_wait(
        waitset: dds_entity_t,
        xs: *mut dds_attach_t,
        nxs: size_t,
        reltimeout: dds_duration_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief This operation allows an application thread to wait for the a status"]
    #[doc = "        change or other trigger on (one of) the entities that are attached to"]
    #[doc = "        the WaitSet."]
    #[doc = " @ingroup waitset"]
    #[doc = ""]
    #[doc = " The dds_waitset_wait() operation blocks until the some of the attached"]
    #[doc = " entities have triggered or \"abstimeout\" has been reached."]
    #[doc = " 'Triggered' (dds_triggered()) doesn't mean the same for every entity:"]
    #[doc = "  - Reader/Writer/Publisher/Subscriber/Topic/Participant"]
    #[doc = "      - These are triggered when their status changed."]
    #[doc = "  - WaitSet"]
    #[doc = "      - Triggered when trigger value was set to true by the application."]
    #[doc = "        It stays triggered until application sets the trigger value to"]
    #[doc = "        false (dds_waitset_set_trigger()). This can be used to wake up an"]
    #[doc = "        waitset for different reasons (f.i. termination) than the 'normal'"]
    #[doc = "        status change (like new data)."]
    #[doc = "  - ReadCondition/QueryCondition"]
    #[doc = "      - Triggered when data is available on the related Reader that matches"]
    #[doc = "        the Condition."]
    #[doc = ""]
    #[doc = " This functions takes a pre-allocated list to put the \"xs\" blobs in (that"]
    #[doc = " were provided during the attach of the related entities) and will return"]
    #[doc = " the number of triggered entities. It is possible that the given size"]
    #[doc = " of the list is not the same as the number of triggered entities. If less"]
    #[doc = " entities were triggered, then the last few entries in the list are"]
    #[doc = " untouched. When more entities are triggered, then only 'size' number of"]
    #[doc = " entries are inserted into the list, but still the complete count of the"]
    #[doc = " triggered entities is returned. Which \"xs\" blobs are returned in the"]
    #[doc = " latter case is undefined."]
    #[doc = ""]
    #[doc = " In case of a time out, the return value is 0."]
    #[doc = ""]
    #[doc = " Deleting the waitset while the application is blocked results in an"]
    #[doc = " error code (i.e. < 0) returned by \"wait\"."]
    #[doc = ""]
    #[doc = " Multiple threads may block on a single waitset at the same time;"]
    #[doc = " the calls are entirely independent."]
    #[doc = ""]
    #[doc = " An empty waitset never triggers (i.e., dds_waitset_wait on an empty"]
    #[doc = " waitset is essentially equivalent to a sleep)."]
    #[doc = ""]
    #[doc = " The \"dds_waitset_wait\" operation is the same as the"]
    #[doc = " \"dds_waitset_wait_until\" except that it takes an relative timeout."]
    #[doc = ""]
    #[doc = " The \"dds_waitset_wait\" operation is the same as the \"dds_wait\""]
    #[doc = " except that it takes an absolute timeout."]
    #[doc = ""]
    #[doc = " @param[in]  waitset    The waitset to set the trigger value on."]
    #[doc = " @param[out] xs         Pre-allocated list to store the 'blobs' that were"]
    #[doc = "                        provided during the attach of the triggered entities."]
    #[doc = " @param[in]  nxs        The size of the pre-allocated blobs list."]
    #[doc = " @param[in]  abstimeout Absolute timeout"]
    #[doc = ""]
    #[doc = " @returns A dds_return_t with the number of entities triggered or an error code."]
    #[doc = ""]
    #[doc = " @retval >0"]
    #[doc = "             Number of entities triggered."]
    #[doc = " @retval  0"]
    #[doc = "             Time out (no entities were triggered)."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The given waitset is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The waitset has already been deleted."]
    pub fn dds_waitset_wait_until(
        waitset: dds_entity_t,
        xs: *mut dds_attach_t,
        nxs: size_t,
        abstimeout: dds_time_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Access and read the collection of data values (of same type) and sample info from the"]
    #[doc = "        data reader, readcondition or querycondition."]
    #[doc = " @ingroup reading"]
    #[doc = ""]
    #[doc = " Return value provides information about number of samples read, which will"]
    #[doc = " be <= maxs. Based on the count, the buffer will contain data to be read only"]
    #[doc = " when valid_data bit in sample info structure is set."]
    #[doc = " The buffer required for data values, could be allocated explicitly or can"]
    #[doc = " use the memory from data reader to prevent copy. In the latter case, buffer and"]
    #[doc = " sample_info should be returned back, once it is no longer using the Data."]
    #[doc = " Data values once read will remain in the buffer with the sample_state set to READ"]
    #[doc = " and view_state set to NOT_NEW."]
    #[doc = ""]
    #[doc = " @param[in]  reader_or_condition Reader, readcondition or querycondition entity."]
    #[doc = " @param[out] buf An array of pointers to samples into which data is read (pointers can be NULL)."]
    #[doc = " @param[out] si Pointer to an array of @ref dds_sample_info_t returned for each data value."]
    #[doc = " @param[in]  bufsz The size of buffer provided."]
    #[doc = " @param[in]  maxs Maximum number of samples to read."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t with the number of samples read or an error code."]
    #[doc = ""]
    #[doc = " @retval >=0"]
    #[doc = "             Number of samples read."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_read(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        bufsz: size_t,
        maxs: u32,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Access and read loaned samples of data reader, readcondition or querycondition."]
    #[doc = " @ingroup reading"]
    #[doc = ""]
    #[doc = " After dds_read_wl function is being called and the data has been handled, dds_return_loan() function must be called to possibly free memory."]
    #[doc = ""]
    #[doc = " @param[in]  reader_or_condition Reader, readcondition or querycondition entity"]
    #[doc = " @param[out] buf An array of pointers to samples into which data is read (pointers can be NULL)"]
    #[doc = " @param[out] si Pointer to an array of @ref dds_sample_info_t returned for each data value"]
    #[doc = " @param[in]  maxs Maximum number of samples to read"]
    #[doc = ""]
    #[doc = " @returns A dds_return_t with the number of samples read or an error code"]
    #[doc = ""]
    #[doc = " @retval >=0"]
    #[doc = "             Number of samples read."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_read_wl(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        maxs: u32,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Read the collection of data values and sample info from the data reader, readcondition"]
    #[doc = "        or querycondition based on mask."]
    #[doc = " @ingroup reading"]
    #[doc = ""]
    #[doc = " When using a readcondition or querycondition, their masks are or'd with the given mask."]
    #[doc = ""]
    #[doc = " @param[in]  reader_or_condition Reader, readcondition or querycondition entity."]
    #[doc = " @param[out] buf An array of pointers to samples into which data is read (pointers can be NULL)."]
    #[doc = " @param[out] si Pointer to an array of @ref dds_sample_info_t returned for each data value."]
    #[doc = " @param[in]  bufsz The size of buffer provided."]
    #[doc = " @param[in]  maxs Maximum number of samples to read."]
    #[doc = " @param[in]  mask Filter the data based on dds_sample_state_t|dds_view_state_t|dds_instance_state_t."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t with the number of samples read or an error code."]
    #[doc = ""]
    #[doc = " @retval >=0"]
    #[doc = "             Number of samples read."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_read_mask(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        bufsz: size_t,
        maxs: u32,
        mask: u32,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Access and read loaned samples of data reader, readcondition"]
    #[doc = "        or querycondition based on mask"]
    #[doc = " @ingroup reading"]
    #[doc = ""]
    #[doc = " When using a readcondition or querycondition, their masks are or'd with the given mask."]
    #[doc = ""]
    #[doc = " After dds_read_mask_wl function is being called and the data has been handled, dds_return_loan() function must be called to possibly free memory"]
    #[doc = ""]
    #[doc = " @param[in]  reader_or_condition Reader, readcondition or querycondition entity."]
    #[doc = " @param[out] buf An array of pointers to samples into which data is read (pointers can be NULL)."]
    #[doc = " @param[out] si Pointer to an array of @ref dds_sample_info_t returned for each data value."]
    #[doc = " @param[in]  maxs Maximum number of samples to read."]
    #[doc = " @param[in]  mask Filter the data based on dds_sample_state_t|dds_view_state_t|dds_instance_state_t."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t with the number of samples read or an error code."]
    #[doc = ""]
    #[doc = " @retval >=0"]
    #[doc = "             Number of samples read."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_read_mask_wl(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        maxs: u32,
        mask: u32,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Access and read the collection of data values (of same type) and sample info from the"]
    #[doc = "        data reader, readcondition or querycondition, coped by the provided instance handle."]
    #[doc = " @ingroup reading"]
    #[doc = ""]
    #[doc = " This operation implements the same functionality as dds_read, except that only data scoped to"]
    #[doc = " the provided instance handle is read."]
    #[doc = ""]
    #[doc = " @param[in]  reader_or_condition Reader, readcondition or querycondition entity."]
    #[doc = " @param[out] buf An array of pointers to samples into which data is read (pointers can be NULL)."]
    #[doc = " @param[out] si Pointer to an array of @ref dds_sample_info_t returned for each data value."]
    #[doc = " @param[in]  bufsz The size of buffer provided."]
    #[doc = " @param[in]  maxs Maximum number of samples to read."]
    #[doc = " @param[in]  handle Instance handle related to the samples to read."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t with the number of samples read or an error code."]
    #[doc = ""]
    #[doc = " @retval >=0"]
    #[doc = "             Number of samples read."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    #[doc = " @retval DDS_RETCODE_PRECONDITION_NOT_MET"]
    #[doc = "             The instance handle has not been registered with this reader."]
    pub fn dds_read_instance(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        bufsz: size_t,
        maxs: u32,
        handle: dds_instance_handle_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Access and read loaned samples of data reader, readcondition or querycondition,"]
    #[doc = "        scoped by the provided instance handle."]
    #[doc = " @ingroup reading"]
    #[doc = ""]
    #[doc = " This operation implements the same functionality as dds_read_wl, except that only data"]
    #[doc = " scoped to the provided instance handle is read."]
    #[doc = ""]
    #[doc = " @param[in]  reader_or_condition Reader, readcondition or querycondition entity."]
    #[doc = " @param[out] buf An array of pointers to samples into which data is read (pointers can be NULL)."]
    #[doc = " @param[out] si Pointer to an array of @ref dds_sample_info_t returned for each data value."]
    #[doc = " @param[in]  maxs Maximum number of samples to read."]
    #[doc = " @param[in]  handle Instance handle related to the samples to read."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t with the number of samples read or an error code."]
    #[doc = ""]
    #[doc = " @retval >=0"]
    #[doc = "             Number of samples read."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    #[doc = " @retval DDS_RETCODE_PRECONDITION_NOT_MET"]
    #[doc = "             The instance handle has not been registered with this reader."]
    pub fn dds_read_instance_wl(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        maxs: u32,
        handle: dds_instance_handle_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Read the collection of data values and sample info from the data reader, readcondition"]
    #[doc = "        or querycondition based on mask and scoped by the provided instance handle."]
    #[doc = " @ingroup reading"]
    #[doc = ""]
    #[doc = " This operation implements the same functionality as dds_read_mask, except that only data"]
    #[doc = " scoped to the provided instance handle is read."]
    #[doc = ""]
    #[doc = " @param[in]  reader_or_condition Reader, readcondition or querycondition entity."]
    #[doc = " @param[out] buf An array of pointers to samples into which data is read (pointers can be NULL)."]
    #[doc = " @param[out] si Pointer to an array of @ref dds_sample_info_t returned for each data value."]
    #[doc = " @param[in]  bufsz The size of buffer provided."]
    #[doc = " @param[in]  maxs Maximum number of samples to read."]
    #[doc = " @param[in]  handle Instance handle related to the samples to read."]
    #[doc = " @param[in]  mask Filter the data based on dds_sample_state_t|dds_view_state_t|dds_instance_state_t."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t with the number of samples read or an error code."]
    #[doc = ""]
    #[doc = " @retval >=0"]
    #[doc = "             Number of samples read."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    #[doc = " @retval DDS_RETCODE_PRECONDITION_NOT_MET"]
    #[doc = "             The instance handle has not been registered with this reader."]
    pub fn dds_read_instance_mask(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        bufsz: size_t,
        maxs: u32,
        handle: dds_instance_handle_t,
        mask: u32,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Access and read loaned samples of data reader, readcondition or"]
    #[doc = "        querycondition based on mask, scoped by the provided instance handle."]
    #[doc = " @ingroup reading"]
    #[doc = ""]
    #[doc = " This operation implements the same functionality as dds_read_mask_wl, except that"]
    #[doc = " only data scoped to the provided instance handle is read."]
    #[doc = ""]
    #[doc = " @param[in]  reader_or_condition Reader, readcondition or querycondition entity."]
    #[doc = " @param[out] buf An array of pointers to samples into which data is read (pointers can be NULL)."]
    #[doc = " @param[out] si Pointer to an array of @ref dds_sample_info_t returned for each data value."]
    #[doc = " @param[in]  maxs Maximum number of samples to read."]
    #[doc = " @param[in]  handle Instance handle related to the samples to read."]
    #[doc = " @param[in]  mask Filter the data based on dds_sample_state_t|dds_view_state_t|dds_instance_state_t."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t with the number of samples read or an error code."]
    #[doc = ""]
    #[doc = " @retval >=0"]
    #[doc = "             Number of samples read."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    #[doc = " @retval DDS_RETCODE_PRECONDITION_NOT_MET"]
    #[doc = "             The instance handle has not been registered with this reader."]
    pub fn dds_read_instance_mask_wl(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        maxs: u32,
        handle: dds_instance_handle_t,
        mask: u32,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Access the collection of data values (of same type) and sample info from the"]
    #[doc = "        data reader, readcondition or querycondition."]
    #[doc = " @ingroup reading"]
    #[doc = ""]
    #[doc = " Data value once read is removed from the Data Reader cannot to"]
    #[doc = " 'read' or 'taken' again."]
    #[doc = " Return value provides information about number of samples read, which will"]
    #[doc = " be <= maxs. Based on the count, the buffer will contain data to be read only"]
    #[doc = " when valid_data bit in sample info structure is set."]
    #[doc = " The buffer required for data values, could be allocated explicitly or can"]
    #[doc = " use the memory from data reader to prevent copy. In the latter case, buffer and"]
    #[doc = " sample_info should be returned back, once it is no longer using the Data."]
    #[doc = ""]
    #[doc = " @param[in]  reader_or_condition Reader, readcondition or querycondition entity."]
    #[doc = " @param[out] buf An array of pointers to samples into which data is read (pointers can be NULL)."]
    #[doc = " @param[out] si Pointer to an array of @ref dds_sample_info_t returned for each data value."]
    #[doc = " @param[in]  bufsz The size of buffer provided."]
    #[doc = " @param[in]  maxs Maximum number of samples to read."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t with the number of samples read or an error code."]
    #[doc = ""]
    #[doc = " @retval >=0"]
    #[doc = "             Number of samples read."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_take(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        bufsz: size_t,
        maxs: u32,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Access loaned samples of data reader, readcondition or querycondition."]
    #[doc = " @ingroup reading"]
    #[doc = ""]
    #[doc = " After dds_take_wl function is being called and the data has been handled, dds_return_loan() function must be called to possibly free memory"]
    #[doc = ""]
    #[doc = " @param[in]  reader_or_condition Reader, readcondition or querycondition entity."]
    #[doc = " @param[out] buf An array of pointers to samples into which data is read (pointers can be NULL)."]
    #[doc = " @param[out] si Pointer to an array of @ref dds_sample_info_t returned for each data value."]
    #[doc = " @param[in]  maxs Maximum number of samples to read."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t with the number of samples read or an error code."]
    #[doc = ""]
    #[doc = " @retval >=0"]
    #[doc = "             Number of samples read."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_take_wl(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        maxs: u32,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Take the collection of data values (of same type) and sample info from the"]
    #[doc = "        data reader, readcondition or querycondition based on mask"]
    #[doc = " @ingroup reading"]
    #[doc = ""]
    #[doc = " When using a readcondition or querycondition, their masks are or'd with the given mask."]
    #[doc = ""]
    #[doc = " @param[in]  reader_or_condition Reader, readcondition or querycondition entity."]
    #[doc = " @param[out] buf An array of pointers to samples into which data is read (pointers can be NULL)."]
    #[doc = " @param[out] si Pointer to an array of @ref dds_sample_info_t returned for each data value."]
    #[doc = " @param[in]  bufsz The size of buffer provided."]
    #[doc = " @param[in]  maxs Maximum number of samples to read."]
    #[doc = " @param[in]  mask Filter the data based on dds_sample_state_t|dds_view_state_t|dds_instance_state_t."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t with the number of samples read or an error code."]
    #[doc = ""]
    #[doc = " @retval >=0"]
    #[doc = "             Number of samples read."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_take_mask(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        bufsz: size_t,
        maxs: u32,
        mask: u32,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief  Access loaned samples of data reader, readcondition or querycondition based on mask."]
    #[doc = " @ingroup reading"]
    #[doc = ""]
    #[doc = " When using a readcondition or querycondition, their masks are or'd with the given mask."]
    #[doc = ""]
    #[doc = " After dds_take_mask_wl function is being called and the data has been handled, dds_return_loan() function must be called to possibly free memory"]
    #[doc = ""]
    #[doc = " @param[in]  reader_or_condition Reader, readcondition or querycondition entity."]
    #[doc = " @param[out] buf An array of pointers to samples into which data is read (pointers can be NULL)."]
    #[doc = " @param[out] si Pointer to an array of @ref dds_sample_info_t returned for each data value."]
    #[doc = " @param[in]  maxs Maximum number of samples to read."]
    #[doc = " @param[in]  mask Filter the data based on dds_sample_state_t|dds_view_state_t|dds_instance_state_t."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t with the number of samples read or an error code."]
    #[doc = ""]
    #[doc = " @retval >=0"]
    #[doc = "             Number of samples read."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_take_mask_wl(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        maxs: u32,
        mask: u32,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Access the collection of data values (of same type) and sample info from the"]
    #[doc = "        data reader, readcondition or querycondition but scoped by the given"]
    #[doc = "        instance handle."]
    #[doc = " @ingroup reading"]
    #[doc = ""]
    #[doc = " This operation mplements the same functionality as dds_take, except that only data"]
    #[doc = " scoped to the provided instance handle is taken."]
    #[doc = ""]
    #[doc = " @param[in]  reader_or_condition Reader, readcondition or querycondition entity."]
    #[doc = " @param[out] buf An array of pointers to samples into which data is read (pointers can be NULL)."]
    #[doc = " @param[out] si Pointer to an array of @ref dds_sample_info_t returned for each data value."]
    #[doc = " @param[in]  bufsz The size of buffer provided."]
    #[doc = " @param[in]  maxs Maximum number of samples to read."]
    #[doc = " @param[in]  handle Instance handle related to the samples to read."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t with the number of samples read or an error code."]
    #[doc = ""]
    #[doc = " @retval >=0"]
    #[doc = "             Number of samples read."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    #[doc = " @retval DDS_RETCODE_PRECONDITION_NOT_MET"]
    #[doc = "             The instance handle has not been registered with this reader."]
    pub fn dds_take_instance(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        bufsz: size_t,
        maxs: u32,
        handle: dds_instance_handle_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Access loaned samples of data reader, readcondition or querycondition,"]
    #[doc = "        scoped by the given instance handle."]
    #[doc = " @ingroup reading"]
    #[doc = ""]
    #[doc = " This operation implements the same functionality as dds_take_wl, except that"]
    #[doc = " only data scoped to the provided instance handle is read."]
    #[doc = ""]
    #[doc = " @param[in]  reader_or_condition Reader, readcondition or querycondition entity."]
    #[doc = " @param[out] buf An array of pointers to samples into which data is read (pointers can be NULL)."]
    #[doc = " @param[out] si Pointer to an array of @ref dds_sample_info_t returned for each data value."]
    #[doc = " @param[in]  maxs Maximum number of samples to read."]
    #[doc = " @param[in]  handle Instance handle related to the samples to read."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t with the number of samples read or an error code."]
    #[doc = ""]
    #[doc = " @retval >=0"]
    #[doc = "             Number of samples read."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    #[doc = " @retval DDS_RETCODE_PRECONDITION_NOT_MET"]
    #[doc = "             The instance handle has not been registered with this reader."]
    pub fn dds_take_instance_wl(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        maxs: u32,
        handle: dds_instance_handle_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Take the collection of data values (of same type) and sample info from the"]
    #[doc = "        data reader, readcondition or querycondition based on mask and scoped"]
    #[doc = "        by the given instance handle."]
    #[doc = " @ingroup reading"]
    #[doc = ""]
    #[doc = " This operation implements the same functionality as dds_take_mask, except that only"]
    #[doc = " data scoped to the provided instance handle is read."]
    #[doc = ""]
    #[doc = " @param[in]  reader_or_condition Reader, readcondition or querycondition entity."]
    #[doc = " @param[out] buf An array of pointers to samples into which data is read (pointers can be NULL)."]
    #[doc = " @param[out] si Pointer to an array of @ref dds_sample_info_t returned for each data value."]
    #[doc = " @param[in]  bufsz The size of buffer provided."]
    #[doc = " @param[in]  maxs Maximum number of samples to read."]
    #[doc = " @param[in]  handle Instance handle related to the samples to read."]
    #[doc = " @param[in]  mask Filter the data based on dds_sample_state_t|dds_view_state_t|dds_instance_state_t."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t with the number of samples read or an error code."]
    #[doc = ""]
    #[doc = " @retval >=0"]
    #[doc = "             Number of samples read."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    #[doc = " @retval DDS_RETCODE_PRECONDITION_NOT_MET"]
    #[doc = "             The instance handle has not been registered with this reader."]
    pub fn dds_take_instance_mask(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        bufsz: size_t,
        maxs: u32,
        handle: dds_instance_handle_t,
        mask: u32,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief  Access loaned samples of data reader, readcondition or querycondition based"]
    #[doc = "         on mask and scoped by the given intance handle."]
    #[doc = " @ingroup reading"]
    #[doc = ""]
    #[doc = " This operation implements the same functionality as dds_take_mask_wl, except that"]
    #[doc = " only data scoped to the provided instance handle is read."]
    #[doc = ""]
    #[doc = " @param[in]  reader_or_condition Reader, readcondition or querycondition entity."]
    #[doc = " @param[out] buf An array of pointers to samples into which data is read (pointers can be NULL)."]
    #[doc = " @param[out] si Pointer to an array of @ref dds_sample_info_t returned for each data value."]
    #[doc = " @param[in]  maxs Maximum number of samples to read."]
    #[doc = " @param[in]  handle Instance handle related to the samples to read."]
    #[doc = " @param[in]  mask Filter the data based on dds_sample_state_t|dds_view_state_t|dds_instance_state_t."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t with the number of samples or an error code."]
    #[doc = ""]
    #[doc = " @retval >= 0"]
    #[doc = "             Number of samples read."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             One of the given arguments is not valid."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object"]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    #[doc = " @retval DDS_RETCODE_PRECONDITION_NOT_MET"]
    #[doc = "             The instance handle has not been registered with this reader."]
    pub fn dds_take_instance_mask_wl(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        maxs: u32,
        handle: dds_instance_handle_t,
        mask: u32,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Read, copy and remove the status set for the entity"]
    #[doc = " @ingroup reading"]
    #[doc = ""]
    #[doc = " This operation copies the next, non-previously accessed"]
    #[doc = " data value and corresponding sample info and removes from"]
    #[doc = " the data reader. As an entity, only reader is accepted."]
    #[doc = ""]
    #[doc = " The read/take next functions return a single sample. The returned sample"]
    #[doc = " has a sample state of NOT_READ, a view state of ANY_VIEW_STATE and an"]
    #[doc = " instance state of ANY_INSTANCE_STATE."]
    #[doc = ""]
    #[doc = " @param[in]  reader The reader entity."]
    #[doc = " @param[out] buf An array of pointers to samples into which data is read (pointers can be NULL)."]
    #[doc = " @param[out] si The pointer to @ref dds_sample_info_t returned for a data value."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The operation was successful."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The entity parameter is not a valid parameter."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_take_next(
        reader: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Read, copy and remove the status set for the entity"]
    #[doc = " @ingroup reading"]
    #[doc = ""]
    #[doc = " This operation copies the next, non-previously accessed"]
    #[doc = " data value and corresponding sample info and removes from"]
    #[doc = " the data reader. As an entity, only reader is accepted."]
    #[doc = ""]
    #[doc = " The read/take next functions return a single sample. The returned sample"]
    #[doc = " has a sample state of NOT_READ, a view state of ANY_VIEW_STATE and an"]
    #[doc = " instance state of ANY_INSTANCE_STATE."]
    #[doc = ""]
    #[doc = " After dds_take_next_wl function is being called and the data has been handled,"]
    #[doc = " dds_return_loan() function must be called to possibly free memory."]
    #[doc = ""]
    #[doc = " @param[in]  reader The reader entity."]
    #[doc = " @param[out] buf An array of pointers to samples into which data is read (pointers can be NULL)."]
    #[doc = " @param[out] si The pointer to @ref dds_sample_info_t returned for a data value."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The operation was successful."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The entity parameter is not a valid parameter."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_take_next_wl(
        reader: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Read and copy the status set for the entity"]
    #[doc = " @ingroup reading"]
    #[doc = ""]
    #[doc = " This operation copies the next, non-previously accessed"]
    #[doc = " data value and corresponding sample info. As an entity,"]
    #[doc = " only reader is accepted."]
    #[doc = ""]
    #[doc = " The read/take next functions return a single sample. The returned sample"]
    #[doc = " has a sample state of NOT_READ, a view state of ANY_VIEW_STATE and an"]
    #[doc = " instance state of ANY_INSTANCE_STATE."]
    #[doc = ""]
    #[doc = " @param[in]  reader The reader entity."]
    #[doc = " @param[out] buf An array of pointers to samples into which data is read (pointers can be NULL)."]
    #[doc = " @param[out] si The pointer to @ref dds_sample_info_t returned for a data value."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The operation was successful."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The entity parameter is not a valid parameter."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_read_next(
        reader: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Read and copy the status set for the loaned sample"]
    #[doc = " @ingroup reading"]
    #[doc = ""]
    #[doc = " This operation copies the next, non-previously accessed"]
    #[doc = " data value and corresponding loaned sample info. As an entity,"]
    #[doc = " only reader is accepted."]
    #[doc = ""]
    #[doc = " The read/take next functions return a single sample. The returned sample"]
    #[doc = " has a sample state of NOT_READ, a view state of ANY_VIEW_STATE and an"]
    #[doc = " instance state of ANY_INSTANCE_STATE."]
    #[doc = ""]
    #[doc = " After dds_read_next_wl function is being called and the data has been handled,"]
    #[doc = " dds_return_loan() function must be called to possibly free memory."]
    #[doc = ""]
    #[doc = " @param[in]  reader The reader entity."]
    #[doc = " @param[out] buf An array of pointers to samples into which data is read (pointers can be NULL)."]
    #[doc = " @param[out] si The pointer to @ref dds_sample_info_t returned for a data value."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The operation was successful."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The entity parameter is not a valid parameter."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_read_next_wl(
        reader: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Return loaned samples to a reader or writer"]
    #[doc = " @ingroup loan"]
    #[doc = ""]
    #[doc = " Used to release sample buffers returned by a read/take operation (a reader-loan)"]
    #[doc = " or, in case shared memory is enabled, of the loan_sample operation (a writer-loan)."]
    #[doc = ""]
    #[doc = " When the application provides an empty buffer to a reader-loan, memory is allocated and"]
    #[doc = " managed by DDS. By calling dds_return_loan(), the reader-loan is released so that the buffer"]
    #[doc = " can be reused during a successive read/take operation. When a condition is provided, the"]
    #[doc = " reader to which the condition belongs is looked up."]
    #[doc = ""]
    #[doc = " Writer-loans are normally released implicitly when writing a loaned sample, but you can"]
    #[doc = " cancel a writer-loan prematurely by invoking the return_loan() operation. For writer loans, buf is"]
    #[doc = " overwritten with null pointers for all successfully returned entries. Any failure causes it to abort,"]
    #[doc = " possibly midway through buf."]
    #[doc = ""]
    #[doc = " @param[in] entity The entity that the loan belongs to."]
    #[doc = " @param[in,out] buf An array of (pointers to) samples, some or all of which will be set to null pointers."]
    #[doc = " @param[in] bufsz The number of (pointers to) samples stored in buf."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure"]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             - the operation was successful; for a writer loan, all entries in buf are set to null"]
    #[doc = "             - this specifically includes cases where bufsz <= 0 while entity is valid"]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             - the entity parameter is not a valid parameter"]
    #[doc = "             - buf is null, or bufsz > 0 and buf[0] = null"]
    #[doc = "             - (for writer loans) buf[0 <= i < bufsz] is null; operation is aborted, all buf[j < i] = null on return"]
    #[doc = " @retval DDS_RETCODE_PRECONDITION_NOT_MET"]
    #[doc = "             - (for reader loans) buf was already returned (not guaranteed to be detected)"]
    #[doc = "             - (for writer loans) buf[0 <= i < bufsz] does not correspond to an outstanding loan, all buf[j < i] = null on return"]
    #[doc = " @retval DDS_RETCODE_UNSUPPORTED"]
    #[doc = "             - (for writer loans) invoked on a writer not supporting loans."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             - the operation is invoked on an inappropriate object."]
    pub fn dds_return_loan(
        entity: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        bufsz: i32,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief This operation takes a sample and returns an instance handle to be used for subsequent operations."]
    #[doc = " @ingroup instance_handle"]
    #[doc = ""]
    #[doc = " @param[in]  entity Reader or Writer entity."]
    #[doc = " @param[in]  data   Sample with a key fields set."]
    #[doc = ""]
    #[doc = " @returns instance handle or DDS_HANDLE_NIL if instance could not be found from key."]
    pub fn dds_lookup_instance(
        entity: dds_entity_t,
        data: *const ::std::os::raw::c_void,
    ) -> dds_instance_handle_t;
}
extern "C" {
    #[doc = " @brief This operation takes an instance handle and return a key-value corresponding to it."]
    #[doc = " @ingroup instance_handle"]
    #[doc = ""]
    #[doc = " @param[in]  entity Reader, writer, readcondition or querycondition entity."]
    #[doc = " @param[in]  inst   Instance handle."]
    #[doc = " @param[out] data   pointer to an instance, to which the key ID corresponding to the instance handle will be"]
    #[doc = "    returned, the sample in the instance should be ignored."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The operation was successful."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             One of the parameters was invalid or the topic does not exist."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = ""]
    #[doc = " DOC_TODO: Check return codes for completeness"]
    pub fn dds_instance_get_key(
        entity: dds_entity_t,
        inst: dds_instance_handle_t,
        data: *mut ::std::os::raw::c_void,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Begin coherent publishing or begin accessing a coherent set in a subscriber"]
    #[doc = " @ingroup publication"]
    #[doc = ""]
    #[doc = " Invoking on a Writer or Reader behaves as if dds_begin_coherent was invoked on its parent"]
    #[doc = " Publisher or Subscriber respectively."]
    #[doc = ""]
    #[doc = " @param[in]  entity The entity that is prepared for coherent access."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The operation was successful."]
    #[doc = " @retval DDS_RETCODE_ERROR"]
    #[doc = "             An internal error has occurred."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The provided entity is invalid or not supported."]
    pub fn dds_begin_coherent(entity: dds_entity_t) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief End coherent publishing or end accessing a coherent set in a subscriber"]
    #[doc = " @ingroup publication"]
    #[doc = ""]
    #[doc = " Invoking on a Writer or Reader behaves as if dds_end_coherent was invoked on its parent"]
    #[doc = " Publisher or Subscriber respectively."]
    #[doc = ""]
    #[doc = " @param[in] entity The entity on which coherent access is finished."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The operation was successful."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The provided entity is invalid or not supported."]
    pub fn dds_end_coherent(entity: dds_entity_t) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Trigger DATA_AVAILABLE event on contained readers"]
    #[doc = " @ingroup subscriber"]
    #[doc = ""]
    #[doc = " The DATA_AVAILABLE event is broadcast to all readers owned by this subscriber that currently"]
    #[doc = " have new data available. Any on_data_available listener callbacks attached to respective"]
    #[doc = " readers are invoked."]
    #[doc = ""]
    #[doc = " @param[in] subscriber A valid subscriber handle."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The operation was successful."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The provided subscriber is invalid."]
    pub fn dds_notify_readers(subscriber: dds_entity_t) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Checks whether the entity has one of its enabled statuses triggered."]
    #[doc = " @ingroup entity"]
    #[doc = ""]
    #[doc = " @param[in]  entity  Entity for which to check for triggered status."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The operation was successful."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The entity parameter is not a valid parameter."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_triggered(entity: dds_entity_t) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Get the topic"]
    #[doc = " @ingroup entity"]
    #[doc = ""]
    #[doc = " This operation returns a topic (handle) when the function call is done"]
    #[doc = " with reader, writer, read condition or query condition. For instance, it"]
    #[doc = " will return the topic when it is used for creating the reader or writer."]
    #[doc = " For the conditions, it returns the topic that is used for creating the reader"]
    #[doc = " which was used to create the condition."]
    #[doc = ""]
    #[doc = " @param[in] entity The entity."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The operation was successful."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The entity parameter is not a valid parameter."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    #[doc = " @retval DDS_RETCODE_ALREADY_DELETED"]
    #[doc = "             The entity has already been deleted."]
    pub fn dds_get_topic(entity: dds_entity_t) -> dds_entity_t;
}
extern "C" {
    #[doc = " @brief Get instance handles of the data readers matching a writer"]
    #[doc = " @ingroup builtintopic"]
    #[doc = ""]
    #[doc = " This operation fills the provided array with the instance handles"]
    #[doc = " of the data readers that match the writer.  On successful output,"]
    #[doc = " the number of entries of \"rds\" set is the minimum of the return"]
    #[doc = " value and the value of \"nrds\"."]
    #[doc = ""]
    #[doc = " @param[in] writer   The writer."]
    #[doc = " @param[in] rds      The array to be filled."]
    #[doc = " @param[in] nrds     The size of the rds array, at most the first"]
    #[doc = "                     nrds entries will be filled.  rds = NULL and nrds = 0"]
    #[doc = "                     is a valid way of determining the number of matched"]
    #[doc = "                     readers, but inefficient compared to relying on the"]
    #[doc = "                     matched publication status."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating the number of matched readers"]
    #[doc = "             or failure.  The return value may be larger than nrds"]
    #[doc = "             if there are more matching readers than the array can"]
    #[doc = "             hold."]
    #[doc = ""]
    #[doc = " @retval >=0"]
    #[doc = "             The number of matching readers."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The entity parameter is not valid or rds = NULL and"]
    #[doc = "             nrds > 0."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    pub fn dds_get_matched_subscriptions(
        writer: dds_entity_t,
        rds: *mut dds_instance_handle_t,
        nrds: size_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Get a description of a reader matched with the provided writer"]
    #[doc = " @ingroup builtintopic"]
    #[doc = ""]
    #[doc = " This operation looks up the reader instance handle in the set of"]
    #[doc = " readers matched with the specified writer, returning a freshly"]
    #[doc = " allocated sample of the DCPSSubscription built-in topic if found,"]
    #[doc = " and NULL if not.  The caller is responsible for freeing the"]
    #[doc = " memory allocated, e.g. using dds_builtintopic_free_endpoint."]
    #[doc = ""]
    #[doc = " This operation is similar to performing a read of the given"]
    #[doc = " instance handle on a reader of the DCPSSubscription built-in"]
    #[doc = " topic, but this operation additionally filters on whether the"]
    #[doc = " reader is matched by the provided writer."]
    #[doc = ""]
    #[doc = " @param[in] writer   The writer."]
    #[doc = " @param[in] ih       The instance handle of a reader."]
    #[doc = ""]
    #[doc = " @returns A newly allocated sample containing the information on the"]
    #[doc = "             reader, or a NULL pointer for any kind of failure."]
    #[doc = ""]
    #[doc = " @retval != NULL"]
    #[doc = "             The requested data"]
    #[doc = " @retval NULL"]
    #[doc = "             The writer is not valid or ih is not an instance handle"]
    #[doc = "             of a matched reader."]
    pub fn dds_get_matched_subscription_data(
        writer: dds_entity_t,
        ih: dds_instance_handle_t,
    ) -> *mut dds_builtintopic_endpoint_t;
}
extern "C" {
    #[doc = " @brief Get instance handles of the data writers matching a reader"]
    #[doc = " @ingroup builtintopic"]
    #[doc = ""]
    #[doc = " This operation fills the provided array with the instance handles"]
    #[doc = " of the data writers that match the reader.  On successful output,"]
    #[doc = " the number of entries of \"wrs\" set is the minimum of the return"]
    #[doc = " value and the value of \"nwrs\"."]
    #[doc = ""]
    #[doc = " @param[in] reader   The reader."]
    #[doc = " @param[in] wrs      The array to be filled."]
    #[doc = " @param[in] nwrs     The size of the wrs array, at most the first"]
    #[doc = "             nwrs entries will be filled.  wrs = NULL and wrds = 0"]
    #[doc = "             is a valid way of determining the number of matched"]
    #[doc = "             readers, but inefficient compared to relying on the"]
    #[doc = "             matched publication status."]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating the number of matched writers"]
    #[doc = "             or failure.  The return value may be larger than nwrs"]
    #[doc = "             if there are more matching writers than the array can"]
    #[doc = "             hold."]
    #[doc = ""]
    #[doc = " @retval >=0"]
    #[doc = "             The number of matching writers."]
    #[doc = " @retval DDS_RETCODE_BAD_PARAMETER"]
    #[doc = "             The entity parameter is not valid or wrs = NULL and"]
    #[doc = "             nwrs > 0."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    pub fn dds_get_matched_publications(
        reader: dds_entity_t,
        wrs: *mut dds_instance_handle_t,
        nwrs: size_t,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @brief Get a description of a writer matched with the provided reader"]
    #[doc = " @ingroup builtintopic"]
    #[doc = ""]
    #[doc = " This operation looks up the writer instance handle in the set of"]
    #[doc = " writers matched with the specified reader, returning a freshly"]
    #[doc = " allocated sample of the DCPSPublication built-in topic if found,"]
    #[doc = " and NULL if not.  The caller is responsible for freeing the"]
    #[doc = " memory allocated, e.g. using dds_builtintopic_free_endpoint."]
    #[doc = ""]
    #[doc = " This operation is similar to performing a read of the given"]
    #[doc = " instance handle on a reader of the DCPSPublication built-in"]
    #[doc = " topic, but this operation additionally filters on whether the"]
    #[doc = " writer is matched by the provided reader."]
    #[doc = ""]
    #[doc = " @param[in] reader   The reader."]
    #[doc = " @param[in] ih       The instance handle of a writer."]
    #[doc = ""]
    #[doc = " @returns A newly allocated sample containing the information on the"]
    #[doc = "             writer, or a NULL pointer for any kind of failure."]
    #[doc = ""]
    #[doc = " @retval != NULL"]
    #[doc = "             The requested data"]
    #[doc = " @retval NULL"]
    #[doc = "             The reader is not valid or ih is not an instance handle"]
    #[doc = "             of a matched writer."]
    pub fn dds_get_matched_publication_data(
        reader: dds_entity_t,
        ih: dds_instance_handle_t,
    ) -> *mut dds_builtintopic_endpoint_t;
}
extern "C" {
    #[doc = " @brief This operation manually asserts the liveliness of a writer"]
    #[doc = "        or domain participant."]
    #[doc = " @ingroup entity"]
    #[doc = ""]
    #[doc = " This operation manually asserts the liveliness of a writer"]
    #[doc = " or domain participant. This is used in combination with the Liveliness"]
    #[doc = " QoS policy to indicate that the entity remains active. This operation need"]
    #[doc = " only be used if the liveliness kind in the QoS is either"]
    #[doc = " DDS_LIVELINESS_MANUAL_BY_PARTICIPANT or DDS_LIVELINESS_MANUAL_BY_TOPIC."]
    #[doc = ""]
    #[doc = " @param[in] entity  A domain participant or writer"]
    #[doc = ""]
    #[doc = " @returns A dds_return_t indicating success or failure."]
    #[doc = ""]
    #[doc = " @retval DDS_RETCODE_OK"]
    #[doc = "             The operation was successful."]
    #[doc = " @retval DDS_RETCODE_ILLEGAL_OPERATION"]
    #[doc = "             The operation is invoked on an inappropriate object."]
    pub fn dds_assert_liveliness(entity: dds_entity_t) -> dds_return_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: size_t,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
impl Default for iovec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type ddsrt_iovec_t = iovec;
pub type ddsrt_msg_iovlen_t = size_t;
#[doc = " @brief Types on which atomic operations are defined."]
#[doc = ""]
#[doc = " @note 64-bit types are defined even if atomic operations on them are not"]
#[doc = "       really supported. atomic"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ddsrt_atomic_uint32_t {
    pub v: u32,
}
#[test]
fn bindgen_test_layout_ddsrt_atomic_uint32_t() {
    assert_eq!(
        ::std::mem::size_of::<ddsrt_atomic_uint32_t>(),
        4usize,
        concat!("Size of: ", stringify!(ddsrt_atomic_uint32_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsrt_atomic_uint32_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ddsrt_atomic_uint32_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsrt_atomic_uint32_t>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsrt_atomic_uint32_t),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ddsrt_atomic_uintptr_t {
    pub v: usize,
}
#[test]
fn bindgen_test_layout_ddsrt_atomic_uintptr_t() {
    assert_eq!(
        ::std::mem::size_of::<ddsrt_atomic_uintptr_t>(),
        8usize,
        concat!("Size of: ", stringify!(ddsrt_atomic_uintptr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsrt_atomic_uintptr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ddsrt_atomic_uintptr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsrt_atomic_uintptr_t>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsrt_atomic_uintptr_t),
            "::",
            stringify!(v)
        )
    );
}
pub type ddsrt_atomic_voidp_t = ddsrt_atomic_uintptr_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union ddsi_guid_prefix {
    pub s: [::std::os::raw::c_uchar; 12usize],
    pub u: [u32; 3usize],
    _bindgen_union_align: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_ddsi_guid_prefix() {
    assert_eq!(
        ::std::mem::size_of::<ddsi_guid_prefix>(),
        12usize,
        concat!("Size of: ", stringify!(ddsi_guid_prefix))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsi_guid_prefix>(),
        4usize,
        concat!("Alignment of ", stringify!(ddsi_guid_prefix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_guid_prefix>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_guid_prefix),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_guid_prefix>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_guid_prefix),
            "::",
            stringify!(u)
        )
    );
}
impl Default for ddsi_guid_prefix {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type ddsi_guid_prefix_t = ddsi_guid_prefix;
#[repr(C)]
#[derive(Copy, Clone)]
pub union ddsi_entityid {
    pub u: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_ddsi_entityid() {
    assert_eq!(
        ::std::mem::size_of::<ddsi_entityid>(),
        4usize,
        concat!("Size of: ", stringify!(ddsi_entityid))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsi_entityid>(),
        4usize,
        concat!("Alignment of ", stringify!(ddsi_entityid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_entityid>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_entityid),
            "::",
            stringify!(u)
        )
    );
}
impl Default for ddsi_entityid {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type ddsi_entityid_t = ddsi_entityid;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ddsi_guid {
    pub prefix: ddsi_guid_prefix_t,
    pub entityid: ddsi_entityid_t,
}
#[test]
fn bindgen_test_layout_ddsi_guid() {
    assert_eq!(
        ::std::mem::size_of::<ddsi_guid>(),
        16usize,
        concat!("Size of: ", stringify!(ddsi_guid))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsi_guid>(),
        4usize,
        concat!("Alignment of ", stringify!(ddsi_guid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_guid>())).prefix as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_guid),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_guid>())).entityid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_guid),
            "::",
            stringify!(entityid)
        )
    );
}
impl Default for ddsi_guid {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddsi_octetseq {
    pub length: u32,
    pub value: *mut ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_ddsi_octetseq() {
    assert_eq!(
        ::std::mem::size_of::<ddsi_octetseq>(),
        16usize,
        concat!("Size of: ", stringify!(ddsi_octetseq))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsi_octetseq>(),
        8usize,
        concat!("Alignment of ", stringify!(ddsi_octetseq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_octetseq>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_octetseq),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_octetseq>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_octetseq),
            "::",
            stringify!(value)
        )
    );
}
impl Default for ddsi_octetseq {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type ddsi_octetseq_t = ddsi_octetseq;
pub type dds_userdata_qospolicy_t = ddsi_octetseq_t;
pub type dds_topicdata_qospolicy_t = ddsi_octetseq_t;
pub type dds_groupdata_qospolicy_t = ddsi_octetseq_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_property {
    pub propagate: ::std::os::raw::c_uchar,
    pub name: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_dds_property() {
    assert_eq!(
        ::std::mem::size_of::<dds_property>(),
        24usize,
        concat!("Size of: ", stringify!(dds_property))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_property>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_property))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_property>())).propagate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_property),
            "::",
            stringify!(propagate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_property>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_property),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_property>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_property),
            "::",
            stringify!(value)
        )
    );
}
impl Default for dds_property {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_property_t = dds_property;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_propertyseq {
    pub n: u32,
    pub props: *mut dds_property_t,
}
#[test]
fn bindgen_test_layout_dds_propertyseq() {
    assert_eq!(
        ::std::mem::size_of::<dds_propertyseq>(),
        16usize,
        concat!("Size of: ", stringify!(dds_propertyseq))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_propertyseq>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_propertyseq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_propertyseq>())).n as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_propertyseq),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_propertyseq>())).props as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_propertyseq),
            "::",
            stringify!(props)
        )
    );
}
impl Default for dds_propertyseq {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_propertyseq_t = dds_propertyseq;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_binaryproperty {
    pub propagate: ::std::os::raw::c_uchar,
    pub name: *mut ::std::os::raw::c_char,
    pub value: ddsi_octetseq_t,
}
#[test]
fn bindgen_test_layout_dds_binaryproperty() {
    assert_eq!(
        ::std::mem::size_of::<dds_binaryproperty>(),
        32usize,
        concat!("Size of: ", stringify!(dds_binaryproperty))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_binaryproperty>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_binaryproperty))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_binaryproperty>())).propagate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_binaryproperty),
            "::",
            stringify!(propagate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_binaryproperty>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_binaryproperty),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_binaryproperty>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_binaryproperty),
            "::",
            stringify!(value)
        )
    );
}
impl Default for dds_binaryproperty {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_binaryproperty_t = dds_binaryproperty;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_binarypropertyseq {
    pub n: u32,
    pub props: *mut dds_binaryproperty_t,
}
#[test]
fn bindgen_test_layout_dds_binarypropertyseq() {
    assert_eq!(
        ::std::mem::size_of::<dds_binarypropertyseq>(),
        16usize,
        concat!("Size of: ", stringify!(dds_binarypropertyseq))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_binarypropertyseq>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_binarypropertyseq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_binarypropertyseq>())).n as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_binarypropertyseq),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_binarypropertyseq>())).props as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_binarypropertyseq),
            "::",
            stringify!(props)
        )
    );
}
impl Default for dds_binarypropertyseq {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_binarypropertyseq_t = dds_binarypropertyseq;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_property_qospolicy {
    pub value: dds_propertyseq_t,
    pub binary_value: dds_binarypropertyseq_t,
}
#[test]
fn bindgen_test_layout_dds_property_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_property_qospolicy>(),
        32usize,
        concat!("Size of: ", stringify!(dds_property_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_property_qospolicy>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_property_qospolicy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_property_qospolicy>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_property_qospolicy),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_property_qospolicy>())).binary_value as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_property_qospolicy),
            "::",
            stringify!(binary_value)
        )
    );
}
impl Default for dds_property_qospolicy {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_property_qospolicy_t = dds_property_qospolicy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_durability_qospolicy {
    pub kind: dds_durability_kind_t,
}
#[test]
fn bindgen_test_layout_dds_durability_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_durability_qospolicy>(),
        4usize,
        concat!("Size of: ", stringify!(dds_durability_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_durability_qospolicy>(),
        4usize,
        concat!("Alignment of ", stringify!(dds_durability_qospolicy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_durability_qospolicy>())).kind as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_durability_qospolicy),
            "::",
            stringify!(kind)
        )
    );
}
impl Default for dds_durability_qospolicy {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_durability_qospolicy_t = dds_durability_qospolicy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_history_qospolicy {
    pub kind: dds_history_kind_t,
    pub depth: i32,
}
#[test]
fn bindgen_test_layout_dds_history_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_history_qospolicy>(),
        8usize,
        concat!("Size of: ", stringify!(dds_history_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_history_qospolicy>(),
        4usize,
        concat!("Alignment of ", stringify!(dds_history_qospolicy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_history_qospolicy>())).kind as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_history_qospolicy),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_history_qospolicy>())).depth as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_history_qospolicy),
            "::",
            stringify!(depth)
        )
    );
}
impl Default for dds_history_qospolicy {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_history_qospolicy_t = dds_history_qospolicy;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_resource_limits_qospolicy {
    pub max_samples: i32,
    pub max_instances: i32,
    pub max_samples_per_instance: i32,
}
#[test]
fn bindgen_test_layout_dds_resource_limits_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_resource_limits_qospolicy>(),
        12usize,
        concat!("Size of: ", stringify!(dds_resource_limits_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_resource_limits_qospolicy>(),
        4usize,
        concat!("Alignment of ", stringify!(dds_resource_limits_qospolicy))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_resource_limits_qospolicy>())).max_samples as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_resource_limits_qospolicy),
            "::",
            stringify!(max_samples)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_resource_limits_qospolicy>())).max_instances as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_resource_limits_qospolicy),
            "::",
            stringify!(max_instances)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_resource_limits_qospolicy>())).max_samples_per_instance
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_resource_limits_qospolicy),
            "::",
            stringify!(max_samples_per_instance)
        )
    );
}
pub type dds_resource_limits_qospolicy_t = dds_resource_limits_qospolicy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_durability_service_qospolicy {
    pub service_cleanup_delay: dds_duration_t,
    pub history: dds_history_qospolicy_t,
    pub resource_limits: dds_resource_limits_qospolicy_t,
}
#[test]
fn bindgen_test_layout_dds_durability_service_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_durability_service_qospolicy>(),
        32usize,
        concat!("Size of: ", stringify!(dds_durability_service_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_durability_service_qospolicy>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(dds_durability_service_qospolicy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_durability_service_qospolicy>())).service_cleanup_delay
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_durability_service_qospolicy),
            "::",
            stringify!(service_cleanup_delay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_durability_service_qospolicy>())).history as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_durability_service_qospolicy),
            "::",
            stringify!(history)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_durability_service_qospolicy>())).resource_limits as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_durability_service_qospolicy),
            "::",
            stringify!(resource_limits)
        )
    );
}
impl Default for dds_durability_service_qospolicy {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_durability_service_qospolicy_t = dds_durability_service_qospolicy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_presentation_qospolicy {
    pub access_scope: dds_presentation_access_scope_kind_t,
    pub coherent_access: ::std::os::raw::c_uchar,
    pub ordered_access: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_dds_presentation_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_presentation_qospolicy>(),
        8usize,
        concat!("Size of: ", stringify!(dds_presentation_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_presentation_qospolicy>(),
        4usize,
        concat!("Alignment of ", stringify!(dds_presentation_qospolicy))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_presentation_qospolicy>())).access_scope as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_presentation_qospolicy),
            "::",
            stringify!(access_scope)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_presentation_qospolicy>())).coherent_access as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_presentation_qospolicy),
            "::",
            stringify!(coherent_access)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_presentation_qospolicy>())).ordered_access as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_presentation_qospolicy),
            "::",
            stringify!(ordered_access)
        )
    );
}
impl Default for dds_presentation_qospolicy {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_presentation_qospolicy_t = dds_presentation_qospolicy;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_deadline_qospolicy {
    pub deadline: dds_duration_t,
}
#[test]
fn bindgen_test_layout_dds_deadline_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_deadline_qospolicy>(),
        8usize,
        concat!("Size of: ", stringify!(dds_deadline_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_deadline_qospolicy>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_deadline_qospolicy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_deadline_qospolicy>())).deadline as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_deadline_qospolicy),
            "::",
            stringify!(deadline)
        )
    );
}
pub type dds_deadline_qospolicy_t = dds_deadline_qospolicy;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_latency_budget_qospolicy {
    pub duration: dds_duration_t,
}
#[test]
fn bindgen_test_layout_dds_latency_budget_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_latency_budget_qospolicy>(),
        8usize,
        concat!("Size of: ", stringify!(dds_latency_budget_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_latency_budget_qospolicy>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_latency_budget_qospolicy))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_latency_budget_qospolicy>())).duration as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_latency_budget_qospolicy),
            "::",
            stringify!(duration)
        )
    );
}
pub type dds_latency_budget_qospolicy_t = dds_latency_budget_qospolicy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_ownership_qospolicy {
    pub kind: dds_ownership_kind_t,
}
#[test]
fn bindgen_test_layout_dds_ownership_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_ownership_qospolicy>(),
        4usize,
        concat!("Size of: ", stringify!(dds_ownership_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_ownership_qospolicy>(),
        4usize,
        concat!("Alignment of ", stringify!(dds_ownership_qospolicy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_ownership_qospolicy>())).kind as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_ownership_qospolicy),
            "::",
            stringify!(kind)
        )
    );
}
impl Default for dds_ownership_qospolicy {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_ownership_qospolicy_t = dds_ownership_qospolicy;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_ownership_strength_qospolicy {
    pub value: i32,
}
#[test]
fn bindgen_test_layout_dds_ownership_strength_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_ownership_strength_qospolicy>(),
        4usize,
        concat!("Size of: ", stringify!(dds_ownership_strength_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_ownership_strength_qospolicy>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dds_ownership_strength_qospolicy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_ownership_strength_qospolicy>())).value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_ownership_strength_qospolicy),
            "::",
            stringify!(value)
        )
    );
}
pub type dds_ownership_strength_qospolicy_t = dds_ownership_strength_qospolicy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_liveliness_qospolicy {
    pub kind: dds_liveliness_kind_t,
    pub lease_duration: dds_duration_t,
}
#[test]
fn bindgen_test_layout_dds_liveliness_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_liveliness_qospolicy>(),
        16usize,
        concat!("Size of: ", stringify!(dds_liveliness_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_liveliness_qospolicy>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_liveliness_qospolicy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_liveliness_qospolicy>())).kind as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_liveliness_qospolicy),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_liveliness_qospolicy>())).lease_duration as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_liveliness_qospolicy),
            "::",
            stringify!(lease_duration)
        )
    );
}
impl Default for dds_liveliness_qospolicy {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_liveliness_qospolicy_t = dds_liveliness_qospolicy;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_time_based_filter_qospolicy {
    pub minimum_separation: dds_duration_t,
}
#[test]
fn bindgen_test_layout_dds_time_based_filter_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_time_based_filter_qospolicy>(),
        8usize,
        concat!("Size of: ", stringify!(dds_time_based_filter_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_time_based_filter_qospolicy>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_time_based_filter_qospolicy))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_time_based_filter_qospolicy>())).minimum_separation
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_time_based_filter_qospolicy),
            "::",
            stringify!(minimum_separation)
        )
    );
}
pub type dds_time_based_filter_qospolicy_t = dds_time_based_filter_qospolicy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddsi_stringseq {
    pub n: u32,
    pub strs: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ddsi_stringseq() {
    assert_eq!(
        ::std::mem::size_of::<ddsi_stringseq>(),
        16usize,
        concat!("Size of: ", stringify!(ddsi_stringseq))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsi_stringseq>(),
        8usize,
        concat!("Alignment of ", stringify!(ddsi_stringseq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_stringseq>())).n as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_stringseq),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_stringseq>())).strs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_stringseq),
            "::",
            stringify!(strs)
        )
    );
}
impl Default for ddsi_stringseq {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type ddsi_stringseq_t = ddsi_stringseq;
pub type dds_partition_qospolicy_t = ddsi_stringseq_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_reliability_qospolicy {
    pub kind: dds_reliability_kind_t,
    pub max_blocking_time: dds_duration_t,
}
#[test]
fn bindgen_test_layout_dds_reliability_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_reliability_qospolicy>(),
        16usize,
        concat!("Size of: ", stringify!(dds_reliability_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_reliability_qospolicy>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_reliability_qospolicy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_reliability_qospolicy>())).kind as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_reliability_qospolicy),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_reliability_qospolicy>())).max_blocking_time as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_reliability_qospolicy),
            "::",
            stringify!(max_blocking_time)
        )
    );
}
impl Default for dds_reliability_qospolicy {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_reliability_qospolicy_t = dds_reliability_qospolicy;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_transport_priority_qospolicy {
    pub value: i32,
}
#[test]
fn bindgen_test_layout_dds_transport_priority_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_transport_priority_qospolicy>(),
        4usize,
        concat!("Size of: ", stringify!(dds_transport_priority_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_transport_priority_qospolicy>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dds_transport_priority_qospolicy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_transport_priority_qospolicy>())).value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_transport_priority_qospolicy),
            "::",
            stringify!(value)
        )
    );
}
pub type dds_transport_priority_qospolicy_t = dds_transport_priority_qospolicy;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_lifespan_qospolicy {
    pub duration: dds_duration_t,
}
#[test]
fn bindgen_test_layout_dds_lifespan_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_lifespan_qospolicy>(),
        8usize,
        concat!("Size of: ", stringify!(dds_lifespan_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_lifespan_qospolicy>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_lifespan_qospolicy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_lifespan_qospolicy>())).duration as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_lifespan_qospolicy),
            "::",
            stringify!(duration)
        )
    );
}
pub type dds_lifespan_qospolicy_t = dds_lifespan_qospolicy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_destination_order_qospolicy {
    pub kind: dds_destination_order_kind_t,
}
#[test]
fn bindgen_test_layout_dds_destination_order_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_destination_order_qospolicy>(),
        4usize,
        concat!("Size of: ", stringify!(dds_destination_order_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_destination_order_qospolicy>(),
        4usize,
        concat!("Alignment of ", stringify!(dds_destination_order_qospolicy))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_destination_order_qospolicy>())).kind as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_destination_order_qospolicy),
            "::",
            stringify!(kind)
        )
    );
}
impl Default for dds_destination_order_qospolicy {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_destination_order_qospolicy_t = dds_destination_order_qospolicy;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_entity_factory_qospolicy {
    pub autoenable_created_entities: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_dds_entity_factory_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_entity_factory_qospolicy>(),
        1usize,
        concat!("Size of: ", stringify!(dds_entity_factory_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_entity_factory_qospolicy>(),
        1usize,
        concat!("Alignment of ", stringify!(dds_entity_factory_qospolicy))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_entity_factory_qospolicy>())).autoenable_created_entities
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_entity_factory_qospolicy),
            "::",
            stringify!(autoenable_created_entities)
        )
    );
}
pub type dds_entity_factory_qospolicy_t = dds_entity_factory_qospolicy;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_writer_data_lifecycle_qospolicy {
    pub autodispose_unregistered_instances: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_dds_writer_data_lifecycle_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_writer_data_lifecycle_qospolicy>(),
        1usize,
        concat!("Size of: ", stringify!(dds_writer_data_lifecycle_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_writer_data_lifecycle_qospolicy>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(dds_writer_data_lifecycle_qospolicy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_writer_data_lifecycle_qospolicy>()))
                .autodispose_unregistered_instances as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_writer_data_lifecycle_qospolicy),
            "::",
            stringify!(autodispose_unregistered_instances)
        )
    );
}
pub type dds_writer_data_lifecycle_qospolicy_t = dds_writer_data_lifecycle_qospolicy;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_reader_data_lifecycle_qospolicy {
    pub autopurge_nowriter_samples_delay: dds_duration_t,
    pub autopurge_disposed_samples_delay: dds_duration_t,
}
#[test]
fn bindgen_test_layout_dds_reader_data_lifecycle_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_reader_data_lifecycle_qospolicy>(),
        16usize,
        concat!("Size of: ", stringify!(dds_reader_data_lifecycle_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_reader_data_lifecycle_qospolicy>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(dds_reader_data_lifecycle_qospolicy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_reader_data_lifecycle_qospolicy>()))
                .autopurge_nowriter_samples_delay as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_reader_data_lifecycle_qospolicy),
            "::",
            stringify!(autopurge_nowriter_samples_delay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_reader_data_lifecycle_qospolicy>()))
                .autopurge_disposed_samples_delay as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_reader_data_lifecycle_qospolicy),
            "::",
            stringify!(autopurge_disposed_samples_delay)
        )
    );
}
pub type dds_reader_data_lifecycle_qospolicy_t = dds_reader_data_lifecycle_qospolicy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_subscription_keys_qospolicy {
    pub use_key_list: ::std::os::raw::c_uchar,
    pub key_list: ddsi_stringseq_t,
}
#[test]
fn bindgen_test_layout_dds_subscription_keys_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_subscription_keys_qospolicy>(),
        24usize,
        concat!("Size of: ", stringify!(dds_subscription_keys_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_subscription_keys_qospolicy>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_subscription_keys_qospolicy))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_subscription_keys_qospolicy>())).use_key_list as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_subscription_keys_qospolicy),
            "::",
            stringify!(use_key_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_subscription_keys_qospolicy>())).key_list as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_subscription_keys_qospolicy),
            "::",
            stringify!(key_list)
        )
    );
}
impl Default for dds_subscription_keys_qospolicy {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_subscription_keys_qospolicy_t = dds_subscription_keys_qospolicy;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_reader_lifespan_qospolicy {
    pub use_lifespan: ::std::os::raw::c_uchar,
    pub duration: dds_duration_t,
}
#[test]
fn bindgen_test_layout_dds_reader_lifespan_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_reader_lifespan_qospolicy>(),
        16usize,
        concat!("Size of: ", stringify!(dds_reader_lifespan_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_reader_lifespan_qospolicy>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_reader_lifespan_qospolicy))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_reader_lifespan_qospolicy>())).use_lifespan as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_reader_lifespan_qospolicy),
            "::",
            stringify!(use_lifespan)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_reader_lifespan_qospolicy>())).duration as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_reader_lifespan_qospolicy),
            "::",
            stringify!(duration)
        )
    );
}
pub type dds_reader_lifespan_qospolicy_t = dds_reader_lifespan_qospolicy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_ignorelocal_qospolicy {
    pub value: dds_ignorelocal_kind_t,
}
#[test]
fn bindgen_test_layout_dds_ignorelocal_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_ignorelocal_qospolicy>(),
        4usize,
        concat!("Size of: ", stringify!(dds_ignorelocal_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_ignorelocal_qospolicy>(),
        4usize,
        concat!("Alignment of ", stringify!(dds_ignorelocal_qospolicy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_ignorelocal_qospolicy>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_ignorelocal_qospolicy),
            "::",
            stringify!(value)
        )
    );
}
impl Default for dds_ignorelocal_qospolicy {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_ignorelocal_qospolicy_t = dds_ignorelocal_qospolicy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_type_consistency_enforcement_qospolicy {
    pub kind: dds_type_consistency_kind_t,
    pub ignore_sequence_bounds: bool,
    pub ignore_string_bounds: bool,
    pub ignore_member_names: bool,
    pub prevent_type_widening: bool,
    pub force_type_validation: bool,
}
#[test]
fn bindgen_test_layout_dds_type_consistency_enforcement_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_type_consistency_enforcement_qospolicy>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(dds_type_consistency_enforcement_qospolicy)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<dds_type_consistency_enforcement_qospolicy>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dds_type_consistency_enforcement_qospolicy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_type_consistency_enforcement_qospolicy>())).kind as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_type_consistency_enforcement_qospolicy),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_type_consistency_enforcement_qospolicy>()))
                .ignore_sequence_bounds as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_type_consistency_enforcement_qospolicy),
            "::",
            stringify!(ignore_sequence_bounds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_type_consistency_enforcement_qospolicy>()))
                .ignore_string_bounds as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_type_consistency_enforcement_qospolicy),
            "::",
            stringify!(ignore_string_bounds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_type_consistency_enforcement_qospolicy>()))
                .ignore_member_names as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_type_consistency_enforcement_qospolicy),
            "::",
            stringify!(ignore_member_names)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_type_consistency_enforcement_qospolicy>()))
                .prevent_type_widening as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_type_consistency_enforcement_qospolicy),
            "::",
            stringify!(prevent_type_widening)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_type_consistency_enforcement_qospolicy>()))
                .force_type_validation as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_type_consistency_enforcement_qospolicy),
            "::",
            stringify!(force_type_validation)
        )
    );
}
impl Default for dds_type_consistency_enforcement_qospolicy {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_type_consistency_enforcement_qospolicy_t = dds_type_consistency_enforcement_qospolicy;
pub type dds_locator_mask_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_data_representation_id_seq {
    pub n: u32,
    pub ids: *mut dds_data_representation_id_t,
}
#[test]
fn bindgen_test_layout_dds_data_representation_id_seq() {
    assert_eq!(
        ::std::mem::size_of::<dds_data_representation_id_seq>(),
        16usize,
        concat!("Size of: ", stringify!(dds_data_representation_id_seq))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_data_representation_id_seq>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_data_representation_id_seq))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_data_representation_id_seq>())).n as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_data_representation_id_seq),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_data_representation_id_seq>())).ids as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_data_representation_id_seq),
            "::",
            stringify!(ids)
        )
    );
}
impl Default for dds_data_representation_id_seq {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_data_representation_id_seq_t = dds_data_representation_id_seq;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_data_representation_qospolicy {
    pub value: dds_data_representation_id_seq_t,
}
#[test]
fn bindgen_test_layout_dds_data_representation_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_data_representation_qospolicy>(),
        16usize,
        concat!("Size of: ", stringify!(dds_data_representation_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_data_representation_qospolicy>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(dds_data_representation_qospolicy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_data_representation_qospolicy>())).value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_data_representation_qospolicy),
            "::",
            stringify!(value)
        )
    );
}
impl Default for dds_data_representation_qospolicy {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_data_representation_qospolicy_t = dds_data_representation_qospolicy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_qos {
    pub present: u64,
    pub aliased: u64,
    pub topic_name: *mut ::std::os::raw::c_char,
    pub type_name: *mut ::std::os::raw::c_char,
    pub entity_name: *mut ::std::os::raw::c_char,
    pub type_information: *mut ddsi_typeinfo,
    pub presentation: dds_presentation_qospolicy_t,
    pub partition: dds_partition_qospolicy_t,
    pub group_data: dds_groupdata_qospolicy_t,
    pub entity_factory: dds_entity_factory_qospolicy_t,
    pub topic_data: dds_topicdata_qospolicy_t,
    pub durability: dds_durability_qospolicy_t,
    pub durability_service: dds_durability_service_qospolicy_t,
    pub deadline: dds_deadline_qospolicy_t,
    pub latency_budget: dds_latency_budget_qospolicy_t,
    pub liveliness: dds_liveliness_qospolicy_t,
    pub reliability: dds_reliability_qospolicy_t,
    pub destination_order: dds_destination_order_qospolicy_t,
    pub history: dds_history_qospolicy_t,
    pub resource_limits: dds_resource_limits_qospolicy_t,
    pub transport_priority: dds_transport_priority_qospolicy_t,
    pub lifespan: dds_lifespan_qospolicy_t,
    pub user_data: dds_userdata_qospolicy_t,
    pub ownership: dds_ownership_qospolicy_t,
    pub ownership_strength: dds_ownership_strength_qospolicy_t,
    pub time_based_filter: dds_time_based_filter_qospolicy_t,
    pub writer_data_lifecycle: dds_writer_data_lifecycle_qospolicy_t,
    pub reader_data_lifecycle: dds_reader_data_lifecycle_qospolicy_t,
    pub subscription_keys: dds_subscription_keys_qospolicy_t,
    pub reader_lifespan: dds_reader_lifespan_qospolicy_t,
    pub ignorelocal: dds_ignorelocal_qospolicy_t,
    pub property: dds_property_qospolicy_t,
    pub type_consistency: dds_type_consistency_enforcement_qospolicy_t,
    pub ignore_locator_type: dds_locator_mask_t,
    pub data_representation: dds_data_representation_qospolicy_t,
}
#[test]
fn bindgen_test_layout_dds_qos() {
    assert_eq!(
        ::std::mem::size_of::<dds_qos>(),
        408usize,
        concat!("Size of: ", stringify!(dds_qos))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_qos>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_qos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).present as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(present)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).aliased as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(aliased)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).topic_name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(topic_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).type_name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).entity_name as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(entity_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).type_information as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(type_information)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).presentation as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(presentation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).partition as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(partition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).group_data as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(group_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).entity_factory as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(entity_factory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).topic_data as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(topic_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).durability as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(durability)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).durability_service as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(durability_service)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).deadline as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(deadline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).latency_budget as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(latency_budget)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).liveliness as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(liveliness)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).reliability as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(reliability)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).destination_order as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(destination_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).history as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(history)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).resource_limits as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(resource_limits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).transport_priority as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(transport_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).lifespan as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(lifespan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).user_data as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).ownership as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(ownership)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).ownership_strength as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(ownership_strength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).time_based_filter as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(time_based_filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).writer_data_lifecycle as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(writer_data_lifecycle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).reader_data_lifecycle as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(reader_data_lifecycle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).subscription_keys as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(subscription_keys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).reader_lifespan as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(reader_lifespan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).ignorelocal as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(ignorelocal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).property as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(property)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).type_consistency as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(type_consistency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).ignore_locator_type as *const _ as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(ignore_locator_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).data_representation as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(data_representation)
        )
    );
}
impl Default for dds_qos {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type ddsi_typeid_t = ddsi_typeid;
pub type ddsi_typeinfo_t = ddsi_typeinfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddsi_typemap {
    _unused: [u8; 0],
}
pub type ddsi_typemap_t = ddsi_typemap;
pub const ddsi_typeid_kind_DDSI_TYPEID_KIND_MINIMAL: ddsi_typeid_kind = 0;
pub const ddsi_typeid_kind_DDSI_TYPEID_KIND_COMPLETE: ddsi_typeid_kind = 1;
pub const ddsi_typeid_kind_DDSI_TYPEID_KIND_PLAIN_COLLECTION_MINIMAL: ddsi_typeid_kind = 2;
pub const ddsi_typeid_kind_DDSI_TYPEID_KIND_PLAIN_COLLECTION_COMPLETE: ddsi_typeid_kind = 3;
pub const ddsi_typeid_kind_DDSI_TYPEID_KIND_FULLY_DESCRIPTIVE: ddsi_typeid_kind = 4;
pub type ddsi_typeid_kind = ::std::os::raw::c_uint;
pub use self::ddsi_typeid_kind as ddsi_typeid_kind_t;
#[doc = " @anchor ddsi_sertype"]
#[doc = " @brief DDSI sertype"]
#[doc = " @ingroup dds"]
#[doc = " DOC_TODO"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddsi_sertype {
    pub ops: *const ddsi_sertype_ops,
    pub serdata_ops: *const ddsi_serdata_ops,
    pub serdata_basehash: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub allowed_data_representation: u32,
    pub type_name: *mut ::std::os::raw::c_char,
    pub gv: ddsrt_atomic_voidp_t,
    pub flags_refc: ddsrt_atomic_uint32_t,
    pub base_sertype: *const ddsi_sertype,
    pub wrapped_sertopic: *mut ::std::os::raw::c_void,
    pub iox_size: u32,
}
#[test]
fn bindgen_test_layout_ddsi_sertype() {
    assert_eq!(
        ::std::mem::size_of::<ddsi_sertype>(),
        80usize,
        concat!("Size of: ", stringify!(ddsi_sertype))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsi_sertype>(),
        8usize,
        concat!("Alignment of ", stringify!(ddsi_sertype))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype>())).ops as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype>())).serdata_ops as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype),
            "::",
            stringify!(serdata_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype>())).serdata_basehash as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype),
            "::",
            stringify!(serdata_basehash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ddsi_sertype>())).allowed_data_representation as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype),
            "::",
            stringify!(allowed_data_representation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype>())).type_name as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype>())).gv as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype),
            "::",
            stringify!(gv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype>())).flags_refc as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype),
            "::",
            stringify!(flags_refc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype>())).base_sertype as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype),
            "::",
            stringify!(base_sertype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype>())).wrapped_sertopic as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype),
            "::",
            stringify!(wrapped_sertopic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype>())).iox_size as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype),
            "::",
            stringify!(iox_size)
        )
    );
}
impl Default for ddsi_sertype {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ddsi_sertype {
    #[inline]
    pub fn typekind_no_key(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_typekind_no_key(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_keyhash(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_keyhash(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fixed_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fixed_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        typekind_no_key: u32,
        request_keyhash: u32,
        fixed_size: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let typekind_no_key: u32 = unsafe { ::std::mem::transmute(typekind_no_key) };
            typekind_no_key as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let request_keyhash: u32 = unsafe { ::std::mem::transmute(request_keyhash) };
            request_keyhash as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let fixed_size: u32 = unsafe { ::std::mem::transmute(fixed_size) };
            fixed_size as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ddsi_sertype_equal_t = ::std::option::Option<
    unsafe extern "C" fn(a: *const ddsi_sertype, b: *const ddsi_sertype) -> bool,
>;
pub type ddsi_sertype_hash_t =
    ::std::option::Option<unsafe extern "C" fn(tp: *const ddsi_sertype) -> u32>;
pub type ddsi_sertype_free_t = ::std::option::Option<unsafe extern "C" fn(tp: *mut ddsi_sertype)>;
pub type ddsi_sertype_zero_samples_t = ::std::option::Option<
    unsafe extern "C" fn(
        d: *const ddsi_sertype,
        samples: *mut ::std::os::raw::c_void,
        count: size_t,
    ),
>;
pub type ddsi_sertype_realloc_samples_t = ::std::option::Option<
    unsafe extern "C" fn(
        ptrs: *mut *mut ::std::os::raw::c_void,
        d: *const ddsi_sertype,
        old: *mut ::std::os::raw::c_void,
        oldcount: size_t,
        count: size_t,
    ),
>;
pub type ddsi_sertype_free_samples_t = ::std::option::Option<
    unsafe extern "C" fn(
        d: *const ddsi_sertype,
        ptrs: *mut *mut ::std::os::raw::c_void,
        count: size_t,
        op: dds_free_op_t,
    ),
>;
pub type ddsi_sertype_typeid_t = ::std::option::Option<
    unsafe extern "C" fn(tp: *const ddsi_sertype, kind: ddsi_typeid_kind_t) -> *mut ddsi_typeid_t,
>;
pub type ddsi_sertype_get_serialized_size_t = ::std::option::Option<
    unsafe extern "C" fn(d: *const ddsi_sertype, sample: *const ::std::os::raw::c_void) -> size_t,
>;
pub type ddsi_sertype_serialize_into_t = ::std::option::Option<
    unsafe extern "C" fn(
        d: *const ddsi_sertype,
        sample: *const ::std::os::raw::c_void,
        dst_buffer: *mut ::std::os::raw::c_void,
        dst_size: size_t,
    ) -> bool,
>;
pub type ddsi_sertype_typemap_t =
    ::std::option::Option<unsafe extern "C" fn(tp: *const ddsi_sertype) -> *mut ddsi_typemap_t>;
pub type ddsi_sertype_typeinfo_t =
    ::std::option::Option<unsafe extern "C" fn(tp: *const ddsi_sertype) -> *mut ddsi_typeinfo_t>;
pub type ddsi_sertype_derive_t = ::std::option::Option<
    unsafe extern "C" fn(
        sertype: *const ddsi_sertype,
        data_representation: dds_data_representation_id_t,
        tce_qos: dds_type_consistency_enforcement_qospolicy_t,
    ) -> *mut ddsi_sertype,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddsi_sertype_v0 {
    _unused: [u8; 0],
}
pub type ddsi_sertype_v0_t =
    ::std::option::Option<unsafe extern "C" fn(dummy: *mut ddsi_sertype_v0)>;
extern "C" {
    pub fn ddsi_sertype_v0(dummy: *mut ddsi_sertype_v0);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddsi_sertype_ops {
    pub version: ddsi_sertype_v0_t,
    pub arg: *mut ::std::os::raw::c_void,
    pub free: ddsi_sertype_free_t,
    pub zero_samples: ddsi_sertype_zero_samples_t,
    pub realloc_samples: ddsi_sertype_realloc_samples_t,
    pub free_samples: ddsi_sertype_free_samples_t,
    pub equal: ddsi_sertype_equal_t,
    pub hash: ddsi_sertype_hash_t,
    pub type_id: ddsi_sertype_typeid_t,
    pub type_map: ddsi_sertype_typemap_t,
    pub type_info: ddsi_sertype_typeinfo_t,
    pub derive_sertype: ddsi_sertype_derive_t,
    pub get_serialized_size: ddsi_sertype_get_serialized_size_t,
    pub serialize_into: ddsi_sertype_serialize_into_t,
}
#[test]
fn bindgen_test_layout_ddsi_sertype_ops() {
    assert_eq!(
        ::std::mem::size_of::<ddsi_sertype_ops>(),
        112usize,
        concat!("Size of: ", stringify!(ddsi_sertype_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsi_sertype_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(ddsi_sertype_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype_ops>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype_ops>())).arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype_ops>())).free as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype_ops>())).zero_samples as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(zero_samples)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ddsi_sertype_ops>())).realloc_samples as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(realloc_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype_ops>())).free_samples as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(free_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype_ops>())).equal as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(equal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype_ops>())).hash as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype_ops>())).type_id as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(type_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype_ops>())).type_map as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(type_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype_ops>())).type_info as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(type_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype_ops>())).derive_sertype as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(derive_sertype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ddsi_sertype_ops>())).get_serialized_size as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(get_serialized_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype_ops>())).serialize_into as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(serialize_into)
        )
    );
}
impl Default for ddsi_sertype_ops {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn ddsi_sertype_init(
        tp: *mut ddsi_sertype,
        type_name: *const ::std::os::raw::c_char,
        sertype_ops: *const ddsi_sertype_ops,
        serdata_ops: *const ddsi_serdata_ops,
        topickind_no_key: bool,
    );
}
extern "C" {
    pub fn ddsi_sertype_fini(tp: *mut ddsi_sertype);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ddsi_keyhash {
    pub value: [::std::os::raw::c_uchar; 16usize],
}
#[test]
fn bindgen_test_layout_ddsi_keyhash() {
    assert_eq!(
        ::std::mem::size_of::<ddsi_keyhash>(),
        16usize,
        concat!("Size of: ", stringify!(ddsi_keyhash))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsi_keyhash>(),
        1usize,
        concat!("Alignment of ", stringify!(ddsi_keyhash))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_keyhash>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_keyhash),
            "::",
            stringify!(value)
        )
    );
}
pub type ddsi_keyhash_t = ddsi_keyhash;
pub const ddsi_serdata_kind_SDK_EMPTY: ddsi_serdata_kind = 0;
pub const ddsi_serdata_kind_SDK_KEY: ddsi_serdata_kind = 1;
pub const ddsi_serdata_kind_SDK_DATA: ddsi_serdata_kind = 2;
pub type ddsi_serdata_kind = ::std::os::raw::c_uint;
#[doc = " @anchor ddsi_serdata"]
#[doc = " @brief DDSI Serdata"]
#[doc = " @ingroup dds"]
#[doc = " DOC_TODO"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddsi_serdata {
    pub ops: *const ddsi_serdata_ops,
    pub hash: u32,
    pub refc: ddsrt_atomic_uint32_t,
    pub kind: ddsi_serdata_kind,
    pub type_: *const ddsi_sertype,
    pub timestamp: ddsrt_wctime_t,
    pub statusinfo: u32,
    pub twrite: ddsrt_mtime_t,
    pub iox_chunk: *mut ::std::os::raw::c_void,
    pub iox_subscriber: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ddsi_serdata() {
    assert_eq!(
        ::std::mem::size_of::<ddsi_serdata>(),
        72usize,
        concat!("Size of: ", stringify!(ddsi_serdata))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsi_serdata>(),
        8usize,
        concat!("Alignment of ", stringify!(ddsi_serdata))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata>())).ops as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata>())).hash as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata>())).refc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata),
            "::",
            stringify!(refc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata>())).kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata>())).type_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata>())).timestamp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata>())).statusinfo as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata),
            "::",
            stringify!(statusinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata>())).twrite as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata),
            "::",
            stringify!(twrite)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata>())).iox_chunk as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata),
            "::",
            stringify!(iox_chunk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata>())).iox_subscriber as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata),
            "::",
            stringify!(iox_subscriber)
        )
    );
}
impl Default for ddsi_serdata {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type ddsi_serdata_size_t =
    ::std::option::Option<unsafe extern "C" fn(d: *const ddsi_serdata) -> u32>;
pub type ddsi_serdata_free_t = ::std::option::Option<unsafe extern "C" fn(d: *mut ddsi_serdata)>;
pub type ddsi_serdata_from_ser_t = ::std::option::Option<
    unsafe extern "C" fn(
        type_: *const ddsi_sertype,
        kind: ddsi_serdata_kind,
        fragchain: *const nn_rdata,
        size: size_t,
    ) -> *mut ddsi_serdata,
>;
pub type ddsi_serdata_from_ser_iov_t = ::std::option::Option<
    unsafe extern "C" fn(
        type_: *const ddsi_sertype,
        kind: ddsi_serdata_kind,
        niov: ddsrt_msg_iovlen_t,
        iov: *const ddsrt_iovec_t,
        size: size_t,
    ) -> *mut ddsi_serdata,
>;
pub type ddsi_serdata_from_keyhash_t = ::std::option::Option<
    unsafe extern "C" fn(
        type_: *const ddsi_sertype,
        keyhash: *const ddsi_keyhash,
    ) -> *mut ddsi_serdata,
>;
pub type ddsi_serdata_from_sample_t = ::std::option::Option<
    unsafe extern "C" fn(
        type_: *const ddsi_sertype,
        kind: ddsi_serdata_kind,
        sample: *const ::std::os::raw::c_void,
    ) -> *mut ddsi_serdata,
>;
pub type ddsi_serdata_to_untyped_t =
    ::std::option::Option<unsafe extern "C" fn(d: *const ddsi_serdata) -> *mut ddsi_serdata>;
pub type ddsi_serdata_to_ser_t = ::std::option::Option<
    unsafe extern "C" fn(
        d: *const ddsi_serdata,
        off: size_t,
        sz: size_t,
        buf: *mut ::std::os::raw::c_void,
    ),
>;
pub type ddsi_serdata_to_ser_ref_t = ::std::option::Option<
    unsafe extern "C" fn(
        d: *const ddsi_serdata,
        off: size_t,
        sz: size_t,
        ref_: *mut ddsrt_iovec_t,
    ) -> *mut ddsi_serdata,
>;
pub type ddsi_serdata_to_ser_unref_t =
    ::std::option::Option<unsafe extern "C" fn(d: *mut ddsi_serdata, ref_: *const ddsrt_iovec_t)>;
pub type ddsi_serdata_to_sample_t = ::std::option::Option<
    unsafe extern "C" fn(
        d: *const ddsi_serdata,
        sample: *mut ::std::os::raw::c_void,
        bufptr: *mut *mut ::std::os::raw::c_void,
        buflim: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
pub type ddsi_serdata_untyped_to_sample_t = ::std::option::Option<
    unsafe extern "C" fn(
        type_: *const ddsi_sertype,
        d: *const ddsi_serdata,
        sample: *mut ::std::os::raw::c_void,
        bufptr: *mut *mut ::std::os::raw::c_void,
        buflim: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
pub type ddsi_serdata_eqkey_t = ::std::option::Option<
    unsafe extern "C" fn(a: *const ddsi_serdata, b: *const ddsi_serdata) -> bool,
>;
pub type ddsi_serdata_print_t = ::std::option::Option<
    unsafe extern "C" fn(
        type_: *const ddsi_sertype,
        d: *const ddsi_serdata,
        buf: *mut ::std::os::raw::c_char,
        size: size_t,
    ) -> size_t,
>;
pub type ddsi_serdata_get_keyhash_t = ::std::option::Option<
    unsafe extern "C" fn(d: *const ddsi_serdata, buf: *mut ddsi_keyhash, force_md5: bool),
>;
pub type ddsi_serdata_iox_size_t =
    ::std::option::Option<unsafe extern "C" fn(d: *const ddsi_serdata) -> u32>;
pub type ddsi_serdata_from_iox_t = ::std::option::Option<
    unsafe extern "C" fn(
        type_: *const ddsi_sertype,
        kind: ddsi_serdata_kind,
        sub: *mut ::std::os::raw::c_void,
        buffer: *mut ::std::os::raw::c_void,
    ) -> *mut ddsi_serdata,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ddsi_serdata_ops {
    pub eqkey: ddsi_serdata_eqkey_t,
    pub get_size: ddsi_serdata_size_t,
    pub from_ser: ddsi_serdata_from_ser_t,
    pub from_ser_iov: ddsi_serdata_from_ser_iov_t,
    pub from_keyhash: ddsi_serdata_from_keyhash_t,
    pub from_sample: ddsi_serdata_from_sample_t,
    pub to_ser: ddsi_serdata_to_ser_t,
    pub to_ser_ref: ddsi_serdata_to_ser_ref_t,
    pub to_ser_unref: ddsi_serdata_to_ser_unref_t,
    pub to_sample: ddsi_serdata_to_sample_t,
    pub to_untyped: ddsi_serdata_to_untyped_t,
    pub untyped_to_sample: ddsi_serdata_untyped_to_sample_t,
    pub free: ddsi_serdata_free_t,
    pub print: ddsi_serdata_print_t,
    pub get_keyhash: ddsi_serdata_get_keyhash_t,
    pub get_sample_size: ddsi_serdata_iox_size_t,
    pub from_iox_buffer: ddsi_serdata_from_iox_t,
}
#[test]
fn bindgen_test_layout_ddsi_serdata_ops() {
    assert_eq!(
        ::std::mem::size_of::<ddsi_serdata_ops>(),
        136usize,
        concat!("Size of: ", stringify!(ddsi_serdata_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsi_serdata_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(ddsi_serdata_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).eqkey as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(eqkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).get_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(get_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).from_ser as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(from_ser)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).from_ser_iov as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(from_ser_iov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).from_keyhash as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(from_keyhash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).from_sample as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(from_sample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).to_ser as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(to_ser)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).to_ser_ref as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(to_ser_ref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).to_ser_unref as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(to_ser_unref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).to_sample as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(to_sample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).to_untyped as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(to_untyped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ddsi_serdata_ops>())).untyped_to_sample as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(untyped_to_sample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).free as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).print as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(print)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).get_keyhash as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(get_keyhash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ddsi_serdata_ops>())).get_sample_size as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(get_sample_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ddsi_serdata_ops>())).from_iox_buffer as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(from_iox_buffer)
        )
    );
}
extern "C" {
    pub fn ddsi_serdata_init(
        d: *mut ddsi_serdata,
        type_: *const ddsi_sertype,
        kind: ddsi_serdata_kind,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_rbuf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nn_rmsg_chunk {
    pub rbuf: *mut nn_rbuf,
    pub next: *mut nn_rmsg_chunk,
    pub u: nn_rmsg_chunk__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nn_rmsg_chunk__bindgen_ty_1 {
    pub size: u32,
    pub l: i64,
    pub d: f64,
    pub p: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_nn_rmsg_chunk__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<nn_rmsg_chunk__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(nn_rmsg_chunk__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<nn_rmsg_chunk__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(nn_rmsg_chunk__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nn_rmsg_chunk__bindgen_ty_1>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rmsg_chunk__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rmsg_chunk__bindgen_ty_1>())).l as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rmsg_chunk__bindgen_ty_1),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rmsg_chunk__bindgen_ty_1>())).d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rmsg_chunk__bindgen_ty_1),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rmsg_chunk__bindgen_ty_1>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rmsg_chunk__bindgen_ty_1),
            "::",
            stringify!(p)
        )
    );
}
impl Default for nn_rmsg_chunk__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_nn_rmsg_chunk() {
    assert_eq!(
        ::std::mem::size_of::<nn_rmsg_chunk>(),
        24usize,
        concat!("Size of: ", stringify!(nn_rmsg_chunk))
    );
    assert_eq!(
        ::std::mem::align_of::<nn_rmsg_chunk>(),
        8usize,
        concat!("Alignment of ", stringify!(nn_rmsg_chunk))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rmsg_chunk>())).rbuf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rmsg_chunk),
            "::",
            stringify!(rbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rmsg_chunk>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rmsg_chunk),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rmsg_chunk>())).u as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rmsg_chunk),
            "::",
            stringify!(u)
        )
    );
}
impl Default for nn_rmsg_chunk {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nn_rmsg {
    pub refcount: ddsrt_atomic_uint32_t,
    pub lastchunk: *mut nn_rmsg_chunk,
    pub trace: bool,
    pub chunk: nn_rmsg_chunk,
}
#[test]
fn bindgen_test_layout_nn_rmsg() {
    assert_eq!(
        ::std::mem::size_of::<nn_rmsg>(),
        48usize,
        concat!("Size of: ", stringify!(nn_rmsg))
    );
    assert_eq!(
        ::std::mem::align_of::<nn_rmsg>(),
        8usize,
        concat!("Alignment of ", stringify!(nn_rmsg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rmsg>())).refcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rmsg),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rmsg>())).lastchunk as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rmsg),
            "::",
            stringify!(lastchunk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rmsg>())).trace as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rmsg),
            "::",
            stringify!(trace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rmsg>())).chunk as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rmsg),
            "::",
            stringify!(chunk)
        )
    );
}
impl Default for nn_rmsg {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_rdata {
    pub rmsg: *mut nn_rmsg,
    pub nextfrag: *mut nn_rdata,
    pub min: u32,
    pub maxp1: u32,
    pub submsg_zoff: u16,
    pub payload_zoff: u16,
    pub keyhash_zoff: u16,
    pub refcount_bias_added: ddsrt_atomic_uint32_t,
}
#[test]
fn bindgen_test_layout_nn_rdata() {
    assert_eq!(
        ::std::mem::size_of::<nn_rdata>(),
        40usize,
        concat!("Size of: ", stringify!(nn_rdata))
    );
    assert_eq!(
        ::std::mem::align_of::<nn_rdata>(),
        8usize,
        concat!("Alignment of ", stringify!(nn_rdata))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rdata>())).rmsg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rdata),
            "::",
            stringify!(rmsg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rdata>())).nextfrag as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rdata),
            "::",
            stringify!(nextfrag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rdata>())).min as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rdata),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rdata>())).maxp1 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rdata),
            "::",
            stringify!(maxp1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rdata>())).submsg_zoff as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rdata),
            "::",
            stringify!(submsg_zoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rdata>())).payload_zoff as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rdata),
            "::",
            stringify!(payload_zoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rdata>())).keyhash_zoff as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rdata),
            "::",
            stringify!(keyhash_zoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rdata>())).refcount_bias_added as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rdata),
            "::",
            stringify!(refcount_bias_added)
        )
    );
}
impl Default for nn_rdata {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type ddsrt_md5_byte_t = ::std::os::raw::c_uchar;
pub type ddsrt_md5_word_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ddsrt_md5_state_s {
    pub count: [ddsrt_md5_word_t; 2usize],
    pub abcd: [ddsrt_md5_word_t; 4usize],
    pub buf: [ddsrt_md5_byte_t; 64usize],
}
#[test]
fn bindgen_test_layout_ddsrt_md5_state_s() {
    assert_eq!(
        ::std::mem::size_of::<ddsrt_md5_state_s>(),
        88usize,
        concat!("Size of: ", stringify!(ddsrt_md5_state_s))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsrt_md5_state_s>(),
        4usize,
        concat!("Alignment of ", stringify!(ddsrt_md5_state_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsrt_md5_state_s>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsrt_md5_state_s),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsrt_md5_state_s>())).abcd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsrt_md5_state_s),
            "::",
            stringify!(abcd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsrt_md5_state_s>())).buf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsrt_md5_state_s),
            "::",
            stringify!(buf)
        )
    );
}
impl Default for ddsrt_md5_state_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type ddsrt_md5_state_t = ddsrt_md5_state_s;
extern "C" {
    pub fn ddsrt_md5_init(pms: *mut ddsrt_md5_state_t);
}
extern "C" {
    pub fn ddsrt_md5_append(
        pms: *mut ddsrt_md5_state_t,
        data: *const ddsrt_md5_byte_t,
        nbytes: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn ddsrt_md5_finish(pms: *mut ddsrt_md5_state_t, digest: *mut ddsrt_md5_byte_t);
}
pub const ddsi_shm_loglevel_DDSI_SHM_OFF: ddsi_shm_loglevel = 0;
pub const ddsi_shm_loglevel_DDSI_SHM_FATAL: ddsi_shm_loglevel = 1;
pub const ddsi_shm_loglevel_DDSI_SHM_ERROR: ddsi_shm_loglevel = 2;
pub const ddsi_shm_loglevel_DDSI_SHM_WARN: ddsi_shm_loglevel = 3;
pub const ddsi_shm_loglevel_DDSI_SHM_INFO: ddsi_shm_loglevel = 4;
pub const ddsi_shm_loglevel_DDSI_SHM_DEBUG: ddsi_shm_loglevel = 5;
pub const ddsi_shm_loglevel_DDSI_SHM_VERBOSE: ddsi_shm_loglevel = 6;
pub type ddsi_shm_loglevel = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpp2c_Publisher {
    _unused: [u8; 0],
}
#[doc = " @brief publisher handle"]
pub type iox_pub_t = *mut cpp2c_Publisher;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpp2c_Subscriber {
    _unused: [u8; 0],
}
#[doc = " @brief Subscriber handle"]
pub type iox_sub_t = *mut cpp2c_Subscriber;
pub const iox_shm_data_state_t_IOX_CHUNK_UNINITIALIZED: iox_shm_data_state_t = 0;
pub const iox_shm_data_state_t_IOX_CHUNK_CONTAINS_RAW_DATA: iox_shm_data_state_t = 1;
pub const iox_shm_data_state_t_IOX_CHUNK_CONTAINS_SERIALIZED_DATA: iox_shm_data_state_t = 2;
pub type iox_shm_data_state_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iceoryx_header {
    pub guid: ddsi_guid,
    pub tstamp: dds_time_t,
    pub statusinfo: u32,
    pub data_size: u32,
    pub data_kind: ::std::os::raw::c_uchar,
    pub keyhash: ddsi_keyhash_t,
    pub shm_data_state: iox_shm_data_state_t,
}
#[test]
fn bindgen_test_layout_iceoryx_header() {
    assert_eq!(
        ::std::mem::size_of::<iceoryx_header>(),
        56usize,
        concat!("Size of: ", stringify!(iceoryx_header))
    );
    assert_eq!(
        ::std::mem::align_of::<iceoryx_header>(),
        8usize,
        concat!("Alignment of ", stringify!(iceoryx_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iceoryx_header>())).guid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iceoryx_header),
            "::",
            stringify!(guid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iceoryx_header>())).tstamp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(iceoryx_header),
            "::",
            stringify!(tstamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iceoryx_header>())).statusinfo as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(iceoryx_header),
            "::",
            stringify!(statusinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iceoryx_header>())).data_size as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(iceoryx_header),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iceoryx_header>())).data_kind as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(iceoryx_header),
            "::",
            stringify!(data_kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iceoryx_header>())).keyhash as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(iceoryx_header),
            "::",
            stringify!(keyhash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iceoryx_header>())).shm_data_state as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(iceoryx_header),
            "::",
            stringify!(shm_data_state)
        )
    );
}
impl Default for iceoryx_header {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type iceoryx_header_t = iceoryx_header;
extern "C" {
    pub fn shm_lock_iox_sub(sub: iox_sub_t);
}
extern "C" {
    pub fn shm_unlock_iox_sub(sub: iox_sub_t);
}
extern "C" {
    pub fn free_iox_chunk(iox_sub: *mut iox_sub_t, iox_chunk: *mut *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn iceoryx_header_from_chunk(
        iox_chunk: *const ::std::os::raw::c_void,
    ) -> *mut iceoryx_header_t;
}
extern "C" {
    pub fn shm_set_loglevel(arg1: ddsi_shm_loglevel);
}
extern "C" {
    pub fn shm_create_chunk(iox_pub: iox_pub_t, size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn shm_set_data_state(
        iox_chunk: *mut ::std::os::raw::c_void,
        data_state: iox_shm_data_state_t,
    );
}
extern "C" {
    pub fn shm_get_data_state(iox_chunk: *mut ::std::os::raw::c_void) -> iox_shm_data_state_t;
}
extern "C" {
    #[doc = " @ingroup loan"]
    #[doc = " @brief Check if a Loan is available to reader/writer"]
    #[doc = " The loan is available if the shared memory is enabled and all the constraints"]
    #[doc = " to enable shared memory are met and the type is fixed"]
    #[doc = " @note dds_loan_sample can be used if and only if"]
    #[doc = " dds_is_loan_available returns true."]
    #[doc = ""]
    #[doc = " @param[in] entity the handle of the entity"]
    #[doc = ""]
    #[doc = " @returns loan available or not"]
    pub fn dds_is_loan_available(entity: dds_entity_t) -> bool;
}
extern "C" {
    #[doc = " @ingroup loan"]
    #[doc = " @brief Check if a shared memory is available to reader/writer."]
    #[doc = ""]
    #[doc = " @note dds_loan_shared_memory_buffer can be used if and only if"]
    #[doc = " dds_is_shared_memory_available returns true."]
    #[doc = ""]
    #[doc = " @param[in] entity the handle of the entity"]
    #[doc = ""]
    #[doc = " @returns true if shared memory is available, false otherwise"]
    pub fn dds_is_shared_memory_available(entity: dds_entity_t) -> bool;
}
extern "C" {
    #[doc = " @ingroup loan"]
    #[doc = " @brief Loan a shared memory buffer of a specific size from the writer."]
    #[doc = ""]
    #[doc = " @note Currently this function is to be used with dds_writecdr by adding the"]
    #[doc = " loaned buffer to serdata as iox_chunk."]
    #[doc = " @note The function can only be used if dds_is_shared_memory_available is"]
    #[doc = "       true for the writer."]
    #[doc = ""]
    #[doc = " @param[in] writer the writer to loan the buffer from"]
    #[doc = " @param[in] size the requested buffer size"]
    #[doc = " @param[out] buffer the loaned buffer"]
    #[doc = ""]
    #[doc = " @returns DDS_RETCODE_OK if successful, DDS_RETCODE_ERROR otherwise"]
    pub fn dds_loan_shared_memory_buffer(
        writer: dds_entity_t,
        size: size_t,
        buffer: *mut *mut ::std::os::raw::c_void,
    ) -> dds_return_t;
}
extern "C" {
    #[doc = " @ingroup loan"]
    #[doc = " @brief Loan a sample from the writer."]
    #[doc = ""]
    #[doc = " @note This function is to be used with dds_write to publish the loaned"]
    #[doc = " sample."]
    #[doc = " @note The function can only be used if dds_is_loan_available is"]
    #[doc = "       true for the writer."]
    #[doc = ""]
    #[doc = " @param[in] writer the writer to loan the buffer from"]
    #[doc = " @param[out] sample the loaned sample"]
    #[doc = ""]
    #[doc = " @returns DDS_RETCODE_OK if successful, DDS_RETCODE_ERROR otherwise"]
    pub fn dds_loan_sample(
        writer: dds_entity_t,
        sample: *mut *mut ::std::os::raw::c_void,
    ) -> dds_return_t;
}
extern "C" {
    pub fn _dummy(status: dds_status_id_t);
}
extern "C" {
    pub fn ddsi_serdata_addref(serdata_const: *const ddsi_serdata) -> *mut ddsi_serdata;
}
extern "C" {
    pub fn ddsi_serdata_removeref(serdata: *mut ddsi_serdata);
}
pub const BUILTIN_TOPIC_DCPSPARTICIPANT: ::std::os::raw::c_int = 2147418113;
pub const BUILTIN_TOPIC_DCPSTOPIC: ::std::os::raw::c_int = 2147418114;
pub const BUILTIN_TOPIC_DCPSPUBLICATION: ::std::os::raw::c_int = 2147418115;
pub const BUILTIN_TOPIC_DCPSSUBSCRIPTION: ::std::os::raw::c_int = 2147418116;

/* automatically generated by rust-bindgen 0.55.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub type size_t = ::std::os::raw::c_ulong;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type dds_entity_t = i32;
pub type dds_time_t = i64;
pub type dds_duration_t = i64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ddsrt_mtime_t {
    pub v: dds_time_t,
}
#[test]
fn bindgen_test_layout_ddsrt_mtime_t() {
    assert_eq!(
        ::std::mem::size_of::<ddsrt_mtime_t>(),
        8usize,
        concat!("Size of: ", stringify!(ddsrt_mtime_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsrt_mtime_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ddsrt_mtime_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsrt_mtime_t>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsrt_mtime_t),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ddsrt_wctime_t {
    pub v: dds_time_t,
}
#[test]
fn bindgen_test_layout_ddsrt_wctime_t() {
    assert_eq!(
        ::std::mem::size_of::<ddsrt_wctime_t>(),
        8usize,
        concat!("Size of: ", stringify!(ddsrt_wctime_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsrt_wctime_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ddsrt_wctime_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsrt_wctime_t>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsrt_wctime_t),
            "::",
            stringify!(v)
        )
    );
}
pub type dds_return_t = i32;
pub const dds_free_op_t_DDS_FREE_ALL: dds_free_op_t = 7;
pub const dds_free_op_t_DDS_FREE_CONTENTS: dds_free_op_t = 3;
pub const dds_free_op_t_DDS_FREE_KEY: dds_free_op_t = 1;
pub type dds_free_op_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn dds_alloc(size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dds_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dds_realloc_zero(
        ptr: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dds_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn dds_string_alloc(size: size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dds_string_dup(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dds_string_free(str_: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn dds_sample_free(
        sample: *mut ::std::os::raw::c_void,
        desc: *const dds_topic_descriptor,
        op: dds_free_op_t,
    );
}
pub const dds_stream_opcode_DDS_OP_RTS: dds_stream_opcode = 0;
pub const dds_stream_opcode_DDS_OP_ADR: dds_stream_opcode = 16777216;
pub const dds_stream_opcode_DDS_OP_JSR: dds_stream_opcode = 33554432;
pub const dds_stream_opcode_DDS_OP_JEQ: dds_stream_opcode = 50331648;
pub const dds_stream_opcode_DDS_OP_DLC: dds_stream_opcode = 67108864;
pub const dds_stream_opcode_DDS_OP_PLC: dds_stream_opcode = 83886080;
pub const dds_stream_opcode_DDS_OP_PLM: dds_stream_opcode = 100663296;
pub const dds_stream_opcode_DDS_OP_KOF: dds_stream_opcode = 117440512;
pub const dds_stream_opcode_DDS_OP_JEQ4: dds_stream_opcode = 134217728;
pub type dds_stream_opcode = ::std::os::raw::c_uint;
pub const dds_stream_typecode_DDS_OP_VAL_1BY: dds_stream_typecode = 1;
pub const dds_stream_typecode_DDS_OP_VAL_2BY: dds_stream_typecode = 2;
pub const dds_stream_typecode_DDS_OP_VAL_4BY: dds_stream_typecode = 3;
pub const dds_stream_typecode_DDS_OP_VAL_8BY: dds_stream_typecode = 4;
pub const dds_stream_typecode_DDS_OP_VAL_STR: dds_stream_typecode = 5;
pub const dds_stream_typecode_DDS_OP_VAL_BST: dds_stream_typecode = 6;
pub const dds_stream_typecode_DDS_OP_VAL_SEQ: dds_stream_typecode = 7;
pub const dds_stream_typecode_DDS_OP_VAL_ARR: dds_stream_typecode = 8;
pub const dds_stream_typecode_DDS_OP_VAL_UNI: dds_stream_typecode = 9;
pub const dds_stream_typecode_DDS_OP_VAL_STU: dds_stream_typecode = 10;
pub const dds_stream_typecode_DDS_OP_VAL_BSQ: dds_stream_typecode = 11;
pub const dds_stream_typecode_DDS_OP_VAL_ENU: dds_stream_typecode = 12;
pub const dds_stream_typecode_DDS_OP_VAL_EXT: dds_stream_typecode = 13;
pub const dds_stream_typecode_DDS_OP_VAL_BLN: dds_stream_typecode = 14;
pub const dds_stream_typecode_DDS_OP_VAL_BMK: dds_stream_typecode = 15;
pub type dds_stream_typecode = ::std::os::raw::c_uint;
pub const dds_stream_typecode_primary_DDS_OP_TYPE_1BY: dds_stream_typecode_primary = 65536;
pub const dds_stream_typecode_primary_DDS_OP_TYPE_2BY: dds_stream_typecode_primary = 131072;
pub const dds_stream_typecode_primary_DDS_OP_TYPE_4BY: dds_stream_typecode_primary = 196608;
pub const dds_stream_typecode_primary_DDS_OP_TYPE_8BY: dds_stream_typecode_primary = 262144;
pub const dds_stream_typecode_primary_DDS_OP_TYPE_STR: dds_stream_typecode_primary = 327680;
pub const dds_stream_typecode_primary_DDS_OP_TYPE_BST: dds_stream_typecode_primary = 393216;
pub const dds_stream_typecode_primary_DDS_OP_TYPE_SEQ: dds_stream_typecode_primary = 458752;
pub const dds_stream_typecode_primary_DDS_OP_TYPE_ARR: dds_stream_typecode_primary = 524288;
pub const dds_stream_typecode_primary_DDS_OP_TYPE_UNI: dds_stream_typecode_primary = 589824;
pub const dds_stream_typecode_primary_DDS_OP_TYPE_STU: dds_stream_typecode_primary = 655360;
pub const dds_stream_typecode_primary_DDS_OP_TYPE_BSQ: dds_stream_typecode_primary = 720896;
pub const dds_stream_typecode_primary_DDS_OP_TYPE_ENU: dds_stream_typecode_primary = 786432;
pub const dds_stream_typecode_primary_DDS_OP_TYPE_EXT: dds_stream_typecode_primary = 851968;
pub const dds_stream_typecode_primary_DDS_OP_TYPE_BLN: dds_stream_typecode_primary = 917504;
pub const dds_stream_typecode_primary_DDS_OP_TYPE_BMK: dds_stream_typecode_primary = 983040;
pub type dds_stream_typecode_primary = ::std::os::raw::c_uint;
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_1BY: dds_stream_typecode_subtype = 256;
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_2BY: dds_stream_typecode_subtype = 512;
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_4BY: dds_stream_typecode_subtype = 768;
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_8BY: dds_stream_typecode_subtype = 1024;
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_STR: dds_stream_typecode_subtype = 1280;
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_BST: dds_stream_typecode_subtype = 1536;
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_SEQ: dds_stream_typecode_subtype = 1792;
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_ARR: dds_stream_typecode_subtype = 2048;
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_UNI: dds_stream_typecode_subtype = 2304;
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_STU: dds_stream_typecode_subtype = 2560;
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_BSQ: dds_stream_typecode_subtype = 2816;
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_ENU: dds_stream_typecode_subtype = 3072;
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_BLN: dds_stream_typecode_subtype = 3584;
pub const dds_stream_typecode_subtype_DDS_OP_SUBTYPE_BMK: dds_stream_typecode_subtype = 3840;
pub type dds_stream_typecode_subtype = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_sequence {
    pub _maximum: u32,
    pub _length: u32,
    pub _buffer: *mut u8,
    pub _release: bool,
}
#[test]
fn bindgen_test_layout_dds_sequence() {
    assert_eq!(
        ::std::mem::size_of::<dds_sequence>(),
        24usize,
        concat!("Size of: ", stringify!(dds_sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_sequence>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_sequence))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_sequence>()))._maximum as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sequence),
            "::",
            stringify!(_maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_sequence>()))._length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sequence),
            "::",
            stringify!(_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_sequence>()))._buffer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sequence),
            "::",
            stringify!(_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_sequence>()))._release as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sequence),
            "::",
            stringify!(_release)
        )
    );
}
impl Default for dds_sequence {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_sequence_t = dds_sequence;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_key_descriptor {
    pub m_name: *const ::std::os::raw::c_char,
    pub m_offset: u32,
    pub m_idx: u32,
}
#[test]
fn bindgen_test_layout_dds_key_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<dds_key_descriptor>(),
        16usize,
        concat!("Size of: ", stringify!(dds_key_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_key_descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_key_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_key_descriptor>())).m_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_key_descriptor),
            "::",
            stringify!(m_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_key_descriptor>())).m_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_key_descriptor),
            "::",
            stringify!(m_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_key_descriptor>())).m_idx as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_key_descriptor),
            "::",
            stringify!(m_idx)
        )
    );
}
impl Default for dds_key_descriptor {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_key_descriptor_t = dds_key_descriptor;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_type_meta_ser {
    pub data: *mut ::std::os::raw::c_uchar,
    pub sz: u32,
}
#[test]
fn bindgen_test_layout_dds_type_meta_ser() {
    assert_eq!(
        ::std::mem::size_of::<dds_type_meta_ser>(),
        16usize,
        concat!("Size of: ", stringify!(dds_type_meta_ser))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_type_meta_ser>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_type_meta_ser))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_type_meta_ser>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_type_meta_ser),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_type_meta_ser>())).sz as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_type_meta_ser),
            "::",
            stringify!(sz)
        )
    );
}
impl Default for dds_type_meta_ser {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_topic_descriptor {
    pub m_size: u32,
    pub m_align: u32,
    pub m_flagset: u32,
    pub m_nkeys: u32,
    pub m_typename: *const ::std::os::raw::c_char,
    pub m_keys: *const dds_key_descriptor_t,
    pub m_nops: u32,
    pub m_ops: *const u32,
    pub m_meta: *const ::std::os::raw::c_char,
    pub type_information: dds_type_meta_ser,
    pub type_mapping: dds_type_meta_ser,
    pub restrict_data_representation: u32,
}
#[test]
fn bindgen_test_layout_dds_topic_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<dds_topic_descriptor>(),
        96usize,
        concat!("Size of: ", stringify!(dds_topic_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_topic_descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_topic_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_topic_descriptor>())).m_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_topic_descriptor),
            "::",
            stringify!(m_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_topic_descriptor>())).m_align as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_topic_descriptor),
            "::",
            stringify!(m_align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_topic_descriptor>())).m_flagset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_topic_descriptor),
            "::",
            stringify!(m_flagset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_topic_descriptor>())).m_nkeys as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_topic_descriptor),
            "::",
            stringify!(m_nkeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_topic_descriptor>())).m_typename as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_topic_descriptor),
            "::",
            stringify!(m_typename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_topic_descriptor>())).m_keys as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_topic_descriptor),
            "::",
            stringify!(m_keys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_topic_descriptor>())).m_nops as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_topic_descriptor),
            "::",
            stringify!(m_nops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_topic_descriptor>())).m_ops as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_topic_descriptor),
            "::",
            stringify!(m_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_topic_descriptor>())).m_meta as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_topic_descriptor),
            "::",
            stringify!(m_meta)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_topic_descriptor>())).type_information as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_topic_descriptor),
            "::",
            stringify!(type_information)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_topic_descriptor>())).type_mapping as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_topic_descriptor),
            "::",
            stringify!(type_mapping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_topic_descriptor>())).restrict_data_representation
                as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_topic_descriptor),
            "::",
            stringify!(restrict_data_representation)
        )
    );
}
impl Default for dds_topic_descriptor {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_topic_descriptor_t = dds_topic_descriptor;
pub type dds_instance_handle_t = u64;
pub type dds_domainid_t = u32;
pub const dds_find_scope_DDS_FIND_SCOPE_GLOBAL: dds_find_scope = 0;
pub const dds_find_scope_DDS_FIND_SCOPE_LOCAL_DOMAIN: dds_find_scope = 1;
pub const dds_find_scope_DDS_FIND_SCOPE_PARTICIPANT: dds_find_scope = 2;
pub type dds_find_scope = ::std::os::raw::c_uint;
pub use self::dds_find_scope as dds_find_scope_t;
pub type dds_qos_t = dds_qos;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum dds_durability_kind {
    DDS_DURABILITY_VOLATILE = 0,
    DDS_DURABILITY_TRANSIENT_LOCAL = 1,
    DDS_DURABILITY_TRANSIENT = 2,
    DDS_DURABILITY_PERSISTENT = 3,
}
pub use self::dds_durability_kind as dds_durability_kind_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum dds_history_kind {
    DDS_HISTORY_KEEP_LAST = 0,
    DDS_HISTORY_KEEP_ALL = 1,
}
pub use self::dds_history_kind as dds_history_kind_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum dds_ownership_kind {
    DDS_OWNERSHIP_SHARED = 0,
    DDS_OWNERSHIP_EXCLUSIVE = 1,
}
pub use self::dds_ownership_kind as dds_ownership_kind_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum dds_liveliness_kind {
    DDS_LIVELINESS_AUTOMATIC = 0,
    DDS_LIVELINESS_MANUAL_BY_PARTICIPANT = 1,
    DDS_LIVELINESS_MANUAL_BY_TOPIC = 2,
}
pub use self::dds_liveliness_kind as dds_liveliness_kind_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum dds_reliability_kind {
    DDS_RELIABILITY_BEST_EFFORT = 0,
    DDS_RELIABILITY_RELIABLE = 1,
}
pub use self::dds_reliability_kind as dds_reliability_kind_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum dds_destination_order_kind {
    DDS_DESTINATIONORDER_BY_RECEPTION_TIMESTAMP = 0,
    DDS_DESTINATIONORDER_BY_SOURCE_TIMESTAMP = 1,
}
pub use self::dds_destination_order_kind as dds_destination_order_kind_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum dds_presentation_access_scope_kind {
    DDS_PRESENTATION_INSTANCE = 0,
    DDS_PRESENTATION_TOPIC = 1,
    DDS_PRESENTATION_GROUP = 2,
}
pub use self::dds_presentation_access_scope_kind as dds_presentation_access_scope_kind_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum dds_ignorelocal_kind {
    DDS_IGNORELOCAL_NONE = 0,
    DDS_IGNORELOCAL_PARTICIPANT = 1,
    DDS_IGNORELOCAL_PROCESS = 2,
}
pub use self::dds_ignorelocal_kind as dds_ignorelocal_kind_t;
pub const dds_type_consistency_kind_DDS_TYPE_CONSISTENCY_DISALLOW_TYPE_COERCION:
    dds_type_consistency_kind = 0;
pub const dds_type_consistency_kind_DDS_TYPE_CONSISTENCY_ALLOW_TYPE_COERCION:
    dds_type_consistency_kind = 1;
pub type dds_type_consistency_kind = ::std::os::raw::c_uint;
pub use self::dds_type_consistency_kind as dds_type_consistency_kind_t;
pub type dds_data_representation_id_t = i16;
extern "C" {
    pub fn dds_create_qos() -> *mut dds_qos_t;
}
extern "C" {
    pub fn dds_delete_qos(qos: *mut dds_qos_t);
}
extern "C" {
    pub fn dds_reset_qos(qos: *mut dds_qos_t);
}
extern "C" {
    pub fn dds_copy_qos(dst: *mut dds_qos_t, src: *const dds_qos_t) -> dds_return_t;
}
extern "C" {
    pub fn dds_merge_qos(dst: *mut dds_qos_t, src: *const dds_qos_t);
}
extern "C" {
    pub fn dds_qos_equal(a: *const dds_qos_t, b: *const dds_qos_t) -> bool;
}
extern "C" {
    pub fn dds_qset_userdata(qos: *mut dds_qos_t, value: *const ::std::os::raw::c_void, sz: size_t);
}
extern "C" {
    pub fn dds_qset_topicdata(
        qos: *mut dds_qos_t,
        value: *const ::std::os::raw::c_void,
        sz: size_t,
    );
}
extern "C" {
    pub fn dds_qset_groupdata(
        qos: *mut dds_qos_t,
        value: *const ::std::os::raw::c_void,
        sz: size_t,
    );
}
extern "C" {
    pub fn dds_qset_durability(qos: *mut dds_qos_t, kind: dds_durability_kind_t);
}
extern "C" {
    pub fn dds_qset_history(qos: *mut dds_qos_t, kind: dds_history_kind_t, depth: i32);
}
extern "C" {
    pub fn dds_qset_resource_limits(
        qos: *mut dds_qos_t,
        max_samples: i32,
        max_instances: i32,
        max_samples_per_instance: i32,
    );
}
extern "C" {
    pub fn dds_qset_presentation(
        qos: *mut dds_qos_t,
        access_scope: dds_presentation_access_scope_kind_t,
        coherent_access: bool,
        ordered_access: bool,
    );
}
extern "C" {
    pub fn dds_qset_lifespan(qos: *mut dds_qos_t, lifespan: dds_duration_t);
}
extern "C" {
    pub fn dds_qset_deadline(qos: *mut dds_qos_t, deadline: dds_duration_t);
}
extern "C" {
    pub fn dds_qset_latency_budget(qos: *mut dds_qos_t, duration: dds_duration_t);
}
extern "C" {
    pub fn dds_qset_ownership(qos: *mut dds_qos_t, kind: dds_ownership_kind_t);
}
extern "C" {
    pub fn dds_qset_ownership_strength(qos: *mut dds_qos_t, value: i32);
}
extern "C" {
    pub fn dds_qset_liveliness(
        qos: *mut dds_qos_t,
        kind: dds_liveliness_kind_t,
        lease_duration: dds_duration_t,
    );
}
extern "C" {
    pub fn dds_qset_time_based_filter(qos: *mut dds_qos_t, minimum_separation: dds_duration_t);
}
extern "C" {
    pub fn dds_qset_partition(qos: *mut dds_qos_t, n: u32, ps: *mut *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn dds_qset_partition1(qos: *mut dds_qos_t, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn dds_qset_reliability(
        qos: *mut dds_qos_t,
        kind: dds_reliability_kind_t,
        max_blocking_time: dds_duration_t,
    );
}
extern "C" {
    pub fn dds_qset_transport_priority(qos: *mut dds_qos_t, value: i32);
}
extern "C" {
    pub fn dds_qset_destination_order(qos: *mut dds_qos_t, kind: dds_destination_order_kind_t);
}
extern "C" {
    pub fn dds_qset_writer_data_lifecycle(qos: *mut dds_qos_t, autodispose: bool);
}
extern "C" {
    pub fn dds_qset_reader_data_lifecycle(
        qos: *mut dds_qos_t,
        autopurge_nowriter_samples_delay: dds_duration_t,
        autopurge_disposed_samples_delay: dds_duration_t,
    );
}
extern "C" {
    pub fn dds_qset_durability_service(
        qos: *mut dds_qos_t,
        service_cleanup_delay: dds_duration_t,
        history_kind: dds_history_kind_t,
        history_depth: i32,
        max_samples: i32,
        max_instances: i32,
        max_samples_per_instance: i32,
    );
}
extern "C" {
    pub fn dds_qset_ignorelocal(qos: *mut dds_qos_t, ignore: dds_ignorelocal_kind_t);
}
extern "C" {
    pub fn dds_qget_userdata(
        qos: *const dds_qos_t,
        value: *mut *mut ::std::os::raw::c_void,
        sz: *mut size_t,
    ) -> bool;
}
extern "C" {
    pub fn dds_qget_topicdata(
        qos: *const dds_qos_t,
        value: *mut *mut ::std::os::raw::c_void,
        sz: *mut size_t,
    ) -> bool;
}
extern "C" {
    pub fn dds_qget_groupdata(
        qos: *const dds_qos_t,
        value: *mut *mut ::std::os::raw::c_void,
        sz: *mut size_t,
    ) -> bool;
}
extern "C" {
    pub fn dds_qget_durability(qos: *const dds_qos_t, kind: *mut dds_durability_kind_t) -> bool;
}
extern "C" {
    pub fn dds_qget_history(
        qos: *const dds_qos_t,
        kind: *mut dds_history_kind_t,
        depth: *mut i32,
    ) -> bool;
}
extern "C" {
    pub fn dds_qget_resource_limits(
        qos: *const dds_qos_t,
        max_samples: *mut i32,
        max_instances: *mut i32,
        max_samples_per_instance: *mut i32,
    ) -> bool;
}
extern "C" {
    pub fn dds_qget_presentation(
        qos: *const dds_qos_t,
        access_scope: *mut dds_presentation_access_scope_kind_t,
        coherent_access: *mut bool,
        ordered_access: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn dds_qget_lifespan(qos: *const dds_qos_t, lifespan: *mut dds_duration_t) -> bool;
}
extern "C" {
    pub fn dds_qget_deadline(qos: *const dds_qos_t, deadline: *mut dds_duration_t) -> bool;
}
extern "C" {
    pub fn dds_qget_latency_budget(qos: *const dds_qos_t, duration: *mut dds_duration_t) -> bool;
}
extern "C" {
    pub fn dds_qget_ownership(qos: *const dds_qos_t, kind: *mut dds_ownership_kind_t) -> bool;
}
extern "C" {
    pub fn dds_qget_ownership_strength(qos: *const dds_qos_t, value: *mut i32) -> bool;
}
extern "C" {
    pub fn dds_qget_liveliness(
        qos: *const dds_qos_t,
        kind: *mut dds_liveliness_kind_t,
        lease_duration: *mut dds_duration_t,
    ) -> bool;
}
extern "C" {
    pub fn dds_qget_time_based_filter(
        qos: *const dds_qos_t,
        minimum_separation: *mut dds_duration_t,
    ) -> bool;
}
extern "C" {
    pub fn dds_qget_partition(
        qos: *const dds_qos_t,
        n: *mut u32,
        ps: *mut *mut *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn dds_qget_reliability(
        qos: *const dds_qos_t,
        kind: *mut dds_reliability_kind_t,
        max_blocking_time: *mut dds_duration_t,
    ) -> bool;
}
extern "C" {
    pub fn dds_qget_transport_priority(qos: *const dds_qos_t, value: *mut i32) -> bool;
}
extern "C" {
    pub fn dds_qget_destination_order(
        qos: *const dds_qos_t,
        kind: *mut dds_destination_order_kind_t,
    ) -> bool;
}
extern "C" {
    pub fn dds_qget_writer_data_lifecycle(qos: *const dds_qos_t, autodispose: *mut bool) -> bool;
}
extern "C" {
    pub fn dds_qget_durability_service(
        qos: *const dds_qos_t,
        service_cleanup_delay: *mut dds_duration_t,
        history_kind: *mut dds_history_kind_t,
        history_depth: *mut i32,
        max_samples: *mut i32,
        max_instances: *mut i32,
        max_samples_per_instance: *mut i32,
    ) -> bool;
}
extern "C" {
    pub fn dds_qget_ignorelocal(qos: *const dds_qos_t, ignore: *mut dds_ignorelocal_kind_t)
        -> bool;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_offered_deadline_missed_status {
    pub total_count: u32,
    pub total_count_change: i32,
    pub last_instance_handle: dds_instance_handle_t,
}
#[test]
fn bindgen_test_layout_dds_offered_deadline_missed_status() {
    assert_eq!(
        ::std::mem::size_of::<dds_offered_deadline_missed_status>(),
        16usize,
        concat!("Size of: ", stringify!(dds_offered_deadline_missed_status))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_offered_deadline_missed_status>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(dds_offered_deadline_missed_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_offered_deadline_missed_status>())).total_count as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_offered_deadline_missed_status),
            "::",
            stringify!(total_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_offered_deadline_missed_status>())).total_count_change
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_offered_deadline_missed_status),
            "::",
            stringify!(total_count_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_offered_deadline_missed_status>())).last_instance_handle
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_offered_deadline_missed_status),
            "::",
            stringify!(last_instance_handle)
        )
    );
}
pub type dds_offered_deadline_missed_status_t = dds_offered_deadline_missed_status;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_offered_incompatible_qos_status {
    pub total_count: u32,
    pub total_count_change: i32,
    pub last_policy_id: u32,
}
#[test]
fn bindgen_test_layout_dds_offered_incompatible_qos_status() {
    assert_eq!(
        ::std::mem::size_of::<dds_offered_incompatible_qos_status>(),
        12usize,
        concat!("Size of: ", stringify!(dds_offered_incompatible_qos_status))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_offered_incompatible_qos_status>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dds_offered_incompatible_qos_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_offered_incompatible_qos_status>())).total_count as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_offered_incompatible_qos_status),
            "::",
            stringify!(total_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_offered_incompatible_qos_status>())).total_count_change
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_offered_incompatible_qos_status),
            "::",
            stringify!(total_count_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_offered_incompatible_qos_status>())).last_policy_id
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_offered_incompatible_qos_status),
            "::",
            stringify!(last_policy_id)
        )
    );
}
pub type dds_offered_incompatible_qos_status_t = dds_offered_incompatible_qos_status;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_publication_matched_status {
    pub total_count: u32,
    pub total_count_change: i32,
    pub current_count: u32,
    pub current_count_change: i32,
    pub last_subscription_handle: dds_instance_handle_t,
}
#[test]
fn bindgen_test_layout_dds_publication_matched_status() {
    assert_eq!(
        ::std::mem::size_of::<dds_publication_matched_status>(),
        24usize,
        concat!("Size of: ", stringify!(dds_publication_matched_status))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_publication_matched_status>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_publication_matched_status))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_publication_matched_status>())).total_count as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_publication_matched_status),
            "::",
            stringify!(total_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_publication_matched_status>())).total_count_change
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_publication_matched_status),
            "::",
            stringify!(total_count_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_publication_matched_status>())).current_count as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_publication_matched_status),
            "::",
            stringify!(current_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_publication_matched_status>())).current_count_change
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_publication_matched_status),
            "::",
            stringify!(current_count_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_publication_matched_status>())).last_subscription_handle
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_publication_matched_status),
            "::",
            stringify!(last_subscription_handle)
        )
    );
}
pub type dds_publication_matched_status_t = dds_publication_matched_status;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_liveliness_lost_status {
    pub total_count: u32,
    pub total_count_change: i32,
}
#[test]
fn bindgen_test_layout_dds_liveliness_lost_status() {
    assert_eq!(
        ::std::mem::size_of::<dds_liveliness_lost_status>(),
        8usize,
        concat!("Size of: ", stringify!(dds_liveliness_lost_status))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_liveliness_lost_status>(),
        4usize,
        concat!("Alignment of ", stringify!(dds_liveliness_lost_status))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_liveliness_lost_status>())).total_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_liveliness_lost_status),
            "::",
            stringify!(total_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_liveliness_lost_status>())).total_count_change as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_liveliness_lost_status),
            "::",
            stringify!(total_count_change)
        )
    );
}
pub type dds_liveliness_lost_status_t = dds_liveliness_lost_status;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_subscription_matched_status {
    pub total_count: u32,
    pub total_count_change: i32,
    pub current_count: u32,
    pub current_count_change: i32,
    pub last_publication_handle: dds_instance_handle_t,
}
#[test]
fn bindgen_test_layout_dds_subscription_matched_status() {
    assert_eq!(
        ::std::mem::size_of::<dds_subscription_matched_status>(),
        24usize,
        concat!("Size of: ", stringify!(dds_subscription_matched_status))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_subscription_matched_status>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_subscription_matched_status))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_subscription_matched_status>())).total_count as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_subscription_matched_status),
            "::",
            stringify!(total_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_subscription_matched_status>())).total_count_change
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_subscription_matched_status),
            "::",
            stringify!(total_count_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_subscription_matched_status>())).current_count as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_subscription_matched_status),
            "::",
            stringify!(current_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_subscription_matched_status>())).current_count_change
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_subscription_matched_status),
            "::",
            stringify!(current_count_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_subscription_matched_status>())).last_publication_handle
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_subscription_matched_status),
            "::",
            stringify!(last_publication_handle)
        )
    );
}
pub type dds_subscription_matched_status_t = dds_subscription_matched_status;
pub const dds_sample_rejected_status_kind_DDS_NOT_REJECTED: dds_sample_rejected_status_kind = 0;
pub const dds_sample_rejected_status_kind_DDS_REJECTED_BY_INSTANCES_LIMIT:
    dds_sample_rejected_status_kind = 1;
pub const dds_sample_rejected_status_kind_DDS_REJECTED_BY_SAMPLES_LIMIT:
    dds_sample_rejected_status_kind = 2;
pub const dds_sample_rejected_status_kind_DDS_REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT:
    dds_sample_rejected_status_kind = 3;
pub type dds_sample_rejected_status_kind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_sample_rejected_status {
    pub total_count: u32,
    pub total_count_change: i32,
    pub last_reason: dds_sample_rejected_status_kind,
    pub last_instance_handle: dds_instance_handle_t,
}
#[test]
fn bindgen_test_layout_dds_sample_rejected_status() {
    assert_eq!(
        ::std::mem::size_of::<dds_sample_rejected_status>(),
        24usize,
        concat!("Size of: ", stringify!(dds_sample_rejected_status))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_sample_rejected_status>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_sample_rejected_status))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_sample_rejected_status>())).total_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_rejected_status),
            "::",
            stringify!(total_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_sample_rejected_status>())).total_count_change as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_rejected_status),
            "::",
            stringify!(total_count_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_sample_rejected_status>())).last_reason as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_rejected_status),
            "::",
            stringify!(last_reason)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_sample_rejected_status>())).last_instance_handle as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_rejected_status),
            "::",
            stringify!(last_instance_handle)
        )
    );
}
impl Default for dds_sample_rejected_status {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_sample_rejected_status_t = dds_sample_rejected_status;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_liveliness_changed_status {
    pub alive_count: u32,
    pub not_alive_count: u32,
    pub alive_count_change: i32,
    pub not_alive_count_change: i32,
    pub last_publication_handle: dds_instance_handle_t,
}
#[test]
fn bindgen_test_layout_dds_liveliness_changed_status() {
    assert_eq!(
        ::std::mem::size_of::<dds_liveliness_changed_status>(),
        24usize,
        concat!("Size of: ", stringify!(dds_liveliness_changed_status))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_liveliness_changed_status>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_liveliness_changed_status))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_liveliness_changed_status>())).alive_count as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_liveliness_changed_status),
            "::",
            stringify!(alive_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_liveliness_changed_status>())).not_alive_count as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_liveliness_changed_status),
            "::",
            stringify!(not_alive_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_liveliness_changed_status>())).alive_count_change as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_liveliness_changed_status),
            "::",
            stringify!(alive_count_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_liveliness_changed_status>())).not_alive_count_change
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_liveliness_changed_status),
            "::",
            stringify!(not_alive_count_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_liveliness_changed_status>())).last_publication_handle
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_liveliness_changed_status),
            "::",
            stringify!(last_publication_handle)
        )
    );
}
pub type dds_liveliness_changed_status_t = dds_liveliness_changed_status;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_requested_deadline_missed_status {
    pub total_count: u32,
    pub total_count_change: i32,
    pub last_instance_handle: dds_instance_handle_t,
}
#[test]
fn bindgen_test_layout_dds_requested_deadline_missed_status() {
    assert_eq!(
        ::std::mem::size_of::<dds_requested_deadline_missed_status>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(dds_requested_deadline_missed_status)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<dds_requested_deadline_missed_status>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(dds_requested_deadline_missed_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_requested_deadline_missed_status>())).total_count as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_requested_deadline_missed_status),
            "::",
            stringify!(total_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_requested_deadline_missed_status>())).total_count_change
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_requested_deadline_missed_status),
            "::",
            stringify!(total_count_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_requested_deadline_missed_status>())).last_instance_handle
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_requested_deadline_missed_status),
            "::",
            stringify!(last_instance_handle)
        )
    );
}
pub type dds_requested_deadline_missed_status_t = dds_requested_deadline_missed_status;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_requested_incompatible_qos_status {
    pub total_count: u32,
    pub total_count_change: i32,
    pub last_policy_id: u32,
}
#[test]
fn bindgen_test_layout_dds_requested_incompatible_qos_status() {
    assert_eq!(
        ::std::mem::size_of::<dds_requested_incompatible_qos_status>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(dds_requested_incompatible_qos_status)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<dds_requested_incompatible_qos_status>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dds_requested_incompatible_qos_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_requested_incompatible_qos_status>())).total_count
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_requested_incompatible_qos_status),
            "::",
            stringify!(total_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_requested_incompatible_qos_status>())).total_count_change
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_requested_incompatible_qos_status),
            "::",
            stringify!(total_count_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_requested_incompatible_qos_status>())).last_policy_id
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_requested_incompatible_qos_status),
            "::",
            stringify!(last_policy_id)
        )
    );
}
pub type dds_requested_incompatible_qos_status_t = dds_requested_incompatible_qos_status;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_sample_lost_status {
    pub total_count: u32,
    pub total_count_change: i32,
}
#[test]
fn bindgen_test_layout_dds_sample_lost_status() {
    assert_eq!(
        ::std::mem::size_of::<dds_sample_lost_status>(),
        8usize,
        concat!("Size of: ", stringify!(dds_sample_lost_status))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_sample_lost_status>(),
        4usize,
        concat!("Alignment of ", stringify!(dds_sample_lost_status))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_sample_lost_status>())).total_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_lost_status),
            "::",
            stringify!(total_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_sample_lost_status>())).total_count_change as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_lost_status),
            "::",
            stringify!(total_count_change)
        )
    );
}
pub type dds_sample_lost_status_t = dds_sample_lost_status;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_inconsistent_topic_status {
    pub total_count: u32,
    pub total_count_change: i32,
}
#[test]
fn bindgen_test_layout_dds_inconsistent_topic_status() {
    assert_eq!(
        ::std::mem::size_of::<dds_inconsistent_topic_status>(),
        8usize,
        concat!("Size of: ", stringify!(dds_inconsistent_topic_status))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_inconsistent_topic_status>(),
        4usize,
        concat!("Alignment of ", stringify!(dds_inconsistent_topic_status))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_inconsistent_topic_status>())).total_count as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_inconsistent_topic_status),
            "::",
            stringify!(total_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_inconsistent_topic_status>())).total_count_change as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_inconsistent_topic_status),
            "::",
            stringify!(total_count_change)
        )
    );
}
pub type dds_inconsistent_topic_status_t = dds_inconsistent_topic_status;
extern "C" {
    pub fn dds_get_inconsistent_topic_status(
        topic: dds_entity_t,
        status: *mut dds_inconsistent_topic_status_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_get_publication_matched_status(
        writer: dds_entity_t,
        status: *mut dds_publication_matched_status_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_get_liveliness_lost_status(
        writer: dds_entity_t,
        status: *mut dds_liveliness_lost_status_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_get_offered_deadline_missed_status(
        writer: dds_entity_t,
        status: *mut dds_offered_deadline_missed_status_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_get_offered_incompatible_qos_status(
        writer: dds_entity_t,
        status: *mut dds_offered_incompatible_qos_status_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_get_subscription_matched_status(
        reader: dds_entity_t,
        status: *mut dds_subscription_matched_status_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_get_liveliness_changed_status(
        reader: dds_entity_t,
        status: *mut dds_liveliness_changed_status_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_get_sample_rejected_status(
        reader: dds_entity_t,
        status: *mut dds_sample_rejected_status_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_get_sample_lost_status(
        reader: dds_entity_t,
        status: *mut dds_sample_lost_status_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_get_requested_deadline_missed_status(
        reader: dds_entity_t,
        status: *mut dds_requested_deadline_missed_status_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_get_requested_incompatible_qos_status(
        reader: dds_entity_t,
        status: *mut dds_requested_incompatible_qos_status_t,
    ) -> dds_return_t;
}
pub type dds_on_inconsistent_topic_fn = ::std::option::Option<
    unsafe extern "C" fn(
        topic: dds_entity_t,
        status: dds_inconsistent_topic_status_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type dds_on_liveliness_lost_fn = ::std::option::Option<
    unsafe extern "C" fn(
        writer: dds_entity_t,
        status: dds_liveliness_lost_status_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type dds_on_offered_deadline_missed_fn = ::std::option::Option<
    unsafe extern "C" fn(
        writer: dds_entity_t,
        status: dds_offered_deadline_missed_status_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type dds_on_offered_incompatible_qos_fn = ::std::option::Option<
    unsafe extern "C" fn(
        writer: dds_entity_t,
        status: dds_offered_incompatible_qos_status_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type dds_on_data_on_readers_fn = ::std::option::Option<
    unsafe extern "C" fn(subscriber: dds_entity_t, arg: *mut ::std::os::raw::c_void),
>;
pub type dds_on_sample_lost_fn = ::std::option::Option<
    unsafe extern "C" fn(
        reader: dds_entity_t,
        status: dds_sample_lost_status_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type dds_on_data_available_fn = ::std::option::Option<
    unsafe extern "C" fn(reader: dds_entity_t, arg: *mut ::std::os::raw::c_void),
>;
pub type dds_on_sample_rejected_fn = ::std::option::Option<
    unsafe extern "C" fn(
        reader: dds_entity_t,
        status: dds_sample_rejected_status_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type dds_on_liveliness_changed_fn = ::std::option::Option<
    unsafe extern "C" fn(
        reader: dds_entity_t,
        status: dds_liveliness_changed_status_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type dds_on_requested_deadline_missed_fn = ::std::option::Option<
    unsafe extern "C" fn(
        reader: dds_entity_t,
        status: dds_requested_deadline_missed_status_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type dds_on_requested_incompatible_qos_fn = ::std::option::Option<
    unsafe extern "C" fn(
        reader: dds_entity_t,
        status: dds_requested_incompatible_qos_status_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type dds_on_publication_matched_fn = ::std::option::Option<
    unsafe extern "C" fn(
        writer: dds_entity_t,
        status: dds_publication_matched_status_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type dds_on_subscription_matched_fn = ::std::option::Option<
    unsafe extern "C" fn(
        reader: dds_entity_t,
        status: dds_subscription_matched_status_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_listener {
    _unused: [u8; 0],
}
pub type dds_listener_t = dds_listener;
extern "C" {
    pub fn dds_create_listener(arg: *mut ::std::os::raw::c_void) -> *mut dds_listener_t;
}
extern "C" {
    pub fn dds_delete_listener(listener: *mut dds_listener_t);
}
extern "C" {
    pub fn dds_reset_listener(listener: *mut dds_listener_t);
}
extern "C" {
    pub fn dds_copy_listener(dst: *mut dds_listener_t, src: *const dds_listener_t);
}
extern "C" {
    pub fn dds_merge_listener(dst: *mut dds_listener_t, src: *const dds_listener_t);
}
extern "C" {
    pub fn dds_lset_inconsistent_topic(
        listener: *mut dds_listener_t,
        callback: dds_on_inconsistent_topic_fn,
    );
}
extern "C" {
    pub fn dds_lset_liveliness_lost(
        listener: *mut dds_listener_t,
        callback: dds_on_liveliness_lost_fn,
    );
}
extern "C" {
    pub fn dds_lset_offered_deadline_missed(
        listener: *mut dds_listener_t,
        callback: dds_on_offered_deadline_missed_fn,
    );
}
extern "C" {
    pub fn dds_lset_offered_incompatible_qos(
        listener: *mut dds_listener_t,
        callback: dds_on_offered_incompatible_qos_fn,
    );
}
extern "C" {
    pub fn dds_lset_data_on_readers(
        listener: *mut dds_listener_t,
        callback: dds_on_data_on_readers_fn,
    );
}
extern "C" {
    pub fn dds_lset_sample_lost(listener: *mut dds_listener_t, callback: dds_on_sample_lost_fn);
}
extern "C" {
    pub fn dds_lset_data_available(
        listener: *mut dds_listener_t,
        callback: dds_on_data_available_fn,
    );
}
extern "C" {
    pub fn dds_lset_sample_rejected(
        listener: *mut dds_listener_t,
        callback: dds_on_sample_rejected_fn,
    );
}
extern "C" {
    pub fn dds_lset_liveliness_changed(
        listener: *mut dds_listener_t,
        callback: dds_on_liveliness_changed_fn,
    );
}
extern "C" {
    pub fn dds_lset_requested_deadline_missed(
        listener: *mut dds_listener_t,
        callback: dds_on_requested_deadline_missed_fn,
    );
}
extern "C" {
    pub fn dds_lset_requested_incompatible_qos(
        listener: *mut dds_listener_t,
        callback: dds_on_requested_incompatible_qos_fn,
    );
}
extern "C" {
    pub fn dds_lset_publication_matched(
        listener: *mut dds_listener_t,
        callback: dds_on_publication_matched_fn,
    );
}
extern "C" {
    pub fn dds_lset_subscription_matched(
        listener: *mut dds_listener_t,
        callback: dds_on_subscription_matched_fn,
    );
}
extern "C" {
    pub fn dds_lget_inconsistent_topic(
        listener: *const dds_listener_t,
        callback: *mut dds_on_inconsistent_topic_fn,
    );
}
extern "C" {
    pub fn dds_lget_liveliness_lost(
        listener: *const dds_listener_t,
        callback: *mut dds_on_liveliness_lost_fn,
    );
}
extern "C" {
    pub fn dds_lget_offered_deadline_missed(
        listener: *const dds_listener_t,
        callback: *mut dds_on_offered_deadline_missed_fn,
    );
}
extern "C" {
    pub fn dds_lget_offered_incompatible_qos(
        listener: *const dds_listener_t,
        callback: *mut dds_on_offered_incompatible_qos_fn,
    );
}
extern "C" {
    pub fn dds_lget_data_on_readers(
        listener: *const dds_listener_t,
        callback: *mut dds_on_data_on_readers_fn,
    );
}
extern "C" {
    pub fn dds_lget_sample_lost(
        listener: *const dds_listener_t,
        callback: *mut dds_on_sample_lost_fn,
    );
}
extern "C" {
    pub fn dds_lget_data_available(
        listener: *const dds_listener_t,
        callback: *mut dds_on_data_available_fn,
    );
}
extern "C" {
    pub fn dds_lget_sample_rejected(
        listener: *const dds_listener_t,
        callback: *mut dds_on_sample_rejected_fn,
    );
}
extern "C" {
    pub fn dds_lget_liveliness_changed(
        listener: *const dds_listener_t,
        callback: *mut dds_on_liveliness_changed_fn,
    );
}
extern "C" {
    pub fn dds_lget_requested_deadline_missed(
        listener: *const dds_listener_t,
        callback: *mut dds_on_requested_deadline_missed_fn,
    );
}
extern "C" {
    pub fn dds_lget_requested_incompatible_qos(
        listener: *const dds_listener_t,
        callback: *mut dds_on_requested_incompatible_qos_fn,
    );
}
extern "C" {
    pub fn dds_lget_publication_matched(
        listener: *const dds_listener_t,
        callback: *mut dds_on_publication_matched_fn,
    );
}
extern "C" {
    pub fn dds_lget_subscription_matched(
        listener: *const dds_listener_t,
        callback: *mut dds_on_subscription_matched_fn,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddsi_typeid {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddsi_typeinfo {
    _unused: [u8; 0],
}
pub type dds_typeinfo_t = ddsi_typeinfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_rhc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddsi_plist {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddsi_sertopic {
    _unused: [u8; 0],
}
pub const dds_status_id_DDS_INCONSISTENT_TOPIC_STATUS_ID: dds_status_id = 0;
pub const dds_status_id_DDS_OFFERED_DEADLINE_MISSED_STATUS_ID: dds_status_id = 1;
pub const dds_status_id_DDS_REQUESTED_DEADLINE_MISSED_STATUS_ID: dds_status_id = 2;
pub const dds_status_id_DDS_OFFERED_INCOMPATIBLE_QOS_STATUS_ID: dds_status_id = 3;
pub const dds_status_id_DDS_REQUESTED_INCOMPATIBLE_QOS_STATUS_ID: dds_status_id = 4;
pub const dds_status_id_DDS_SAMPLE_LOST_STATUS_ID: dds_status_id = 5;
pub const dds_status_id_DDS_SAMPLE_REJECTED_STATUS_ID: dds_status_id = 6;
pub const dds_status_id_DDS_DATA_ON_READERS_STATUS_ID: dds_status_id = 7;
pub const dds_status_id_DDS_DATA_AVAILABLE_STATUS_ID: dds_status_id = 8;
pub const dds_status_id_DDS_LIVELINESS_LOST_STATUS_ID: dds_status_id = 9;
pub const dds_status_id_DDS_LIVELINESS_CHANGED_STATUS_ID: dds_status_id = 10;
pub const dds_status_id_DDS_PUBLICATION_MATCHED_STATUS_ID: dds_status_id = 11;
pub const dds_status_id_DDS_SUBSCRIPTION_MATCHED_STATUS_ID: dds_status_id = 12;
pub type dds_status_id = ::std::os::raw::c_uint;
pub use self::dds_status_id as dds_status_id_t;
pub const dds_sample_state_DDS_SST_READ: dds_sample_state = 1;
pub const dds_sample_state_DDS_SST_NOT_READ: dds_sample_state = 2;
pub type dds_sample_state = ::std::os::raw::c_uint;
pub use self::dds_sample_state as dds_sample_state_t;
pub const dds_view_state_DDS_VST_NEW: dds_view_state = 4;
pub const dds_view_state_DDS_VST_OLD: dds_view_state = 8;
pub type dds_view_state = ::std::os::raw::c_uint;
pub use self::dds_view_state as dds_view_state_t;
pub const dds_instance_state_DDS_IST_ALIVE: dds_instance_state = 16;
pub const dds_instance_state_DDS_IST_NOT_ALIVE_DISPOSED: dds_instance_state = 32;
pub const dds_instance_state_DDS_IST_NOT_ALIVE_NO_WRITERS: dds_instance_state = 64;
pub type dds_instance_state = ::std::os::raw::c_uint;
pub use self::dds_instance_state as dds_instance_state_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_sample_info {
    pub sample_state: dds_sample_state_t,
    pub view_state: dds_view_state_t,
    pub instance_state: dds_instance_state_t,
    pub valid_data: bool,
    pub source_timestamp: dds_time_t,
    pub instance_handle: dds_instance_handle_t,
    pub publication_handle: dds_instance_handle_t,
    pub disposed_generation_count: u32,
    pub no_writers_generation_count: u32,
    pub sample_rank: u32,
    pub generation_rank: u32,
    pub absolute_generation_rank: u32,
}
#[test]
fn bindgen_test_layout_dds_sample_info() {
    assert_eq!(
        ::std::mem::size_of::<dds_sample_info>(),
        64usize,
        concat!("Size of: ", stringify!(dds_sample_info))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_sample_info>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_sample_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_sample_info>())).sample_state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_info),
            "::",
            stringify!(sample_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_sample_info>())).view_state as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_info),
            "::",
            stringify!(view_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_sample_info>())).instance_state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_info),
            "::",
            stringify!(instance_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_sample_info>())).valid_data as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_info),
            "::",
            stringify!(valid_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_sample_info>())).source_timestamp as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_info),
            "::",
            stringify!(source_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_sample_info>())).instance_handle as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_info),
            "::",
            stringify!(instance_handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_sample_info>())).publication_handle as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_info),
            "::",
            stringify!(publication_handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_sample_info>())).disposed_generation_count as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_info),
            "::",
            stringify!(disposed_generation_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_sample_info>())).no_writers_generation_count as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_info),
            "::",
            stringify!(no_writers_generation_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_sample_info>())).sample_rank as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_info),
            "::",
            stringify!(sample_rank)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_sample_info>())).generation_rank as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_info),
            "::",
            stringify!(generation_rank)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_sample_info>())).absolute_generation_rank as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_sample_info),
            "::",
            stringify!(absolute_generation_rank)
        )
    );
}
impl Default for dds_sample_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_sample_info_t = dds_sample_info;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_builtintopic_guid {
    pub v: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_dds_builtintopic_guid() {
    assert_eq!(
        ::std::mem::size_of::<dds_builtintopic_guid>(),
        16usize,
        concat!("Size of: ", stringify!(dds_builtintopic_guid))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_builtintopic_guid>(),
        1usize,
        concat!("Alignment of ", stringify!(dds_builtintopic_guid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_builtintopic_guid>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_builtintopic_guid),
            "::",
            stringify!(v)
        )
    );
}
pub type dds_guid_t = dds_builtintopic_guid;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_builtintopic_endpoint {
    pub key: dds_guid_t,
    pub participant_key: dds_guid_t,
    pub participant_instance_handle: dds_instance_handle_t,
    pub topic_name: *mut ::std::os::raw::c_char,
    pub type_name: *mut ::std::os::raw::c_char,
    pub qos: *mut dds_qos_t,
}
#[test]
fn bindgen_test_layout_dds_builtintopic_endpoint() {
    assert_eq!(
        ::std::mem::size_of::<dds_builtintopic_endpoint>(),
        64usize,
        concat!("Size of: ", stringify!(dds_builtintopic_endpoint))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_builtintopic_endpoint>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_builtintopic_endpoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_builtintopic_endpoint>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_builtintopic_endpoint),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_builtintopic_endpoint>())).participant_key as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_builtintopic_endpoint),
            "::",
            stringify!(participant_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_builtintopic_endpoint>())).participant_instance_handle
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_builtintopic_endpoint),
            "::",
            stringify!(participant_instance_handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_builtintopic_endpoint>())).topic_name as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_builtintopic_endpoint),
            "::",
            stringify!(topic_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_builtintopic_endpoint>())).type_name as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_builtintopic_endpoint),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_builtintopic_endpoint>())).qos as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_builtintopic_endpoint),
            "::",
            stringify!(qos)
        )
    );
}
impl Default for dds_builtintopic_endpoint {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_builtintopic_endpoint_t = dds_builtintopic_endpoint;
extern "C" {
    pub fn dds_enable(entity: dds_entity_t) -> dds_return_t;
}
extern "C" {
    pub fn dds_delete(entity: dds_entity_t) -> dds_return_t;
}
extern "C" {
    pub fn dds_get_publisher(writer: dds_entity_t) -> dds_entity_t;
}
extern "C" {
    pub fn dds_get_subscriber(entity: dds_entity_t) -> dds_entity_t;
}
extern "C" {
    pub fn dds_get_datareader(entity: dds_entity_t) -> dds_entity_t;
}
extern "C" {
    pub fn dds_get_mask(condition: dds_entity_t, mask: *mut u32) -> dds_return_t;
}
extern "C" {
    pub fn dds_get_instance_handle(
        entity: dds_entity_t,
        ihdl: *mut dds_instance_handle_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_read_status(entity: dds_entity_t, status: *mut u32, mask: u32) -> dds_return_t;
}
extern "C" {
    pub fn dds_take_status(entity: dds_entity_t, status: *mut u32, mask: u32) -> dds_return_t;
}
extern "C" {
    pub fn dds_get_status_changes(entity: dds_entity_t, status: *mut u32) -> dds_return_t;
}
extern "C" {
    pub fn dds_get_status_mask(entity: dds_entity_t, mask: *mut u32) -> dds_return_t;
}
extern "C" {
    pub fn dds_get_enabled_status(entity: dds_entity_t, mask: *mut u32) -> dds_return_t;
}
extern "C" {
    pub fn dds_set_status_mask(entity: dds_entity_t, mask: u32) -> dds_return_t;
}
extern "C" {
    pub fn dds_set_enabled_status(entity: dds_entity_t, mask: u32) -> dds_return_t;
}
extern "C" {
    pub fn dds_get_qos(entity: dds_entity_t, qos: *mut dds_qos_t) -> dds_return_t;
}
extern "C" {
    pub fn dds_set_qos(entity: dds_entity_t, qos: *const dds_qos_t) -> dds_return_t;
}
extern "C" {
    pub fn dds_get_listener(entity: dds_entity_t, listener: *mut dds_listener_t) -> dds_return_t;
}
extern "C" {
    pub fn dds_set_listener(entity: dds_entity_t, listener: *const dds_listener_t) -> dds_return_t;
}
extern "C" {
    pub fn dds_create_participant(
        domain: dds_domainid_t,
        qos: *const dds_qos_t,
        listener: *const dds_listener_t,
    ) -> dds_entity_t;
}
extern "C" {
    pub fn dds_create_domain(
        domain: dds_domainid_t,
        config: *const ::std::os::raw::c_char,
    ) -> dds_entity_t;
}
extern "C" {
    pub fn dds_get_parent(entity: dds_entity_t) -> dds_entity_t;
}
extern "C" {
    pub fn dds_get_participant(entity: dds_entity_t) -> dds_entity_t;
}
extern "C" {
    pub fn dds_get_children(
        entity: dds_entity_t,
        children: *mut dds_entity_t,
        size: size_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_get_domainid(entity: dds_entity_t, id: *mut dds_domainid_t) -> dds_return_t;
}
extern "C" {
    pub fn dds_lookup_participant(
        domain_id: dds_domainid_t,
        participants: *mut dds_entity_t,
        size: size_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_create_topic(
        participant: dds_entity_t,
        descriptor: *const dds_topic_descriptor_t,
        name: *const ::std::os::raw::c_char,
        qos: *const dds_qos_t,
        listener: *const dds_listener_t,
    ) -> dds_entity_t;
}
extern "C" {
    pub fn dds_create_topic_sertype(
        participant: dds_entity_t,
        name: *const ::std::os::raw::c_char,
        sertype: *mut *mut ddsi_sertype,
        qos: *const dds_qos_t,
        listener: *const dds_listener_t,
        sedp_plist: *const ddsi_plist,
    ) -> dds_entity_t;
}
extern "C" {
    pub fn dds_create_topic_arbitrary(
        participant: dds_entity_t,
        sertopic: *mut ddsi_sertopic,
        qos: *const dds_qos_t,
        listener: *const dds_listener_t,
        sedp_plist: *const ddsi_plist,
    ) -> dds_entity_t;
}
extern "C" {
    pub fn dds_find_topic(
        scope: dds_find_scope_t,
        participant: dds_entity_t,
        name: *const ::std::os::raw::c_char,
        type_info: *const dds_typeinfo_t,
        timeout: dds_duration_t,
    ) -> dds_entity_t;
}
extern "C" {
    pub fn dds_get_name(
        topic: dds_entity_t,
        name: *mut ::std::os::raw::c_char,
        size: size_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_get_type_name(
        topic: dds_entity_t,
        name: *mut ::std::os::raw::c_char,
        size: size_t,
    ) -> dds_return_t;
}
pub type dds_topic_filter_sample_fn =
    ::std::option::Option<unsafe extern "C" fn(sample: *const ::std::os::raw::c_void) -> bool>;
pub type dds_topic_filter_fn = dds_topic_filter_sample_fn;
extern "C" {
    pub fn dds_set_topic_filter(topic: dds_entity_t, filter: dds_topic_filter_fn);
}
extern "C" {
    pub fn dds_get_topic_filter(topic: dds_entity_t) -> dds_topic_filter_fn;
}
extern "C" {
    pub fn dds_create_subscriber(
        participant: dds_entity_t,
        qos: *const dds_qos_t,
        listener: *const dds_listener_t,
    ) -> dds_entity_t;
}
extern "C" {
    pub fn dds_create_publisher(
        participant: dds_entity_t,
        qos: *const dds_qos_t,
        listener: *const dds_listener_t,
    ) -> dds_entity_t;
}
extern "C" {
    pub fn dds_suspend(publisher: dds_entity_t) -> dds_return_t;
}
extern "C" {
    pub fn dds_resume(publisher: dds_entity_t) -> dds_return_t;
}
extern "C" {
    pub fn dds_wait_for_acks(
        publisher_or_writer: dds_entity_t,
        timeout: dds_duration_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_create_reader(
        participant_or_subscriber: dds_entity_t,
        topic: dds_entity_t,
        qos: *const dds_qos_t,
        listener: *const dds_listener_t,
    ) -> dds_entity_t;
}
extern "C" {
    pub fn dds_create_reader_rhc(
        participant_or_subscriber: dds_entity_t,
        topic: dds_entity_t,
        qos: *const dds_qos_t,
        listener: *const dds_listener_t,
        rhc: *mut dds_rhc,
    ) -> dds_entity_t;
}
extern "C" {
    pub fn dds_reader_wait_for_historical_data(
        reader: dds_entity_t,
        max_wait: dds_duration_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_create_writer(
        participant_or_publisher: dds_entity_t,
        topic: dds_entity_t,
        qos: *const dds_qos_t,
        listener: *const dds_listener_t,
    ) -> dds_entity_t;
}
extern "C" {
    pub fn dds_register_instance(
        writer: dds_entity_t,
        handle: *mut dds_instance_handle_t,
        data: *const ::std::os::raw::c_void,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_unregister_instance(
        writer: dds_entity_t,
        data: *const ::std::os::raw::c_void,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_unregister_instance_ih(
        writer: dds_entity_t,
        handle: dds_instance_handle_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_unregister_instance_ts(
        writer: dds_entity_t,
        data: *const ::std::os::raw::c_void,
        timestamp: dds_time_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_unregister_instance_ih_ts(
        writer: dds_entity_t,
        handle: dds_instance_handle_t,
        timestamp: dds_time_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_writedispose(
        writer: dds_entity_t,
        data: *const ::std::os::raw::c_void,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_writedispose_ts(
        writer: dds_entity_t,
        data: *const ::std::os::raw::c_void,
        timestamp: dds_time_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_dispose(writer: dds_entity_t, data: *const ::std::os::raw::c_void) -> dds_return_t;
}
extern "C" {
    pub fn dds_dispose_ts(
        writer: dds_entity_t,
        data: *const ::std::os::raw::c_void,
        timestamp: dds_time_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_dispose_ih(writer: dds_entity_t, handle: dds_instance_handle_t) -> dds_return_t;
}
extern "C" {
    pub fn dds_dispose_ih_ts(
        writer: dds_entity_t,
        handle: dds_instance_handle_t,
        timestamp: dds_time_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_write(writer: dds_entity_t, data: *const ::std::os::raw::c_void) -> dds_return_t;
}
extern "C" {
    pub fn dds_write_flush(writer: dds_entity_t);
}
extern "C" {
    pub fn dds_writecdr(writer: dds_entity_t, serdata: *mut ddsi_serdata) -> dds_return_t;
}
extern "C" {
    pub fn dds_write_ts(
        writer: dds_entity_t,
        data: *const ::std::os::raw::c_void,
        timestamp: dds_time_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_create_readcondition(reader: dds_entity_t, mask: u32) -> dds_entity_t;
}
pub type dds_querycondition_filter_fn =
    ::std::option::Option<unsafe extern "C" fn(sample: *const ::std::os::raw::c_void) -> bool>;
extern "C" {
    pub fn dds_create_querycondition(
        reader: dds_entity_t,
        mask: u32,
        filter: dds_querycondition_filter_fn,
    ) -> dds_entity_t;
}
extern "C" {
    pub fn dds_create_guardcondition(participant: dds_entity_t) -> dds_entity_t;
}
extern "C" {
    pub fn dds_set_guardcondition(guardcond: dds_entity_t, triggered: bool) -> dds_return_t;
}
extern "C" {
    pub fn dds_read_guardcondition(guardcond: dds_entity_t, triggered: *mut bool) -> dds_return_t;
}
extern "C" {
    pub fn dds_take_guardcondition(guardcond: dds_entity_t, triggered: *mut bool) -> dds_return_t;
}
pub type dds_attach_t = isize;
extern "C" {
    pub fn dds_create_waitset(participant: dds_entity_t) -> dds_entity_t;
}
extern "C" {
    pub fn dds_waitset_get_entities(
        waitset: dds_entity_t,
        entities: *mut dds_entity_t,
        size: size_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_waitset_attach(
        waitset: dds_entity_t,
        entity: dds_entity_t,
        x: dds_attach_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_waitset_detach(waitset: dds_entity_t, entity: dds_entity_t) -> dds_return_t;
}
extern "C" {
    pub fn dds_waitset_set_trigger(waitset: dds_entity_t, trigger: bool) -> dds_return_t;
}
extern "C" {
    pub fn dds_waitset_wait(
        waitset: dds_entity_t,
        xs: *mut dds_attach_t,
        nxs: size_t,
        reltimeout: dds_duration_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_waitset_wait_until(
        waitset: dds_entity_t,
        xs: *mut dds_attach_t,
        nxs: size_t,
        abstimeout: dds_time_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_read(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        bufsz: size_t,
        maxs: u32,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_read_wl(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        maxs: u32,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_read_mask(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        bufsz: size_t,
        maxs: u32,
        mask: u32,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_read_mask_wl(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        maxs: u32,
        mask: u32,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_read_instance(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        bufsz: size_t,
        maxs: u32,
        handle: dds_instance_handle_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_read_instance_wl(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        maxs: u32,
        handle: dds_instance_handle_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_read_instance_mask(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        bufsz: size_t,
        maxs: u32,
        handle: dds_instance_handle_t,
        mask: u32,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_read_instance_mask_wl(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        maxs: u32,
        handle: dds_instance_handle_t,
        mask: u32,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_take(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        bufsz: size_t,
        maxs: u32,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_take_wl(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        maxs: u32,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_take_mask(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        bufsz: size_t,
        maxs: u32,
        mask: u32,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_take_mask_wl(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        maxs: u32,
        mask: u32,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_take_instance(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        bufsz: size_t,
        maxs: u32,
        handle: dds_instance_handle_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_take_instance_wl(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        maxs: u32,
        handle: dds_instance_handle_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_take_instance_mask(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        bufsz: size_t,
        maxs: u32,
        handle: dds_instance_handle_t,
        mask: u32,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_take_instance_mask_wl(
        reader_or_condition: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
        maxs: u32,
        handle: dds_instance_handle_t,
        mask: u32,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_take_next(
        reader: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_take_next_wl(
        reader: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_read_next(
        reader: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_read_next_wl(
        reader: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        si: *mut dds_sample_info_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_return_loan(
        entity: dds_entity_t,
        buf: *mut *mut ::std::os::raw::c_void,
        bufsz: i32,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_lookup_instance(
        entity: dds_entity_t,
        data: *const ::std::os::raw::c_void,
    ) -> dds_instance_handle_t;
}
extern "C" {
    pub fn dds_instance_get_key(
        entity: dds_entity_t,
        inst: dds_instance_handle_t,
        data: *mut ::std::os::raw::c_void,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_begin_coherent(entity: dds_entity_t) -> dds_return_t;
}
extern "C" {
    pub fn dds_end_coherent(entity: dds_entity_t) -> dds_return_t;
}
extern "C" {
    pub fn dds_notify_readers(subscriber: dds_entity_t) -> dds_return_t;
}
extern "C" {
    pub fn dds_triggered(entity: dds_entity_t) -> dds_return_t;
}
extern "C" {
    pub fn dds_get_topic(entity: dds_entity_t) -> dds_entity_t;
}
extern "C" {
    pub fn dds_get_matched_subscriptions(
        writer: dds_entity_t,
        rds: *mut dds_instance_handle_t,
        nrds: size_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_get_matched_subscription_data(
        writer: dds_entity_t,
        ih: dds_instance_handle_t,
    ) -> *mut dds_builtintopic_endpoint_t;
}
extern "C" {
    pub fn dds_get_matched_publications(
        reader: dds_entity_t,
        wrs: *mut dds_instance_handle_t,
        nwrs: size_t,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_get_matched_publication_data(
        reader: dds_entity_t,
        ih: dds_instance_handle_t,
    ) -> *mut dds_builtintopic_endpoint_t;
}
extern "C" {
    pub fn dds_assert_liveliness(entity: dds_entity_t) -> dds_return_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: size_t,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
impl Default for iovec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type ddsrt_iovec_t = iovec;
pub type ddsrt_msg_iovlen_t = size_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ddsrt_atomic_uint32_t {
    pub v: u32,
}
#[test]
fn bindgen_test_layout_ddsrt_atomic_uint32_t() {
    assert_eq!(
        ::std::mem::size_of::<ddsrt_atomic_uint32_t>(),
        4usize,
        concat!("Size of: ", stringify!(ddsrt_atomic_uint32_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsrt_atomic_uint32_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ddsrt_atomic_uint32_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsrt_atomic_uint32_t>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsrt_atomic_uint32_t),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ddsrt_atomic_uintptr_t {
    pub v: usize,
}
#[test]
fn bindgen_test_layout_ddsrt_atomic_uintptr_t() {
    assert_eq!(
        ::std::mem::size_of::<ddsrt_atomic_uintptr_t>(),
        8usize,
        concat!("Size of: ", stringify!(ddsrt_atomic_uintptr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsrt_atomic_uintptr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ddsrt_atomic_uintptr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsrt_atomic_uintptr_t>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsrt_atomic_uintptr_t),
            "::",
            stringify!(v)
        )
    );
}
pub type ddsrt_atomic_voidp_t = ddsrt_atomic_uintptr_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union ddsi_guid_prefix {
    pub s: [::std::os::raw::c_uchar; 12usize],
    pub u: [u32; 3usize],
    _bindgen_union_align: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_ddsi_guid_prefix() {
    assert_eq!(
        ::std::mem::size_of::<ddsi_guid_prefix>(),
        12usize,
        concat!("Size of: ", stringify!(ddsi_guid_prefix))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsi_guid_prefix>(),
        4usize,
        concat!("Alignment of ", stringify!(ddsi_guid_prefix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_guid_prefix>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_guid_prefix),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_guid_prefix>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_guid_prefix),
            "::",
            stringify!(u)
        )
    );
}
impl Default for ddsi_guid_prefix {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type ddsi_guid_prefix_t = ddsi_guid_prefix;
#[repr(C)]
#[derive(Copy, Clone)]
pub union ddsi_entityid {
    pub u: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_ddsi_entityid() {
    assert_eq!(
        ::std::mem::size_of::<ddsi_entityid>(),
        4usize,
        concat!("Size of: ", stringify!(ddsi_entityid))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsi_entityid>(),
        4usize,
        concat!("Alignment of ", stringify!(ddsi_entityid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_entityid>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_entityid),
            "::",
            stringify!(u)
        )
    );
}
impl Default for ddsi_entityid {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type ddsi_entityid_t = ddsi_entityid;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ddsi_guid {
    pub prefix: ddsi_guid_prefix_t,
    pub entityid: ddsi_entityid_t,
}
#[test]
fn bindgen_test_layout_ddsi_guid() {
    assert_eq!(
        ::std::mem::size_of::<ddsi_guid>(),
        16usize,
        concat!("Size of: ", stringify!(ddsi_guid))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsi_guid>(),
        4usize,
        concat!("Alignment of ", stringify!(ddsi_guid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_guid>())).prefix as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_guid),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_guid>())).entityid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_guid),
            "::",
            stringify!(entityid)
        )
    );
}
impl Default for ddsi_guid {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddsi_octetseq {
    pub length: u32,
    pub value: *mut ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_ddsi_octetseq() {
    assert_eq!(
        ::std::mem::size_of::<ddsi_octetseq>(),
        16usize,
        concat!("Size of: ", stringify!(ddsi_octetseq))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsi_octetseq>(),
        8usize,
        concat!("Alignment of ", stringify!(ddsi_octetseq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_octetseq>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_octetseq),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_octetseq>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_octetseq),
            "::",
            stringify!(value)
        )
    );
}
impl Default for ddsi_octetseq {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type ddsi_octetseq_t = ddsi_octetseq;
pub type dds_userdata_qospolicy_t = ddsi_octetseq_t;
pub type dds_topicdata_qospolicy_t = ddsi_octetseq_t;
pub type dds_groupdata_qospolicy_t = ddsi_octetseq_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_property {
    pub propagate: ::std::os::raw::c_uchar,
    pub name: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_dds_property() {
    assert_eq!(
        ::std::mem::size_of::<dds_property>(),
        24usize,
        concat!("Size of: ", stringify!(dds_property))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_property>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_property))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_property>())).propagate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_property),
            "::",
            stringify!(propagate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_property>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_property),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_property>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_property),
            "::",
            stringify!(value)
        )
    );
}
impl Default for dds_property {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_property_t = dds_property;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_propertyseq {
    pub n: u32,
    pub props: *mut dds_property_t,
}
#[test]
fn bindgen_test_layout_dds_propertyseq() {
    assert_eq!(
        ::std::mem::size_of::<dds_propertyseq>(),
        16usize,
        concat!("Size of: ", stringify!(dds_propertyseq))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_propertyseq>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_propertyseq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_propertyseq>())).n as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_propertyseq),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_propertyseq>())).props as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_propertyseq),
            "::",
            stringify!(props)
        )
    );
}
impl Default for dds_propertyseq {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_propertyseq_t = dds_propertyseq;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_binaryproperty {
    pub propagate: ::std::os::raw::c_uchar,
    pub name: *mut ::std::os::raw::c_char,
    pub value: ddsi_octetseq_t,
}
#[test]
fn bindgen_test_layout_dds_binaryproperty() {
    assert_eq!(
        ::std::mem::size_of::<dds_binaryproperty>(),
        32usize,
        concat!("Size of: ", stringify!(dds_binaryproperty))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_binaryproperty>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_binaryproperty))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_binaryproperty>())).propagate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_binaryproperty),
            "::",
            stringify!(propagate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_binaryproperty>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_binaryproperty),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_binaryproperty>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_binaryproperty),
            "::",
            stringify!(value)
        )
    );
}
impl Default for dds_binaryproperty {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_binaryproperty_t = dds_binaryproperty;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_binarypropertyseq {
    pub n: u32,
    pub props: *mut dds_binaryproperty_t,
}
#[test]
fn bindgen_test_layout_dds_binarypropertyseq() {
    assert_eq!(
        ::std::mem::size_of::<dds_binarypropertyseq>(),
        16usize,
        concat!("Size of: ", stringify!(dds_binarypropertyseq))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_binarypropertyseq>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_binarypropertyseq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_binarypropertyseq>())).n as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_binarypropertyseq),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_binarypropertyseq>())).props as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_binarypropertyseq),
            "::",
            stringify!(props)
        )
    );
}
impl Default for dds_binarypropertyseq {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_binarypropertyseq_t = dds_binarypropertyseq;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_property_qospolicy {
    pub value: dds_propertyseq_t,
    pub binary_value: dds_binarypropertyseq_t,
}
#[test]
fn bindgen_test_layout_dds_property_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_property_qospolicy>(),
        32usize,
        concat!("Size of: ", stringify!(dds_property_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_property_qospolicy>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_property_qospolicy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_property_qospolicy>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_property_qospolicy),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_property_qospolicy>())).binary_value as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_property_qospolicy),
            "::",
            stringify!(binary_value)
        )
    );
}
impl Default for dds_property_qospolicy {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_property_qospolicy_t = dds_property_qospolicy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_durability_qospolicy {
    pub kind: dds_durability_kind_t,
}
#[test]
fn bindgen_test_layout_dds_durability_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_durability_qospolicy>(),
        4usize,
        concat!("Size of: ", stringify!(dds_durability_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_durability_qospolicy>(),
        4usize,
        concat!("Alignment of ", stringify!(dds_durability_qospolicy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_durability_qospolicy>())).kind as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_durability_qospolicy),
            "::",
            stringify!(kind)
        )
    );
}
impl Default for dds_durability_qospolicy {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_durability_qospolicy_t = dds_durability_qospolicy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_history_qospolicy {
    pub kind: dds_history_kind_t,
    pub depth: i32,
}
#[test]
fn bindgen_test_layout_dds_history_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_history_qospolicy>(),
        8usize,
        concat!("Size of: ", stringify!(dds_history_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_history_qospolicy>(),
        4usize,
        concat!("Alignment of ", stringify!(dds_history_qospolicy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_history_qospolicy>())).kind as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_history_qospolicy),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_history_qospolicy>())).depth as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_history_qospolicy),
            "::",
            stringify!(depth)
        )
    );
}
impl Default for dds_history_qospolicy {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_history_qospolicy_t = dds_history_qospolicy;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_resource_limits_qospolicy {
    pub max_samples: i32,
    pub max_instances: i32,
    pub max_samples_per_instance: i32,
}
#[test]
fn bindgen_test_layout_dds_resource_limits_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_resource_limits_qospolicy>(),
        12usize,
        concat!("Size of: ", stringify!(dds_resource_limits_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_resource_limits_qospolicy>(),
        4usize,
        concat!("Alignment of ", stringify!(dds_resource_limits_qospolicy))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_resource_limits_qospolicy>())).max_samples as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_resource_limits_qospolicy),
            "::",
            stringify!(max_samples)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_resource_limits_qospolicy>())).max_instances as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_resource_limits_qospolicy),
            "::",
            stringify!(max_instances)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_resource_limits_qospolicy>())).max_samples_per_instance
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_resource_limits_qospolicy),
            "::",
            stringify!(max_samples_per_instance)
        )
    );
}
pub type dds_resource_limits_qospolicy_t = dds_resource_limits_qospolicy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_durability_service_qospolicy {
    pub service_cleanup_delay: dds_duration_t,
    pub history: dds_history_qospolicy_t,
    pub resource_limits: dds_resource_limits_qospolicy_t,
}
#[test]
fn bindgen_test_layout_dds_durability_service_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_durability_service_qospolicy>(),
        32usize,
        concat!("Size of: ", stringify!(dds_durability_service_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_durability_service_qospolicy>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(dds_durability_service_qospolicy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_durability_service_qospolicy>())).service_cleanup_delay
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_durability_service_qospolicy),
            "::",
            stringify!(service_cleanup_delay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_durability_service_qospolicy>())).history as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_durability_service_qospolicy),
            "::",
            stringify!(history)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_durability_service_qospolicy>())).resource_limits as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_durability_service_qospolicy),
            "::",
            stringify!(resource_limits)
        )
    );
}
impl Default for dds_durability_service_qospolicy {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_durability_service_qospolicy_t = dds_durability_service_qospolicy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_presentation_qospolicy {
    pub access_scope: dds_presentation_access_scope_kind_t,
    pub coherent_access: ::std::os::raw::c_uchar,
    pub ordered_access: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_dds_presentation_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_presentation_qospolicy>(),
        8usize,
        concat!("Size of: ", stringify!(dds_presentation_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_presentation_qospolicy>(),
        4usize,
        concat!("Alignment of ", stringify!(dds_presentation_qospolicy))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_presentation_qospolicy>())).access_scope as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_presentation_qospolicy),
            "::",
            stringify!(access_scope)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_presentation_qospolicy>())).coherent_access as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_presentation_qospolicy),
            "::",
            stringify!(coherent_access)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_presentation_qospolicy>())).ordered_access as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_presentation_qospolicy),
            "::",
            stringify!(ordered_access)
        )
    );
}
impl Default for dds_presentation_qospolicy {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_presentation_qospolicy_t = dds_presentation_qospolicy;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_deadline_qospolicy {
    pub deadline: dds_duration_t,
}
#[test]
fn bindgen_test_layout_dds_deadline_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_deadline_qospolicy>(),
        8usize,
        concat!("Size of: ", stringify!(dds_deadline_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_deadline_qospolicy>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_deadline_qospolicy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_deadline_qospolicy>())).deadline as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_deadline_qospolicy),
            "::",
            stringify!(deadline)
        )
    );
}
pub type dds_deadline_qospolicy_t = dds_deadline_qospolicy;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_latency_budget_qospolicy {
    pub duration: dds_duration_t,
}
#[test]
fn bindgen_test_layout_dds_latency_budget_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_latency_budget_qospolicy>(),
        8usize,
        concat!("Size of: ", stringify!(dds_latency_budget_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_latency_budget_qospolicy>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_latency_budget_qospolicy))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_latency_budget_qospolicy>())).duration as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_latency_budget_qospolicy),
            "::",
            stringify!(duration)
        )
    );
}
pub type dds_latency_budget_qospolicy_t = dds_latency_budget_qospolicy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_ownership_qospolicy {
    pub kind: dds_ownership_kind_t,
}
#[test]
fn bindgen_test_layout_dds_ownership_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_ownership_qospolicy>(),
        4usize,
        concat!("Size of: ", stringify!(dds_ownership_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_ownership_qospolicy>(),
        4usize,
        concat!("Alignment of ", stringify!(dds_ownership_qospolicy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_ownership_qospolicy>())).kind as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_ownership_qospolicy),
            "::",
            stringify!(kind)
        )
    );
}
impl Default for dds_ownership_qospolicy {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_ownership_qospolicy_t = dds_ownership_qospolicy;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_ownership_strength_qospolicy {
    pub value: i32,
}
#[test]
fn bindgen_test_layout_dds_ownership_strength_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_ownership_strength_qospolicy>(),
        4usize,
        concat!("Size of: ", stringify!(dds_ownership_strength_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_ownership_strength_qospolicy>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dds_ownership_strength_qospolicy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_ownership_strength_qospolicy>())).value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_ownership_strength_qospolicy),
            "::",
            stringify!(value)
        )
    );
}
pub type dds_ownership_strength_qospolicy_t = dds_ownership_strength_qospolicy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_liveliness_qospolicy {
    pub kind: dds_liveliness_kind_t,
    pub lease_duration: dds_duration_t,
}
#[test]
fn bindgen_test_layout_dds_liveliness_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_liveliness_qospolicy>(),
        16usize,
        concat!("Size of: ", stringify!(dds_liveliness_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_liveliness_qospolicy>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_liveliness_qospolicy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_liveliness_qospolicy>())).kind as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_liveliness_qospolicy),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_liveliness_qospolicy>())).lease_duration as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_liveliness_qospolicy),
            "::",
            stringify!(lease_duration)
        )
    );
}
impl Default for dds_liveliness_qospolicy {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_liveliness_qospolicy_t = dds_liveliness_qospolicy;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_time_based_filter_qospolicy {
    pub minimum_separation: dds_duration_t,
}
#[test]
fn bindgen_test_layout_dds_time_based_filter_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_time_based_filter_qospolicy>(),
        8usize,
        concat!("Size of: ", stringify!(dds_time_based_filter_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_time_based_filter_qospolicy>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_time_based_filter_qospolicy))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_time_based_filter_qospolicy>())).minimum_separation
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_time_based_filter_qospolicy),
            "::",
            stringify!(minimum_separation)
        )
    );
}
pub type dds_time_based_filter_qospolicy_t = dds_time_based_filter_qospolicy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddsi_stringseq {
    pub n: u32,
    pub strs: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ddsi_stringseq() {
    assert_eq!(
        ::std::mem::size_of::<ddsi_stringseq>(),
        16usize,
        concat!("Size of: ", stringify!(ddsi_stringseq))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsi_stringseq>(),
        8usize,
        concat!("Alignment of ", stringify!(ddsi_stringseq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_stringseq>())).n as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_stringseq),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_stringseq>())).strs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_stringseq),
            "::",
            stringify!(strs)
        )
    );
}
impl Default for ddsi_stringseq {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type ddsi_stringseq_t = ddsi_stringseq;
pub type dds_partition_qospolicy_t = ddsi_stringseq_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_reliability_qospolicy {
    pub kind: dds_reliability_kind_t,
    pub max_blocking_time: dds_duration_t,
}
#[test]
fn bindgen_test_layout_dds_reliability_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_reliability_qospolicy>(),
        16usize,
        concat!("Size of: ", stringify!(dds_reliability_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_reliability_qospolicy>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_reliability_qospolicy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_reliability_qospolicy>())).kind as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_reliability_qospolicy),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_reliability_qospolicy>())).max_blocking_time as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_reliability_qospolicy),
            "::",
            stringify!(max_blocking_time)
        )
    );
}
impl Default for dds_reliability_qospolicy {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_reliability_qospolicy_t = dds_reliability_qospolicy;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_transport_priority_qospolicy {
    pub value: i32,
}
#[test]
fn bindgen_test_layout_dds_transport_priority_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_transport_priority_qospolicy>(),
        4usize,
        concat!("Size of: ", stringify!(dds_transport_priority_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_transport_priority_qospolicy>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dds_transport_priority_qospolicy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_transport_priority_qospolicy>())).value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_transport_priority_qospolicy),
            "::",
            stringify!(value)
        )
    );
}
pub type dds_transport_priority_qospolicy_t = dds_transport_priority_qospolicy;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_lifespan_qospolicy {
    pub duration: dds_duration_t,
}
#[test]
fn bindgen_test_layout_dds_lifespan_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_lifespan_qospolicy>(),
        8usize,
        concat!("Size of: ", stringify!(dds_lifespan_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_lifespan_qospolicy>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_lifespan_qospolicy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_lifespan_qospolicy>())).duration as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_lifespan_qospolicy),
            "::",
            stringify!(duration)
        )
    );
}
pub type dds_lifespan_qospolicy_t = dds_lifespan_qospolicy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_destination_order_qospolicy {
    pub kind: dds_destination_order_kind_t,
}
#[test]
fn bindgen_test_layout_dds_destination_order_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_destination_order_qospolicy>(),
        4usize,
        concat!("Size of: ", stringify!(dds_destination_order_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_destination_order_qospolicy>(),
        4usize,
        concat!("Alignment of ", stringify!(dds_destination_order_qospolicy))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_destination_order_qospolicy>())).kind as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_destination_order_qospolicy),
            "::",
            stringify!(kind)
        )
    );
}
impl Default for dds_destination_order_qospolicy {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_destination_order_qospolicy_t = dds_destination_order_qospolicy;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_entity_factory_qospolicy {
    pub autoenable_created_entities: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_dds_entity_factory_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_entity_factory_qospolicy>(),
        1usize,
        concat!("Size of: ", stringify!(dds_entity_factory_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_entity_factory_qospolicy>(),
        1usize,
        concat!("Alignment of ", stringify!(dds_entity_factory_qospolicy))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_entity_factory_qospolicy>())).autoenable_created_entities
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_entity_factory_qospolicy),
            "::",
            stringify!(autoenable_created_entities)
        )
    );
}
pub type dds_entity_factory_qospolicy_t = dds_entity_factory_qospolicy;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_writer_data_lifecycle_qospolicy {
    pub autodispose_unregistered_instances: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_dds_writer_data_lifecycle_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_writer_data_lifecycle_qospolicy>(),
        1usize,
        concat!("Size of: ", stringify!(dds_writer_data_lifecycle_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_writer_data_lifecycle_qospolicy>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(dds_writer_data_lifecycle_qospolicy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_writer_data_lifecycle_qospolicy>()))
                .autodispose_unregistered_instances as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_writer_data_lifecycle_qospolicy),
            "::",
            stringify!(autodispose_unregistered_instances)
        )
    );
}
pub type dds_writer_data_lifecycle_qospolicy_t = dds_writer_data_lifecycle_qospolicy;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_reader_data_lifecycle_qospolicy {
    pub autopurge_nowriter_samples_delay: dds_duration_t,
    pub autopurge_disposed_samples_delay: dds_duration_t,
}
#[test]
fn bindgen_test_layout_dds_reader_data_lifecycle_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_reader_data_lifecycle_qospolicy>(),
        16usize,
        concat!("Size of: ", stringify!(dds_reader_data_lifecycle_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_reader_data_lifecycle_qospolicy>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(dds_reader_data_lifecycle_qospolicy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_reader_data_lifecycle_qospolicy>()))
                .autopurge_nowriter_samples_delay as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_reader_data_lifecycle_qospolicy),
            "::",
            stringify!(autopurge_nowriter_samples_delay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_reader_data_lifecycle_qospolicy>()))
                .autopurge_disposed_samples_delay as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_reader_data_lifecycle_qospolicy),
            "::",
            stringify!(autopurge_disposed_samples_delay)
        )
    );
}
pub type dds_reader_data_lifecycle_qospolicy_t = dds_reader_data_lifecycle_qospolicy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_subscription_keys_qospolicy {
    pub use_key_list: ::std::os::raw::c_uchar,
    pub key_list: ddsi_stringseq_t,
}
#[test]
fn bindgen_test_layout_dds_subscription_keys_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_subscription_keys_qospolicy>(),
        24usize,
        concat!("Size of: ", stringify!(dds_subscription_keys_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_subscription_keys_qospolicy>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_subscription_keys_qospolicy))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_subscription_keys_qospolicy>())).use_key_list as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_subscription_keys_qospolicy),
            "::",
            stringify!(use_key_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_subscription_keys_qospolicy>())).key_list as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_subscription_keys_qospolicy),
            "::",
            stringify!(key_list)
        )
    );
}
impl Default for dds_subscription_keys_qospolicy {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_subscription_keys_qospolicy_t = dds_subscription_keys_qospolicy;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dds_reader_lifespan_qospolicy {
    pub use_lifespan: ::std::os::raw::c_uchar,
    pub duration: dds_duration_t,
}
#[test]
fn bindgen_test_layout_dds_reader_lifespan_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_reader_lifespan_qospolicy>(),
        16usize,
        concat!("Size of: ", stringify!(dds_reader_lifespan_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_reader_lifespan_qospolicy>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_reader_lifespan_qospolicy))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_reader_lifespan_qospolicy>())).use_lifespan as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_reader_lifespan_qospolicy),
            "::",
            stringify!(use_lifespan)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_reader_lifespan_qospolicy>())).duration as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_reader_lifespan_qospolicy),
            "::",
            stringify!(duration)
        )
    );
}
pub type dds_reader_lifespan_qospolicy_t = dds_reader_lifespan_qospolicy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_ignorelocal_qospolicy {
    pub value: dds_ignorelocal_kind_t,
}
#[test]
fn bindgen_test_layout_dds_ignorelocal_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_ignorelocal_qospolicy>(),
        4usize,
        concat!("Size of: ", stringify!(dds_ignorelocal_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_ignorelocal_qospolicy>(),
        4usize,
        concat!("Alignment of ", stringify!(dds_ignorelocal_qospolicy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_ignorelocal_qospolicy>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_ignorelocal_qospolicy),
            "::",
            stringify!(value)
        )
    );
}
impl Default for dds_ignorelocal_qospolicy {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_ignorelocal_qospolicy_t = dds_ignorelocal_qospolicy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_type_consistency_enforcement_qospolicy {
    pub kind: dds_type_consistency_kind_t,
    pub ignore_sequence_bounds: bool,
    pub ignore_string_bounds: bool,
    pub ignore_member_names: bool,
    pub prevent_type_widening: bool,
    pub force_type_validation: bool,
}
#[test]
fn bindgen_test_layout_dds_type_consistency_enforcement_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_type_consistency_enforcement_qospolicy>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(dds_type_consistency_enforcement_qospolicy)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<dds_type_consistency_enforcement_qospolicy>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dds_type_consistency_enforcement_qospolicy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_type_consistency_enforcement_qospolicy>())).kind as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_type_consistency_enforcement_qospolicy),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_type_consistency_enforcement_qospolicy>()))
                .ignore_sequence_bounds as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_type_consistency_enforcement_qospolicy),
            "::",
            stringify!(ignore_sequence_bounds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_type_consistency_enforcement_qospolicy>()))
                .ignore_string_bounds as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_type_consistency_enforcement_qospolicy),
            "::",
            stringify!(ignore_string_bounds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_type_consistency_enforcement_qospolicy>()))
                .ignore_member_names as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_type_consistency_enforcement_qospolicy),
            "::",
            stringify!(ignore_member_names)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_type_consistency_enforcement_qospolicy>()))
                .prevent_type_widening as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_type_consistency_enforcement_qospolicy),
            "::",
            stringify!(prevent_type_widening)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_type_consistency_enforcement_qospolicy>()))
                .force_type_validation as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_type_consistency_enforcement_qospolicy),
            "::",
            stringify!(force_type_validation)
        )
    );
}
impl Default for dds_type_consistency_enforcement_qospolicy {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_type_consistency_enforcement_qospolicy_t = dds_type_consistency_enforcement_qospolicy;
pub type dds_locator_mask_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_data_representation_id_seq {
    pub n: u32,
    pub ids: *mut dds_data_representation_id_t,
}
#[test]
fn bindgen_test_layout_dds_data_representation_id_seq() {
    assert_eq!(
        ::std::mem::size_of::<dds_data_representation_id_seq>(),
        16usize,
        concat!("Size of: ", stringify!(dds_data_representation_id_seq))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_data_representation_id_seq>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_data_representation_id_seq))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_data_representation_id_seq>())).n as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_data_representation_id_seq),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_data_representation_id_seq>())).ids as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_data_representation_id_seq),
            "::",
            stringify!(ids)
        )
    );
}
impl Default for dds_data_representation_id_seq {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_data_representation_id_seq_t = dds_data_representation_id_seq;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_data_representation_qospolicy {
    pub value: dds_data_representation_id_seq_t,
}
#[test]
fn bindgen_test_layout_dds_data_representation_qospolicy() {
    assert_eq!(
        ::std::mem::size_of::<dds_data_representation_qospolicy>(),
        16usize,
        concat!("Size of: ", stringify!(dds_data_representation_qospolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_data_representation_qospolicy>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(dds_data_representation_qospolicy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dds_data_representation_qospolicy>())).value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_data_representation_qospolicy),
            "::",
            stringify!(value)
        )
    );
}
impl Default for dds_data_representation_qospolicy {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dds_data_representation_qospolicy_t = dds_data_representation_qospolicy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dds_qos {
    pub present: u64,
    pub aliased: u64,
    pub topic_name: *mut ::std::os::raw::c_char,
    pub type_name: *mut ::std::os::raw::c_char,
    pub entity_name: *mut ::std::os::raw::c_char,
    pub type_information: *mut ddsi_typeinfo,
    pub presentation: dds_presentation_qospolicy_t,
    pub partition: dds_partition_qospolicy_t,
    pub group_data: dds_groupdata_qospolicy_t,
    pub entity_factory: dds_entity_factory_qospolicy_t,
    pub topic_data: dds_topicdata_qospolicy_t,
    pub durability: dds_durability_qospolicy_t,
    pub durability_service: dds_durability_service_qospolicy_t,
    pub deadline: dds_deadline_qospolicy_t,
    pub latency_budget: dds_latency_budget_qospolicy_t,
    pub liveliness: dds_liveliness_qospolicy_t,
    pub reliability: dds_reliability_qospolicy_t,
    pub destination_order: dds_destination_order_qospolicy_t,
    pub history: dds_history_qospolicy_t,
    pub resource_limits: dds_resource_limits_qospolicy_t,
    pub transport_priority: dds_transport_priority_qospolicy_t,
    pub lifespan: dds_lifespan_qospolicy_t,
    pub user_data: dds_userdata_qospolicy_t,
    pub ownership: dds_ownership_qospolicy_t,
    pub ownership_strength: dds_ownership_strength_qospolicy_t,
    pub time_based_filter: dds_time_based_filter_qospolicy_t,
    pub writer_data_lifecycle: dds_writer_data_lifecycle_qospolicy_t,
    pub reader_data_lifecycle: dds_reader_data_lifecycle_qospolicy_t,
    pub subscription_keys: dds_subscription_keys_qospolicy_t,
    pub reader_lifespan: dds_reader_lifespan_qospolicy_t,
    pub ignorelocal: dds_ignorelocal_qospolicy_t,
    pub property: dds_property_qospolicy_t,
    pub type_consistency: dds_type_consistency_enforcement_qospolicy_t,
    pub ignore_locator_type: dds_locator_mask_t,
    pub data_representation: dds_data_representation_qospolicy_t,
}
#[test]
fn bindgen_test_layout_dds_qos() {
    assert_eq!(
        ::std::mem::size_of::<dds_qos>(),
        408usize,
        concat!("Size of: ", stringify!(dds_qos))
    );
    assert_eq!(
        ::std::mem::align_of::<dds_qos>(),
        8usize,
        concat!("Alignment of ", stringify!(dds_qos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).present as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(present)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).aliased as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(aliased)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).topic_name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(topic_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).type_name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).entity_name as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(entity_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).type_information as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(type_information)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).presentation as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(presentation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).partition as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(partition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).group_data as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(group_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).entity_factory as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(entity_factory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).topic_data as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(topic_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).durability as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(durability)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).durability_service as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(durability_service)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).deadline as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(deadline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).latency_budget as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(latency_budget)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).liveliness as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(liveliness)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).reliability as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(reliability)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).destination_order as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(destination_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).history as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(history)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).resource_limits as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(resource_limits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).transport_priority as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(transport_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).lifespan as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(lifespan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).user_data as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).ownership as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(ownership)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).ownership_strength as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(ownership_strength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).time_based_filter as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(time_based_filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).writer_data_lifecycle as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(writer_data_lifecycle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).reader_data_lifecycle as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(reader_data_lifecycle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).subscription_keys as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(subscription_keys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).reader_lifespan as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(reader_lifespan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).ignorelocal as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(ignorelocal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).property as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(property)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).type_consistency as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(type_consistency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).ignore_locator_type as *const _ as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(ignore_locator_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dds_qos>())).data_representation as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(dds_qos),
            "::",
            stringify!(data_representation)
        )
    );
}
impl Default for dds_qos {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type ddsi_typeid_t = ddsi_typeid;
pub type ddsi_typeinfo_t = ddsi_typeinfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddsi_typemap {
    _unused: [u8; 0],
}
pub type ddsi_typemap_t = ddsi_typemap;
pub const ddsi_typeid_kind_DDSI_TYPEID_KIND_MINIMAL: ddsi_typeid_kind = 0;
pub const ddsi_typeid_kind_DDSI_TYPEID_KIND_COMPLETE: ddsi_typeid_kind = 1;
pub const ddsi_typeid_kind_DDSI_TYPEID_KIND_PLAIN_COLLECTION_MINIMAL: ddsi_typeid_kind = 2;
pub const ddsi_typeid_kind_DDSI_TYPEID_KIND_PLAIN_COLLECTION_COMPLETE: ddsi_typeid_kind = 3;
pub const ddsi_typeid_kind_DDSI_TYPEID_KIND_FULLY_DESCRIPTIVE: ddsi_typeid_kind = 4;
pub type ddsi_typeid_kind = ::std::os::raw::c_uint;
pub use self::ddsi_typeid_kind as ddsi_typeid_kind_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddsi_sertype {
    pub ops: *const ddsi_sertype_ops,
    pub serdata_ops: *const ddsi_serdata_ops,
    pub serdata_basehash: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub allowed_data_representation: u32,
    pub type_name: *mut ::std::os::raw::c_char,
    pub gv: ddsrt_atomic_voidp_t,
    pub flags_refc: ddsrt_atomic_uint32_t,
    pub base_sertype: *const ddsi_sertype,
    pub wrapped_sertopic: *mut ::std::os::raw::c_void,
    pub iox_size: u32,
}
#[test]
fn bindgen_test_layout_ddsi_sertype() {
    assert_eq!(
        ::std::mem::size_of::<ddsi_sertype>(),
        80usize,
        concat!("Size of: ", stringify!(ddsi_sertype))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsi_sertype>(),
        8usize,
        concat!("Alignment of ", stringify!(ddsi_sertype))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype>())).ops as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype>())).serdata_ops as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype),
            "::",
            stringify!(serdata_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype>())).serdata_basehash as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype),
            "::",
            stringify!(serdata_basehash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ddsi_sertype>())).allowed_data_representation as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype),
            "::",
            stringify!(allowed_data_representation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype>())).type_name as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype>())).gv as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype),
            "::",
            stringify!(gv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype>())).flags_refc as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype),
            "::",
            stringify!(flags_refc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype>())).base_sertype as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype),
            "::",
            stringify!(base_sertype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype>())).wrapped_sertopic as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype),
            "::",
            stringify!(wrapped_sertopic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype>())).iox_size as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype),
            "::",
            stringify!(iox_size)
        )
    );
}
impl Default for ddsi_sertype {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ddsi_sertype {
    #[inline]
    pub fn typekind_no_key(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_typekind_no_key(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_keyhash(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_keyhash(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fixed_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fixed_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        typekind_no_key: u32,
        request_keyhash: u32,
        fixed_size: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let typekind_no_key: u32 = unsafe { ::std::mem::transmute(typekind_no_key) };
            typekind_no_key as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let request_keyhash: u32 = unsafe { ::std::mem::transmute(request_keyhash) };
            request_keyhash as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let fixed_size: u32 = unsafe { ::std::mem::transmute(fixed_size) };
            fixed_size as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ddsi_sertype_equal_t = ::std::option::Option<
    unsafe extern "C" fn(a: *const ddsi_sertype, b: *const ddsi_sertype) -> bool,
>;
pub type ddsi_sertype_hash_t =
    ::std::option::Option<unsafe extern "C" fn(tp: *const ddsi_sertype) -> u32>;
pub type ddsi_sertype_free_t = ::std::option::Option<unsafe extern "C" fn(tp: *mut ddsi_sertype)>;
pub type ddsi_sertype_zero_samples_t = ::std::option::Option<
    unsafe extern "C" fn(
        d: *const ddsi_sertype,
        samples: *mut ::std::os::raw::c_void,
        count: size_t,
    ),
>;
pub type ddsi_sertype_realloc_samples_t = ::std::option::Option<
    unsafe extern "C" fn(
        ptrs: *mut *mut ::std::os::raw::c_void,
        d: *const ddsi_sertype,
        old: *mut ::std::os::raw::c_void,
        oldcount: size_t,
        count: size_t,
    ),
>;
pub type ddsi_sertype_free_samples_t = ::std::option::Option<
    unsafe extern "C" fn(
        d: *const ddsi_sertype,
        ptrs: *mut *mut ::std::os::raw::c_void,
        count: size_t,
        op: dds_free_op_t,
    ),
>;
pub type ddsi_sertype_typeid_t = ::std::option::Option<
    unsafe extern "C" fn(tp: *const ddsi_sertype, kind: ddsi_typeid_kind_t) -> *mut ddsi_typeid_t,
>;
pub type ddsi_sertype_get_serialized_size_t = ::std::option::Option<
    unsafe extern "C" fn(d: *const ddsi_sertype, sample: *const ::std::os::raw::c_void) -> size_t,
>;
pub type ddsi_sertype_serialize_into_t = ::std::option::Option<
    unsafe extern "C" fn(
        d: *const ddsi_sertype,
        sample: *const ::std::os::raw::c_void,
        dst_buffer: *mut ::std::os::raw::c_void,
        dst_size: size_t,
    ) -> bool,
>;
pub type ddsi_sertype_typemap_t =
    ::std::option::Option<unsafe extern "C" fn(tp: *const ddsi_sertype) -> *mut ddsi_typemap_t>;
pub type ddsi_sertype_typeinfo_t =
    ::std::option::Option<unsafe extern "C" fn(tp: *const ddsi_sertype) -> *mut ddsi_typeinfo_t>;
pub type ddsi_sertype_derive_t = ::std::option::Option<
    unsafe extern "C" fn(
        sertype: *const ddsi_sertype,
        data_representation: dds_data_representation_id_t,
        tce_qos: dds_type_consistency_enforcement_qospolicy_t,
    ) -> *mut ddsi_sertype,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddsi_sertype_v0 {
    _unused: [u8; 0],
}
pub type ddsi_sertype_v0_t =
    ::std::option::Option<unsafe extern "C" fn(dummy: *mut ddsi_sertype_v0)>;
extern "C" {
    pub fn ddsi_sertype_v0(dummy: *mut ddsi_sertype_v0);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddsi_sertype_ops {
    pub version: ddsi_sertype_v0_t,
    pub arg: *mut ::std::os::raw::c_void,
    pub free: ddsi_sertype_free_t,
    pub zero_samples: ddsi_sertype_zero_samples_t,
    pub realloc_samples: ddsi_sertype_realloc_samples_t,
    pub free_samples: ddsi_sertype_free_samples_t,
    pub equal: ddsi_sertype_equal_t,
    pub hash: ddsi_sertype_hash_t,
    pub type_id: ddsi_sertype_typeid_t,
    pub type_map: ddsi_sertype_typemap_t,
    pub type_info: ddsi_sertype_typeinfo_t,
    pub derive_sertype: ddsi_sertype_derive_t,
    pub get_serialized_size: ddsi_sertype_get_serialized_size_t,
    pub serialize_into: ddsi_sertype_serialize_into_t,
}
#[test]
fn bindgen_test_layout_ddsi_sertype_ops() {
    assert_eq!(
        ::std::mem::size_of::<ddsi_sertype_ops>(),
        112usize,
        concat!("Size of: ", stringify!(ddsi_sertype_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsi_sertype_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(ddsi_sertype_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype_ops>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype_ops>())).arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype_ops>())).free as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype_ops>())).zero_samples as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(zero_samples)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ddsi_sertype_ops>())).realloc_samples as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(realloc_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype_ops>())).free_samples as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(free_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype_ops>())).equal as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(equal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype_ops>())).hash as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype_ops>())).type_id as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(type_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype_ops>())).type_map as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(type_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype_ops>())).type_info as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(type_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype_ops>())).derive_sertype as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(derive_sertype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ddsi_sertype_ops>())).get_serialized_size as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(get_serialized_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_sertype_ops>())).serialize_into as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_sertype_ops),
            "::",
            stringify!(serialize_into)
        )
    );
}
impl Default for ddsi_sertype_ops {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn ddsi_sertype_init(
        tp: *mut ddsi_sertype,
        type_name: *const ::std::os::raw::c_char,
        sertype_ops: *const ddsi_sertype_ops,
        serdata_ops: *const ddsi_serdata_ops,
        topickind_no_key: bool,
    );
}
extern "C" {
    pub fn ddsi_sertype_fini(tp: *mut ddsi_sertype);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ddsi_keyhash {
    pub value: [::std::os::raw::c_uchar; 16usize],
}
#[test]
fn bindgen_test_layout_ddsi_keyhash() {
    assert_eq!(
        ::std::mem::size_of::<ddsi_keyhash>(),
        16usize,
        concat!("Size of: ", stringify!(ddsi_keyhash))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsi_keyhash>(),
        1usize,
        concat!("Alignment of ", stringify!(ddsi_keyhash))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_keyhash>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_keyhash),
            "::",
            stringify!(value)
        )
    );
}
pub type ddsi_keyhash_t = ddsi_keyhash;
pub const ddsi_serdata_kind_SDK_EMPTY: ddsi_serdata_kind = 0;
pub const ddsi_serdata_kind_SDK_KEY: ddsi_serdata_kind = 1;
pub const ddsi_serdata_kind_SDK_DATA: ddsi_serdata_kind = 2;
pub type ddsi_serdata_kind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddsi_serdata {
    pub ops: *const ddsi_serdata_ops,
    pub hash: u32,
    pub refc: ddsrt_atomic_uint32_t,
    pub kind: ddsi_serdata_kind,
    pub type_: *const ddsi_sertype,
    pub timestamp: ddsrt_wctime_t,
    pub statusinfo: u32,
    pub twrite: ddsrt_mtime_t,
    pub iox_chunk: *mut ::std::os::raw::c_void,
    pub iox_subscriber: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ddsi_serdata() {
    assert_eq!(
        ::std::mem::size_of::<ddsi_serdata>(),
        72usize,
        concat!("Size of: ", stringify!(ddsi_serdata))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsi_serdata>(),
        8usize,
        concat!("Alignment of ", stringify!(ddsi_serdata))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata>())).ops as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata>())).hash as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata>())).refc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata),
            "::",
            stringify!(refc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata>())).kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata>())).type_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata>())).timestamp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata>())).statusinfo as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata),
            "::",
            stringify!(statusinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata>())).twrite as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata),
            "::",
            stringify!(twrite)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata>())).iox_chunk as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata),
            "::",
            stringify!(iox_chunk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata>())).iox_subscriber as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata),
            "::",
            stringify!(iox_subscriber)
        )
    );
}
impl Default for ddsi_serdata {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type ddsi_serdata_size_t =
    ::std::option::Option<unsafe extern "C" fn(d: *const ddsi_serdata) -> u32>;
pub type ddsi_serdata_free_t = ::std::option::Option<unsafe extern "C" fn(d: *mut ddsi_serdata)>;
pub type ddsi_serdata_from_ser_t = ::std::option::Option<
    unsafe extern "C" fn(
        type_: *const ddsi_sertype,
        kind: ddsi_serdata_kind,
        fragchain: *const nn_rdata,
        size: size_t,
    ) -> *mut ddsi_serdata,
>;
pub type ddsi_serdata_from_ser_iov_t = ::std::option::Option<
    unsafe extern "C" fn(
        type_: *const ddsi_sertype,
        kind: ddsi_serdata_kind,
        niov: ddsrt_msg_iovlen_t,
        iov: *const ddsrt_iovec_t,
        size: size_t,
    ) -> *mut ddsi_serdata,
>;
pub type ddsi_serdata_from_keyhash_t = ::std::option::Option<
    unsafe extern "C" fn(
        type_: *const ddsi_sertype,
        keyhash: *const ddsi_keyhash,
    ) -> *mut ddsi_serdata,
>;
pub type ddsi_serdata_from_sample_t = ::std::option::Option<
    unsafe extern "C" fn(
        type_: *const ddsi_sertype,
        kind: ddsi_serdata_kind,
        sample: *const ::std::os::raw::c_void,
    ) -> *mut ddsi_serdata,
>;
pub type ddsi_serdata_to_untyped_t =
    ::std::option::Option<unsafe extern "C" fn(d: *const ddsi_serdata) -> *mut ddsi_serdata>;
pub type ddsi_serdata_to_ser_t = ::std::option::Option<
    unsafe extern "C" fn(
        d: *const ddsi_serdata,
        off: size_t,
        sz: size_t,
        buf: *mut ::std::os::raw::c_void,
    ),
>;
pub type ddsi_serdata_to_ser_ref_t = ::std::option::Option<
    unsafe extern "C" fn(
        d: *const ddsi_serdata,
        off: size_t,
        sz: size_t,
        ref_: *mut ddsrt_iovec_t,
    ) -> *mut ddsi_serdata,
>;
pub type ddsi_serdata_to_ser_unref_t =
    ::std::option::Option<unsafe extern "C" fn(d: *mut ddsi_serdata, ref_: *const ddsrt_iovec_t)>;
pub type ddsi_serdata_to_sample_t = ::std::option::Option<
    unsafe extern "C" fn(
        d: *const ddsi_serdata,
        sample: *mut ::std::os::raw::c_void,
        bufptr: *mut *mut ::std::os::raw::c_void,
        buflim: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
pub type ddsi_serdata_untyped_to_sample_t = ::std::option::Option<
    unsafe extern "C" fn(
        type_: *const ddsi_sertype,
        d: *const ddsi_serdata,
        sample: *mut ::std::os::raw::c_void,
        bufptr: *mut *mut ::std::os::raw::c_void,
        buflim: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
pub type ddsi_serdata_eqkey_t = ::std::option::Option<
    unsafe extern "C" fn(a: *const ddsi_serdata, b: *const ddsi_serdata) -> bool,
>;
pub type ddsi_serdata_print_t = ::std::option::Option<
    unsafe extern "C" fn(
        type_: *const ddsi_sertype,
        d: *const ddsi_serdata,
        buf: *mut ::std::os::raw::c_char,
        size: size_t,
    ) -> size_t,
>;
pub type ddsi_serdata_get_keyhash_t = ::std::option::Option<
    unsafe extern "C" fn(d: *const ddsi_serdata, buf: *mut ddsi_keyhash, force_md5: bool),
>;
pub type ddsi_serdata_iox_size_t =
    ::std::option::Option<unsafe extern "C" fn(d: *const ddsi_serdata) -> u32>;
pub type ddsi_serdata_from_iox_t = ::std::option::Option<
    unsafe extern "C" fn(
        type_: *const ddsi_sertype,
        kind: ddsi_serdata_kind,
        sub: *mut ::std::os::raw::c_void,
        buffer: *mut ::std::os::raw::c_void,
    ) -> *mut ddsi_serdata,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ddsi_serdata_ops {
    pub eqkey: ddsi_serdata_eqkey_t,
    pub get_size: ddsi_serdata_size_t,
    pub from_ser: ddsi_serdata_from_ser_t,
    pub from_ser_iov: ddsi_serdata_from_ser_iov_t,
    pub from_keyhash: ddsi_serdata_from_keyhash_t,
    pub from_sample: ddsi_serdata_from_sample_t,
    pub to_ser: ddsi_serdata_to_ser_t,
    pub to_ser_ref: ddsi_serdata_to_ser_ref_t,
    pub to_ser_unref: ddsi_serdata_to_ser_unref_t,
    pub to_sample: ddsi_serdata_to_sample_t,
    pub to_untyped: ddsi_serdata_to_untyped_t,
    pub untyped_to_sample: ddsi_serdata_untyped_to_sample_t,
    pub free: ddsi_serdata_free_t,
    pub print: ddsi_serdata_print_t,
    pub get_keyhash: ddsi_serdata_get_keyhash_t,
    pub get_sample_size: ddsi_serdata_iox_size_t,
    pub from_iox_buffer: ddsi_serdata_from_iox_t,
}
#[test]
fn bindgen_test_layout_ddsi_serdata_ops() {
    assert_eq!(
        ::std::mem::size_of::<ddsi_serdata_ops>(),
        136usize,
        concat!("Size of: ", stringify!(ddsi_serdata_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsi_serdata_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(ddsi_serdata_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).eqkey as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(eqkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).get_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(get_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).from_ser as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(from_ser)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).from_ser_iov as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(from_ser_iov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).from_keyhash as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(from_keyhash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).from_sample as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(from_sample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).to_ser as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(to_ser)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).to_ser_ref as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(to_ser_ref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).to_ser_unref as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(to_ser_unref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).to_sample as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(to_sample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).to_untyped as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(to_untyped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ddsi_serdata_ops>())).untyped_to_sample as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(untyped_to_sample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).free as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).print as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(print)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsi_serdata_ops>())).get_keyhash as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(get_keyhash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ddsi_serdata_ops>())).get_sample_size as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(get_sample_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ddsi_serdata_ops>())).from_iox_buffer as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsi_serdata_ops),
            "::",
            stringify!(from_iox_buffer)
        )
    );
}
extern "C" {
    pub fn ddsi_serdata_init(
        d: *mut ddsi_serdata,
        type_: *const ddsi_sertype,
        kind: ddsi_serdata_kind,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_rbuf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nn_rmsg_chunk {
    pub rbuf: *mut nn_rbuf,
    pub next: *mut nn_rmsg_chunk,
    pub u: nn_rmsg_chunk__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nn_rmsg_chunk__bindgen_ty_1 {
    pub size: u32,
    pub l: i64,
    pub d: f64,
    pub p: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_nn_rmsg_chunk__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<nn_rmsg_chunk__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(nn_rmsg_chunk__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<nn_rmsg_chunk__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(nn_rmsg_chunk__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nn_rmsg_chunk__bindgen_ty_1>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rmsg_chunk__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rmsg_chunk__bindgen_ty_1>())).l as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rmsg_chunk__bindgen_ty_1),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rmsg_chunk__bindgen_ty_1>())).d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rmsg_chunk__bindgen_ty_1),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rmsg_chunk__bindgen_ty_1>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rmsg_chunk__bindgen_ty_1),
            "::",
            stringify!(p)
        )
    );
}
impl Default for nn_rmsg_chunk__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_nn_rmsg_chunk() {
    assert_eq!(
        ::std::mem::size_of::<nn_rmsg_chunk>(),
        24usize,
        concat!("Size of: ", stringify!(nn_rmsg_chunk))
    );
    assert_eq!(
        ::std::mem::align_of::<nn_rmsg_chunk>(),
        8usize,
        concat!("Alignment of ", stringify!(nn_rmsg_chunk))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rmsg_chunk>())).rbuf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rmsg_chunk),
            "::",
            stringify!(rbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rmsg_chunk>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rmsg_chunk),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rmsg_chunk>())).u as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rmsg_chunk),
            "::",
            stringify!(u)
        )
    );
}
impl Default for nn_rmsg_chunk {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nn_rmsg {
    pub refcount: ddsrt_atomic_uint32_t,
    pub lastchunk: *mut nn_rmsg_chunk,
    pub trace: bool,
    pub chunk: nn_rmsg_chunk,
}
#[test]
fn bindgen_test_layout_nn_rmsg() {
    assert_eq!(
        ::std::mem::size_of::<nn_rmsg>(),
        48usize,
        concat!("Size of: ", stringify!(nn_rmsg))
    );
    assert_eq!(
        ::std::mem::align_of::<nn_rmsg>(),
        8usize,
        concat!("Alignment of ", stringify!(nn_rmsg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rmsg>())).refcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rmsg),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rmsg>())).lastchunk as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rmsg),
            "::",
            stringify!(lastchunk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rmsg>())).trace as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rmsg),
            "::",
            stringify!(trace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rmsg>())).chunk as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rmsg),
            "::",
            stringify!(chunk)
        )
    );
}
impl Default for nn_rmsg {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_rdata {
    pub rmsg: *mut nn_rmsg,
    pub nextfrag: *mut nn_rdata,
    pub min: u32,
    pub maxp1: u32,
    pub submsg_zoff: u16,
    pub payload_zoff: u16,
    pub keyhash_zoff: u16,
    pub refcount_bias_added: ddsrt_atomic_uint32_t,
}
#[test]
fn bindgen_test_layout_nn_rdata() {
    assert_eq!(
        ::std::mem::size_of::<nn_rdata>(),
        40usize,
        concat!("Size of: ", stringify!(nn_rdata))
    );
    assert_eq!(
        ::std::mem::align_of::<nn_rdata>(),
        8usize,
        concat!("Alignment of ", stringify!(nn_rdata))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rdata>())).rmsg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rdata),
            "::",
            stringify!(rmsg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rdata>())).nextfrag as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rdata),
            "::",
            stringify!(nextfrag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rdata>())).min as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rdata),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rdata>())).maxp1 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rdata),
            "::",
            stringify!(maxp1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rdata>())).submsg_zoff as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rdata),
            "::",
            stringify!(submsg_zoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rdata>())).payload_zoff as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rdata),
            "::",
            stringify!(payload_zoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rdata>())).keyhash_zoff as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rdata),
            "::",
            stringify!(keyhash_zoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nn_rdata>())).refcount_bias_added as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nn_rdata),
            "::",
            stringify!(refcount_bias_added)
        )
    );
}
impl Default for nn_rdata {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type ddsrt_md5_byte_t = ::std::os::raw::c_uchar;
pub type ddsrt_md5_word_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ddsrt_md5_state_s {
    pub count: [ddsrt_md5_word_t; 2usize],
    pub abcd: [ddsrt_md5_word_t; 4usize],
    pub buf: [ddsrt_md5_byte_t; 64usize],
}
#[test]
fn bindgen_test_layout_ddsrt_md5_state_s() {
    assert_eq!(
        ::std::mem::size_of::<ddsrt_md5_state_s>(),
        88usize,
        concat!("Size of: ", stringify!(ddsrt_md5_state_s))
    );
    assert_eq!(
        ::std::mem::align_of::<ddsrt_md5_state_s>(),
        4usize,
        concat!("Alignment of ", stringify!(ddsrt_md5_state_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsrt_md5_state_s>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsrt_md5_state_s),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsrt_md5_state_s>())).abcd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsrt_md5_state_s),
            "::",
            stringify!(abcd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddsrt_md5_state_s>())).buf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ddsrt_md5_state_s),
            "::",
            stringify!(buf)
        )
    );
}
impl Default for ddsrt_md5_state_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type ddsrt_md5_state_t = ddsrt_md5_state_s;
extern "C" {
    pub fn ddsrt_md5_init(pms: *mut ddsrt_md5_state_t);
}
extern "C" {
    pub fn ddsrt_md5_append(
        pms: *mut ddsrt_md5_state_t,
        data: *const ddsrt_md5_byte_t,
        nbytes: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn ddsrt_md5_finish(pms: *mut ddsrt_md5_state_t, digest: *mut ddsrt_md5_byte_t);
}
pub const ddsi_shm_loglevel_DDSI_SHM_OFF: ddsi_shm_loglevel = 0;
pub const ddsi_shm_loglevel_DDSI_SHM_FATAL: ddsi_shm_loglevel = 1;
pub const ddsi_shm_loglevel_DDSI_SHM_ERROR: ddsi_shm_loglevel = 2;
pub const ddsi_shm_loglevel_DDSI_SHM_WARN: ddsi_shm_loglevel = 3;
pub const ddsi_shm_loglevel_DDSI_SHM_INFO: ddsi_shm_loglevel = 4;
pub const ddsi_shm_loglevel_DDSI_SHM_DEBUG: ddsi_shm_loglevel = 5;
pub const ddsi_shm_loglevel_DDSI_SHM_VERBOSE: ddsi_shm_loglevel = 6;
pub type ddsi_shm_loglevel = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpp2c_Publisher {
    _unused: [u8; 0],
}
pub type iox_pub_t = *mut cpp2c_Publisher;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpp2c_Subscriber {
    _unused: [u8; 0],
}
pub type iox_sub_t = *mut cpp2c_Subscriber;
pub const iox_shm_data_state_t_IOX_CHUNK_UNINITIALIZED: iox_shm_data_state_t = 0;
pub const iox_shm_data_state_t_IOX_CHUNK_CONTAINS_RAW_DATA: iox_shm_data_state_t = 1;
pub const iox_shm_data_state_t_IOX_CHUNK_CONTAINS_SERIALIZED_DATA: iox_shm_data_state_t = 2;
pub type iox_shm_data_state_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iceoryx_header {
    pub guid: ddsi_guid,
    pub tstamp: dds_time_t,
    pub statusinfo: u32,
    pub data_size: u32,
    pub data_kind: ::std::os::raw::c_uchar,
    pub keyhash: ddsi_keyhash_t,
    pub shm_data_state: iox_shm_data_state_t,
}
#[test]
fn bindgen_test_layout_iceoryx_header() {
    assert_eq!(
        ::std::mem::size_of::<iceoryx_header>(),
        56usize,
        concat!("Size of: ", stringify!(iceoryx_header))
    );
    assert_eq!(
        ::std::mem::align_of::<iceoryx_header>(),
        8usize,
        concat!("Alignment of ", stringify!(iceoryx_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iceoryx_header>())).guid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iceoryx_header),
            "::",
            stringify!(guid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iceoryx_header>())).tstamp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(iceoryx_header),
            "::",
            stringify!(tstamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iceoryx_header>())).statusinfo as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(iceoryx_header),
            "::",
            stringify!(statusinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iceoryx_header>())).data_size as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(iceoryx_header),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iceoryx_header>())).data_kind as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(iceoryx_header),
            "::",
            stringify!(data_kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iceoryx_header>())).keyhash as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(iceoryx_header),
            "::",
            stringify!(keyhash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iceoryx_header>())).shm_data_state as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(iceoryx_header),
            "::",
            stringify!(shm_data_state)
        )
    );
}
impl Default for iceoryx_header {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type iceoryx_header_t = iceoryx_header;
extern "C" {
    pub fn shm_lock_iox_sub(sub: iox_sub_t);
}
extern "C" {
    pub fn shm_unlock_iox_sub(sub: iox_sub_t);
}
extern "C" {
    pub fn free_iox_chunk(iox_sub: *mut iox_sub_t, iox_chunk: *mut *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn iceoryx_header_from_chunk(
        iox_chunk: *const ::std::os::raw::c_void,
    ) -> *mut iceoryx_header_t;
}
extern "C" {
    pub fn shm_set_loglevel(arg1: ddsi_shm_loglevel);
}
extern "C" {
    pub fn shm_create_chunk(iox_pub: iox_pub_t, size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn shm_set_data_state(
        iox_chunk: *mut ::std::os::raw::c_void,
        data_state: iox_shm_data_state_t,
    );
}
extern "C" {
    pub fn shm_get_data_state(iox_chunk: *mut ::std::os::raw::c_void) -> iox_shm_data_state_t;
}
extern "C" {
    pub fn dds_is_loan_available(entity: dds_entity_t) -> bool;
}
extern "C" {
    pub fn dds_is_shared_memory_available(entity: dds_entity_t) -> bool;
}
extern "C" {
    pub fn dds_loan_shared_memory_buffer(
        writer: dds_entity_t,
        size: size_t,
        buffer: *mut *mut ::std::os::raw::c_void,
    ) -> dds_return_t;
}
extern "C" {
    pub fn dds_loan_sample(
        writer: dds_entity_t,
        sample: *mut *mut ::std::os::raw::c_void,
    ) -> dds_return_t;
}
extern "C" {
    pub fn _dummy(status: dds_status_id_t);
}
extern "C" {
    pub fn ddsi_serdata_addref(serdata_const: *const ddsi_serdata) -> *mut ddsi_serdata;
}
extern "C" {
    pub fn ddsi_serdata_removeref(serdata: *mut ddsi_serdata);
}
pub const BUILTIN_TOPIC_DCPSPARTICIPANT: ::std::os::raw::c_int = 2147418113;
pub const BUILTIN_TOPIC_DCPSTOPIC: ::std::os::raw::c_int = 2147418114;
pub const BUILTIN_TOPIC_DCPSPUBLICATION: ::std::os::raw::c_int = 2147418115;
pub const BUILTIN_TOPIC_DCPSSUBSCRIPTION: ::std::os::raw::c_int = 2147418116;
